(*  Title:       FreeCategory
    Author:      Eugene W. Stark <stark@cs.stonybrook.edu>, 2016
    Maintainer:  Eugene W. Stark <stark@cs.stonybrook.edu>
*)

chapter FreeCategory

theory FreeCategory
imports Category AbstractedCategory
begin

  text{*
    This theory defines locales for constructing the free category generated by
    a graph, as well as some special cases, including the discrete category generated
    by a set of objects, the ``quiver'' generated by a set of arrows, and a ``parallel pair''
    of arrows, which is the diagram shape required for equalizers.
    Other diagram shapes can be constructed in a similar fashion.
    The development looks more complicated that it really is, for two reasons:
    first, for each particular construction once the desired category is obtained it is
    necessary to establish facts that completely characterize its structure and allow it to be
    used in applications; and second, for each construction we define an opaque arrow type
    to ensure that client theories depend only on the explicit characterizing facts and
    not on any properties implicit in the particular construction.
  *}

  section Graphs

  text{*
    The following locale gives a definition of graphs in a traditional style.
  *}

  locale graph =
  fixes Obj :: "'obj set"
  and Arr :: "'arr set"
  and Dom :: "'arr \<Rightarrow> 'obj"
  and Cod :: "'arr \<Rightarrow> 'obj"
  assumes dom_is_obj: "x \<in> Arr \<Longrightarrow> Dom x \<in> Obj"
  and cod_is_obj: "x \<in> Arr \<Longrightarrow> Cod x \<in> Obj"
  begin

    text{*
      The list of arrows @{term p} forms a path from object @{term x} to object @{term y}
      if the domains and codomains of the arrows match up in the expected way.
    *}

    definition path
    where "path x y p \<equiv> (p = [] \<and> x = y \<and> x \<in> Obj) \<or>
                        (p \<noteq> [] \<and> x = Dom (hd p) \<and> y = Cod (last p) \<and>
                        (\<forall>n. n \<ge> 0 \<and> n < length p \<longrightarrow> nth p n \<in> Arr) \<and>
                        (\<forall>n. n \<ge> 0 \<and> n < (length p)-1 \<longrightarrow> Cod (nth p n) = Dom (nth p (n+1))))"

    lemma path_Obj:
    assumes "x \<in> Obj"
    shows "path x x []"
      using assms path_def by simp

    lemma path_single_Arr:
    assumes "x \<in> Arr"
    shows "path (Dom x) (Cod x) [x]"
      using assms path_def by simp

    lemma path_concat:
    assumes "path x y p" and "path y z q"
    shows "path x z (p @ q)"
    proof -
      have "p = [] \<or> q = [] \<Longrightarrow> ?thesis"
        using assms path_def by auto
      moreover have "p \<noteq> [] \<and> q \<noteq> [] \<Longrightarrow> ?thesis"
      proof -
        assume pq: "p \<noteq> [] \<and> q \<noteq> []"
        have Cod_last: "Cod (last p) = Cod (nth (p @ q) ((length p)-1))"
          using assms pq by (simp add: last_conv_nth nth_append)
        moreover have Dom_hd: "Dom (hd q) = Dom (nth (p @ q) (length p))"
          using assms pq by (simp add: hd_conv_nth less_not_refl2 nth_append)
        show ?thesis
        proof -
          have 1: "\<And>n. n \<ge> 0 \<and> n < length (p @ q) \<Longrightarrow> nth (p @ q) n \<in> Arr"
          proof -
            fix n
            assume n: "n \<ge> 0 \<and> n < length (p @ q)"
            have "(n \<ge> 0 \<and> n < length p) \<or> (n \<ge> length p \<and> n < length (p @ q))"
              using n by auto
            thus "nth (p @ q) n \<in> Arr"
              using assms pq nth_append path_def le_add_diff_inverse length_append
                    less_eq_nat.simps(1) nat_add_left_cancel_less
              by metis
          qed
          have 2: "\<And>n. n \<ge> 0 \<and> n < length (p @ q) - 1 \<Longrightarrow>
                                    Cod (nth (p @ q) n) = Dom (nth (p @ q) (n+1))"
          proof -
            fix n
            assume n: "n \<ge> 0 \<and> n < length (p @ q) - 1"
            have 1: "(n \<ge> 0 \<and> n < (length p) - 1) \<or> (n \<ge> length p \<and> n < length (p @ q) - 1)
                       \<or> n = (length p) - 1"
              using n by auto
            thus "Cod (nth (p @ q) n) = Dom (nth (p @ q) (n+1))"
            proof -
              have "n \<ge> 0 \<and> n < (length p) - 1 \<Longrightarrow> ?thesis"
                using assms pq nth_append path_def by (metis add_lessD1 less_diff_conv)
              moreover have "n = (length p) - 1 \<Longrightarrow> ?thesis"
                using assms pq nth_append path_def Dom_hd Cod_last by simp
              moreover have "n \<ge> length p \<and> n < length (p @ q) - 1 \<Longrightarrow> ?thesis"
              proof -
                assume 1: "n \<ge> length p \<and> n < length (p @ q) - 1"
                have "Cod (nth (p @ q) n) = Cod (nth q (n - length p))"
                  using 1 nth_append leD by metis
                also have "... = Dom (nth q (n - length p + 1))"
                  using 1 assms(2) path_def by auto
                also have "... = Dom (nth (p @ q) (n + 1))"
                  using 1 nth_append
                  by (metis Nat.add_diff_assoc2 ex_least_nat_le le_0_eq le_add1 le_neq_implies_less
                            le_refl le_trans length_0_conv pq)
                finally show "Cod (nth (p @ q) n) = Dom (nth (p @ q) (n + 1))" by auto
              qed
              ultimately show ?thesis using 1 by auto
            qed
          qed
          show ?thesis
            unfolding path_def using assms pq path_def hd_append2 Cod_last Dom_hd 1 2
            by simp
        qed
      qed
      ultimately show ?thesis by auto
    qed

  end

  section "Free Categories"

  text{*
    The free category generated by a graph has as its arrows all triples @{term "(x, y, p)"},
    where @{term x} and @{term y} are objects and @{term p} is a path from @{term x} to @{term y}.
    We use an option type to provide a value to be used for @{term null}.
  *}

  locale free_category = G: graph Obj Arr D C
  for Obj :: "'obj set"
  and Arr :: "'arr set"
  and D :: "'arr \<Rightarrow> 'obj"
  and C :: "'arr \<Rightarrow> 'obj"
  begin

    typedef ('o, 'a) arr = "UNIV :: ('o * 'o * 'a list) option set" ..

    definition Null
    where "Null = Abs_arr None"

    definition Dom
    where "Dom f = fst (the (Rep_arr f))"

    definition Cod
    where "Cod f = fst (snd (the (Rep_arr f)))"

    definition Path
    where "Path f = snd (snd (the (Rep_arr f)))"

    definition mkArr
    where "mkArr x y p \<equiv> if G.path x y p then Abs_arr (Some (x, y, p)) else Null"

    abbreviation isArr
    where "isArr f \<equiv> f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"

    lemma mkArr_not_Null:
    shows "mkArr x y p \<noteq> Null \<longleftrightarrow> G.path x y p"
      using mkArr_def
      by (metis Abs_arr_inverse Null_def UNIV_I assms option.distinct(1))

    lemma Dom_mkArr [simp]:
    assumes "mkArr x y p \<noteq> Null"
    shows "Dom (mkArr x y p) = x"
      using assms mkArr_def Dom_def
      by (metis Abs_arr_inverse UNIV_I fst_conv option.sel)

    lemma Cod_mkArr [simp]:
    assumes "mkArr x y p \<noteq> Null"
    shows "Cod (mkArr x y p) = y"
      using assms mkArr_def Cod_def
      by (metis Abs_arr_inverse UNIV_I fst_conv snd_conv option.sel)

    lemma Path_mkArr [simp]:
    assumes "mkArr x y p \<noteq> Null"
    shows "Path (mkArr x y p) = p"
      using assms mkArr_def Path_def
      by (metis Abs_arr_inverse UNIV_I snd_conv option.sel)

    lemma mkArr_Path [simp]:
    assumes "isArr f"
    shows "mkArr (Dom f) (Cod f) (Path f) = f"
      by (metis Cod_def Dom_def Null_def Path_def Rep_arr_inverse assms mkArr_def
                option.exhaust_sel surjective_pairing)

    lemma Dom_in_Obj:
    assumes "isArr f"
    shows "Dom f \<in> Obj"
      using assms G.path_def G.dom_is_obj hd_conv_nth leI length_greater_0_conv
            less_numeral_extra(3)
      by fastforce

    lemma Cod_in_Obj:
    assumes "isArr f"
    shows "Cod f \<in> Obj"
      using assms G.path_def G.cod_is_obj
      by (metis diff_less last_conv_nth leI length_greater_0_conv less_imp_le_nat neq0_conv
                not_one_le_zero)

    text{*
      Composition is concatenation of paths.
    *}

    definition comp
    where "comp g f \<equiv> if isArr g \<and> isArr f \<and> Dom g = Cod f
                      then mkArr (Dom f) (Cod g) (Path f @ Path g)
                      else Null"

    interpretation partial_magma comp
    proof
      show "\<exists>!n. \<forall>f. comp n f = n \<and> comp f n = n"
        using comp_def by metis
    qed

    lemma null_char:
    shows "null = Null"
      by (metis comp_null(1) comp_def)

    lemma in_Obj_implies_unit:
    assumes "x \<in> Obj"
    shows "unit (mkArr x x [])"
      unfolding unit_def
      using comp_def null_char Cod_mkArr Dom_mkArr Path_mkArr append_Nil append_Nil2 mkArr_Path
      by fastforce

    lemma has_dom_char:
    shows "has_dom f \<longleftrightarrow> isArr f"
    proof
      show "has_dom f \<Longrightarrow> isArr f"
        unfolding has_dom_def
        by (metis comp_def null_char)
      show "isArr f \<Longrightarrow> has_dom f"
        unfolding has_dom_def
        using Dom_in_Obj G.path_Obj comp_def mkArr_not_Null null_char in_Obj_implies_unit
              self_append_conv2
        by fastforce
    qed

    lemma has_cod_char:
    shows "has_cod f \<longleftrightarrow> isArr f"
    proof
      show "has_cod f \<Longrightarrow> isArr f"
        unfolding has_cod_def
        by (metis comp_def null_char)
      show "isArr f \<Longrightarrow> has_cod f"
        unfolding has_cod_def
        using Cod_in_Obj Cod_mkArr G.path_Obj comp_def mkArr_not_Null null_char in_Obj_implies_unit
        by fastforce
    qed

    interpretation category comp
    proof
      fix f g h
      assume hg: "comp h g \<noteq> null" and hgf: "comp (comp h g) f \<noteq> null"
      have "isArr f \<and> isArr g \<and> Dom g = Cod f"
        using hg hgf comp_def null_char Dom_mkArr by metis
      thus "comp g f \<noteq> null"
        using comp_def null_char mkArr_not_Null G.path_concat by auto
      next
      fix f g h
      assume gf: "comp g f \<noteq> null" and hgf: "comp h (comp g f) \<noteq> null"
      have "isArr h \<and> isArr g"
        using gf hgf by (metis comp_def null_char)
      moreover from this have "Dom h = Cod g"
        using gf hgf Cod_mkArr [of "Dom g" "Cod g" "Path g"]
        by (metis (full_types) Cod_mkArr comp_def null_char)
      ultimately show "comp h g \<noteq> null"
        using comp_def null_char mkArr_not_Null G.path_concat by auto
      next
      fix f g h
      assume gf: "comp g f \<noteq> null" and hg: "comp h g \<noteq> null"
      have 1: "isArr h \<and> isArr g \<and> isArr f \<and> Dom h = Cod g \<and> Dom g = Cod f"
        using gf hg comp_def null_char by metis
      show "comp h (comp g f) \<noteq> null"
        using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
        by auto
      show "comp (comp h g) f \<noteq> null"
        using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
        by auto
      show "comp h (comp g f) = comp (comp h g) f"
        using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
              append_assoc
        by force
      next
      show "\<And>f. has_dom f = has_cod f" using has_dom_char has_cod_char by auto
    qed

    lemma is_category:
    shows "category comp" ..

  end

  sublocale free_category \<subseteq> category comp
    using is_category by auto

  context free_category
  begin

    lemma arr_char:
    shows "arr f \<longleftrightarrow> isArr f"
      by (simp add: arr_def has_cod_char has_dom_iff_has_cod)

    lemma dom_char:
    shows "dom f = (if arr f then mkArr (Dom f) (Dom f) [] else null)"
    proof -
      have "\<not>arr f \<Longrightarrow> dom f = null"
        using arr_char has_domD(1) dom_def by auto
      moreover have "arr f \<Longrightarrow> dom f = mkArr (Dom f) (Dom f) []"
      proof -
        assume f: "arr f"
        have "unit (mkArr (Dom f) (Dom f) [])"
          using f arr_char in_Obj_implies_unit by (simp add: Dom_in_Obj)
        moreover have "comp f (mkArr (Dom f) (Dom f) []) = f"
          using f arr_char comp_def
          by (simp add: Dom_in_Obj G.path_Obj mkArr_not_Null)
        ultimately show ?thesis
          using dom_simp f not_arr_null by force
      qed
      ultimately show ?thesis by auto
    qed

    lemma cod_char:
    shows "cod f = (if arr f then mkArr (Cod f) (Cod f) [] else null)"
    proof -
      have "\<not>arr f \<Longrightarrow> cod f = null"
        using arr_char has_codD(1) cod_def by auto
      moreover have "arr f \<Longrightarrow> cod f = mkArr (Cod f) (Cod f) []"
      proof -
        assume f: "arr f"
        have "unit (mkArr (Cod f) (Cod f) [])"
          using f arr_char in_Obj_implies_unit by (simp add: Cod_in_Obj)
        moreover have "comp (mkArr (Cod f) (Cod f) []) f = f"
          using f arr_char comp_def
          by (simp add: Cod_in_Obj G.path_Obj mkArr_not_Null)
        ultimately show ?thesis
          using cod_simp f not_arr_null by force
      qed
      ultimately show ?thesis by auto
    qed

    lemma comp_char:
    shows "comp g f = (if seq g f then mkArr (Dom f) (Cod g) (Path f @ Path g) else null)"
      by (metis arr_char arr_comp cod_char dom_char comp_def null_char)

    lemma ide_char:
    shows "ide f \<longleftrightarrow> f \<in> (\<lambda>x. mkArr x x []) ` Obj"
    proof
      show "ide f \<Longrightarrow> f \<in> (\<lambda>x. mkArr x x []) ` Obj"
        by (metis (no_types, lifting) Dom_in_Obj arr_char dom_char ideD(2) image_iff ideD(1))
      show "f \<in> (\<lambda>x. mkArr x x []) ` Obj \<Longrightarrow> ide f"
        using G.path_Obj arr_char dom_char mkArr_not_Null by auto
    qed

    lemma arr_empty [simp]:
    assumes "x \<in> Obj"
    shows "arr (mkArr x x [])"
      using assms
      by (simp add: G.path_Obj arr_char free_category.mkArr_not_Null free_category_axioms)

    lemma arr_single [simp]:
    assumes "x \<in> Arr"
    shows "arr (mkArr (D x) (C x) [x])"
      using assms by (simp add: G.path_single_Arr arr_char mkArr_not_Null)

    lemma dom_mkArr [simp]:
    assumes "arr (mkArr x y p)"
    shows "dom (mkArr x y p) = mkArr x x []"
      using assms dom_char Dom_mkArr arr_char by auto

    lemma cod_mkArr [simp]:
    assumes "arr (mkArr x y p)"
    shows "cod (mkArr x y p) = mkArr y y []"
      using assms cod_char Cod_mkArr arr_char by auto

    lemma comp_mkArr [simp]:
    assumes "seq (mkArr y z q) (mkArr x y p)"
    shows "comp (mkArr y z q) (mkArr x y p) = mkArr x z (p @ q)"
      using assms comp_char Cod_mkArr arr_char Dom_mkArr Path_mkArr by auto

    lemma mkArr_eqI:
    assumes "arr (mkArr a b p)"
    shows "mkArr a b p = mkArr a b p' \<longleftrightarrow> p = p'"
      using assms by (metis Path_mkArr arr_char)

  end

  section "Discrete Categories"

  text{*
    A discrete category is a free category generated by a graph with no arrows.
  *}

  locale discrete_category =
    FC: free_category Obj "{} :: unit set" "\<lambda>_. undefined" "\<lambda>_. undefined"
  for Obj :: "'obj set"
  begin

    lemma FC_arr_char:
    shows "FC.arr f \<longleftrightarrow> f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj"
      using FC.arr_char
      by (metis (no_types, lifting) FC.ideD(1) FC.ideI_dom FC.ide_char empty_iff FC.dom_char
          FC.mkArr_Path FC.G.path_def length_greater_0_conv less_or_eq_imp_le)

    lemma FC_seq_char:
    shows "FC.seq g f \<longleftrightarrow> FC.arr f \<and> g = f"
      using FC_arr_char by auto

    typedef 'a arr = "UNIV :: ('a, unit) free_category.arr set" ..

    interpretation AC: abstracted_category FC.comp Abs_arr Rep_arr UNIV
      using Rep_arr_inverse Abs_arr_inverse apply unfold_locales by auto

    definition comp
    where "comp \<equiv> AC.comp"

    lemma is_category:
    shows "category comp"
    proof -
      have "category AC.comp" ..
      thus "category comp" using comp_def by auto
    qed

    interpretation category comp
      using is_category by auto

    definition mkIde
    where "mkIde x \<equiv> if x \<in> Obj then Abs_arr (FC.mkArr x x []) else null"

    definition toObj
    where "toObj f \<equiv> FC.Dom (Rep_arr f)"

    lemma arr_char:
    shows "arr f \<longleftrightarrow> f \<in> mkIde ` Obj"
    proof
      show "arr f \<Longrightarrow> f \<in> mkIde ` Obj"
      proof -
        assume f: "arr f"
        obtain A where "A \<in> Obj \<and> Rep_arr f = FC.mkArr A A []"
          using f AC.arr_char [of f] FC_arr_char [of "Rep_arr f"]
                FC.ide_char FC_seq_char FC.Dom_in_Obj FC.arr_char FC.dom_char comp_def FC.ideD(3)
          by auto
        moreover from this have "f = mkIde A"
          by (metis Rep_arr_inverse mkIde_def)
        ultimately show ?thesis by auto
      qed
      show "f \<in> mkIde ` Obj \<Longrightarrow> arr f"
        using FC_arr_char mkIde_def AC.arr_char AC.domain_closed AC.rep_abs FC.arr_empty
              f_inv_into_f inv_into_into local.comp_def
        by auto
    qed

    lemma dom_char:
    shows "dom f = (if arr f then f else null)"
      using AC.dom_char arr_char comp_def
      by (simp add: AC.arr_char FC.ide_char FC_arr_char Rep_arr_inverse)

    lemma cod_char:
    shows "cod f = (if arr f then f else null)"
      using AC.cod_char arr_char comp_def
      by (simp add: AC.arr_char FC.ide_char FC_arr_char Rep_arr_inverse)

    lemma dom_simp [simp]:
    assumes "arr f"
    shows "dom f = f"
      using assms dom_char by simp

    lemma cod_simp [simp]:
    assumes "arr f"
    shows "cod f = f"
      using assms cod_char by simp

    lemma seq_char:
    shows "seq g f \<longleftrightarrow> ide f \<and> g = f"
      using arr_char dom_char cod_char by fastforce

    lemma comp_char:
    shows "comp g f = (if seq g f then f else null)"
      using AC.comp_char comp_def comp_cod_arr seq_char dom_char by fastforce

    lemma comp_simp [simp]:
    assumes "seq g f"
    shows "comp g f = f"
      using assms comp_char by auto

    lemma is_discrete:
    shows "ide f \<longleftrightarrow> arr f"
      using arr_char dom_char by fastforce

    lemma ide_mkIde:
    assumes "x \<in> Obj"
    shows "ide (mkIde x)"
      using assms mkIde_def arr_char image_iff is_discrete by auto

    lemma toObj_in_Obj:
    assumes "arr a"
    shows "toObj a \<in> Obj"
      using assms toObj_def
      by (metis AC.arr_char FC.Dom_in_Obj FC.arr_char comp_def)

    lemma toObj_mkIde [simp]:
    assumes "x \<in> Obj"
    shows "toObj (mkIde x) = x"
      using assms toObj_def mkIde_def Abs_arr_inverse
      by (metis FC.Dom_mkArr FC.arr_empty FC.not_arr_null FC.null_char UNIV_I)

    lemma mkIde_toObj [simp]:
    assumes "arr a"
    shows "mkIde (toObj a) = a"
      using assms mkIde_def
      by (metis (no_types, lifting) arr_char imageE toObj_mkIde)

  end

  sublocale discrete_category \<subseteq> category comp
    using is_category by auto

  text{*
    The empty category is the discrete category generated by an empty set of objects.
  *}

  locale empty_category =
    discrete_category "{} :: unit set"
  begin

    lemma is_empty:
    shows "\<not>arr f"
      using arr_char by simp

  end

  section "Quivers"

  text{*
    A quiver is a two-object category whose non-identity arrows all point in the
    same direction.  A quiver is specified by giving the set of these non-identity arrows.
  *}

  locale quiver =
    FC: free_category "{False, True}" Arr "\<lambda>_. False" "\<lambda>_. True"
  for Arr :: "'arr set"
  begin

    lemma FC_ide_char:
    shows "FC.ide f \<longleftrightarrow> f = FC.mkArr False False [] \<or> f = FC.mkArr True True []"
      by (simp add: FC.ide_char)

    lemma FC_arr_char:
    shows "FC.arr f \<longleftrightarrow> f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
                        f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
    proof
      assume f: "f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
                 f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
      show "FC.arr f" using f by auto
      next
      assume f: "FC.arr f"
      have "\<not>(f = FC.mkArr False False [] \<or> f = FC.mkArr True True [])
                     \<Longrightarrow> f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
      proof -
        assume f': "\<not>(f = FC.mkArr False False [] \<or> f = FC.mkArr True True [])"
        have "FC.Dom f = False \<and> FC.Cod f = True"
        proof -
          have "f \<noteq> FC.Null \<and> FC.G.path (FC.Dom f) (FC.Cod f) (FC.Path f)"
            using FC.arr_char f by presburger
          then show ?thesis
            by (metis (full_types) FC.G.path_def FC.mkArr_Path f')
        qed
        hence 1: "f = FC.mkArr False True (FC.Path f)"
        proof -
          have "FC.mkArr (FC.Dom f) (FC.Cod f) (FC.Path f) = f"
            using FC.arr_char FC.mkArr_Path f by presburger
          then show ?thesis
            by (simp add: \<open>FC.Dom f = False \<and> FC.Cod f = True\<close>)
        qed
        moreover have "length (FC.Path f) = 1"
        proof -
          have 2: "length (FC.Path f) \<noteq> 0"
            using f f' FC_ide_char FC.arr_char FC.mkArr_Path FC.G.path_def length_0_conv
            by (metis (full_types))
          moreover have "\<And>x y p. length p > 1 \<Longrightarrow> \<not>FC.G.path x y p"
            using FC.G.path_def less_diff_conv by auto
          thus ?thesis by (metis FC.arr_char 2 f less_one linorder_neqE_nat)
        qed
        moreover have "\<And>p. length p = 1 \<longleftrightarrow> (\<exists>x. p = [x])"
          by (metis One_nat_def add.left_neutral length_0_conv length_tl list.sel(3) list.size(4)
                    splice.elims)
        ultimately have "\<exists>x. x \<in> Arr \<and> FC.Path f = [x]"
          by (metis FC.G.path_def FC.arr_char f FC.mkArr_def less_or_eq_imp_le nth_Cons_0
                    zero_less_one)
        thus "f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
          using 1 by auto
      qed
      thus "f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
            f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
        by auto
    qed

    lemma FC_seq_char:
    shows "FC.seq g f \<longleftrightarrow> FC.arr g \<and> FC.arr f \<and>
                          ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
                           (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
    proof
      assume gf: "FC.arr g \<and> FC.arr f \<and>
                  ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
                   (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
      show "FC.seq g f" using gf FC_arr_char FC_ide_char by auto
      next
      assume gf: "FC.seq g f"
      have "FC.Cod f = False \<Longrightarrow> f = FC.mkArr False False []"
      proof -
        assume 1: "FC.Cod f = False"
        have "FC.mkArr (FC.Dom f) (FC.Cod f) (FC.Path f) = f"
          using FC.arr_char gf by auto
        then show ?thesis
          using 1 FC.G.path_def FC.arr_char gf by auto
      qed
      moreover have "FC.Cod f = True \<Longrightarrow> g = FC.mkArr True True []"
      proof -
        assume f: "FC.Cod f = True"
        have "FC.Null \<noteq> g"
          using FC.arr_char gf by blast
        moreover have "FC.Cod f = FC.Dom g"
        proof -
          have 1: "\<not> FC.Dom (FC.mkArr False False [])"
            using FC.not_arr_null FC.null_char FC_arr_char by force
          have "FC.Dom (FC.mkArr True True [])"
            using FC.not_arr_null FC.null_char FC_arr_char by auto
          then show ?thesis
            using 1 by (metis (full_types) FC.cod_char FC.dom_char gf)
        qed
        ultimately show ?thesis
          using f FC_arr_char gf by auto
      qed
      ultimately have "f = FC.mkArr False False [] \<or> g = FC.mkArr True True []"
        using gf FC_arr_char by auto
      moreover have "\<not>(f = FC.mkArr False False [] \<and> g = FC.mkArr True True [])"
        using gf by (metis FC.arr_char FC.dom_mkArr FC.Dom_mkArr FC.cod_mkArr)
      ultimately show "FC.arr g \<and> FC.arr f
                   \<and> ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
                      (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
        using gf by metis
    qed

    typedef 'a arr = "UNIV :: (bool, 'a) free_category.arr set" ..

    interpretation AC: abstracted_category FC.comp Abs_arr Rep_arr UNIV
      using Rep_arr_inverse Abs_arr_inverse apply unfold_locales by auto

    definition comp
    where "comp \<equiv> AC.comp"

    lemma is_category:
    shows "category comp"
    proof -
      have "category AC.comp" ..
      thus "category comp" using comp_def by auto
    qed

    interpretation category comp
      using is_category by auto

    definition Zero
    where "Zero \<equiv> Abs_arr (FC.mkArr False False [])"

    definition One
    where "One \<equiv> Abs_arr (FC.mkArr True True [])"

    definition mkArr
    where "mkArr x \<equiv> if x \<in> Arr then Abs_arr (FC.mkArr False True [x]) else null"

    definition toArr
    where "toArr f \<equiv> hd (FC.Path (Rep_arr f))"

    lemma ide_char:
    shows "ide f \<longleftrightarrow> f = Zero \<or> f = One"
      using comp_def Zero_def One_def
      by (metis AC.ide_char Abs_arr_inverse FC_ide_char Rep_arr_inject UNIV_I)

    lemma not_ide_mkArr:
    shows "\<not>ide (mkArr x)"
      using mkArr_def ide_char Zero_def One_def
      by (metis Abs_arr_inverse FC.G.path_single_Arr UNIV_I FC.Cod_mkArr FC.Dom_mkArr
                FC.mkArr_not_Null ideD(1) not_arr_null)

    lemma arr_char:
    shows "arr f \<longleftrightarrow> f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr"
    proof -
      obtain G :: "'arr set \<Rightarrow> ('arr \<Rightarrow> (bool, 'arr) FC.arr) \<Rightarrow> (bool, 'arr) FC.arr \<Rightarrow> 'arr"
        where "\<forall>A F h. (\<exists>h'. h' \<in> A \<and> h = F h') \<longleftrightarrow> (G A F h \<in> A \<and> h = F (G A F h))"
        by moura
      hence 1: "\<forall>a f A. (a \<in> f ` A \<longrightarrow> G A f a \<in> A \<and> a = f (G A f a)) \<and>
                        (a \<notin> f ` A \<longrightarrow> (\<forall>a'. a' \<in> A \<longrightarrow> a \<noteq> f a'))"
        by auto
      have 2: "Rep_arr f = FC.mkArr False False [] \<longrightarrow> f = Zero"
        by (metis (no_types) Rep_arr_inverse Zero_def)
      have 3: "Rep_arr f = FC.mkArr True True [] \<longrightarrow> f = One"
        by (metis One_def Rep_arr_inverse)
      have "(Rep_arr f \<in> (\<lambda>a. FC.mkArr False True [a]) ` Arr \<longrightarrow>
               G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f) \<in> Arr \<and>
               Rep_arr f = FC.mkArr False True [G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f)])
            \<and> (Rep_arr f \<notin> (\<lambda>a. FC.mkArr False True [a]) ` Arr \<longrightarrow>
                 (\<forall>a. a \<notin> Arr \<or> Rep_arr f \<noteq> FC.mkArr False True [a]))"
        using 1 by meson
      moreover have
          "f \<noteq> mkArr (G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f))
             \<Longrightarrow> G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f) \<notin> Arr \<or>
                 Rep_arr f \<noteq> FC.mkArr False True [G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f)]"
        by (metis Rep_arr_inverse mkArr_def)
      ultimately have "arr f \<Longrightarrow> f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr"
        using 2 3 AC.arr_char FC_arr_char comp_def by force
      thus "arr f \<longleftrightarrow> (f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr)"
        using AC.arr_char Abs_arr_inverse FC_arr_char One_def UNIV_I Zero_def comp_def
              mkArr_def
        by fastforce
    qed

    lemma Zero_not_eq_One [simp]:
    shows "Zero \<noteq> One"
      using Zero_def One_def
      by (metis Abs_arr_inverse FC.not_arr_null FC.null_char FC_arr_char UNIV_I FC.Dom_mkArr)

    lemma Zero_not_in_mkArr_Arr [simp]:
    shows "Zero \<notin> mkArr ` Arr"
      by (metis ide_char imageE not_ide_mkArr)

    lemma One_not_in_mkArr_Arr [simp]:
    shows "One \<notin> mkArr ` Arr"
      by (metis ide_char imageE not_ide_mkArr)

    lemma dom_char:
    shows "dom f = (if ide f then f else if arr f then Zero else null)"
      using comp_def arr_char ide_char AC.dom_char Zero_def AC.arr_char
            AC.ide_char FC.arr_empty FC_ide_char FC_seq_char UNIV_I UNIV_bool FC.cod_mkArr
            ideD(2)
      by metis

    lemma dom_simp [simp]:
    shows "dom One = One"
    and "\<lbrakk>arr f; f \<noteq> One\<rbrakk> \<Longrightarrow> dom f = Zero"
      using assms dom_char ide_char by auto

    lemma cod_char:
    shows "cod f = (if ide f then f else if arr f then One else null)"
      using comp_def arr_char ide_char AC.dom_char One_def AC.arr_char
            AC.ide_char FC.arr_empty FC_ide_char FC_seq_char UNIV_I UNIV_bool
            AC.cod_char FC.dom_mkArr ideD(3)
      by metis

    lemma cod_simp [simp]:
    shows "cod Zero = Zero"
    and "\<lbrakk>arr f; f \<noteq> Zero\<rbrakk> \<Longrightarrow> cod f = One"
      using assms cod_char ide_char by auto

    lemma seq_char:
    shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
    proof
      assume gf: "seq g f"
      have f: "arr f \<and> (f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr)" using gf arr_char by auto
      have g: "arr g \<and> (g = Zero \<or> g = One \<or> g \<in> mkArr ` Arr)" using gf arr_char by auto
      have "f = Zero \<Longrightarrow> g \<noteq> One"
        using f g gf by force
      moreover have "f = One \<Longrightarrow> g = One"
        using f g gf by (metis Zero_not_eq_One cod_simp(2) dom_simp(2))
      moreover have "f \<in> mkArr ` Arr \<Longrightarrow> f \<noteq> Zero \<and> g = One"
        using f gf arr_char [of f]
        by (metis Zero_not_eq_One Zero_not_in_mkArr_Arr cod_simp(2) dom_simp(2))
      ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
        using f g arr_char [of f] arr_char [of g] by blast
      next
      assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
      have "f = Zero \<Longrightarrow> seq g f" using gf arr_char cod_dom dom_simp by fastforce
      moreover have "g = One \<Longrightarrow> seq g f" using gf arr_char dom_cod cod_simp by fastforce
      ultimately show "seq g f" using gf by blast
    qed

    lemma comp_char:
    shows "comp g f = (if seq g f then
                         if f = Zero then g else if g = One then f else null
                       else null)"
    proof -
      have "seq g f \<Longrightarrow> f = Zero \<Longrightarrow> comp g f = g"
        using comp_def seq_char [of g f] AC.comp_char [of g f]
              FC.comp_char [of "Rep_arr g" "Rep_arr f"] Zero_def
        by (metis comp_arr_ide dom_simp ide_char seq_char)
      moreover have "seq g f \<Longrightarrow> g = One \<Longrightarrow> comp g f = f"
        using comp_def seq_char [of g f] AC.comp_char [of g f]
              FC.comp_char [of "Rep_arr g" "Rep_arr f"] One_def
        by (metis comp_ide_arr cod_simp ide_char seq_char)
      moreover have "seq g f \<Longrightarrow> f \<noteq> Zero \<Longrightarrow> g \<noteq> One \<Longrightarrow> comp g f = null"
        using seq_char by blast
      moreover have "\<not>seq g f \<Longrightarrow> comp g f = null"
        using comp_def AC.comp_char by auto
      ultimately show ?thesis by presburger
    qed

    lemma comp_simp [simp]:
    assumes "seq g f"
    shows "f = Zero \<Longrightarrow> comp g f = g"
    and "g = One \<Longrightarrow> comp g f = f"
    proof -
      show "f = Zero \<Longrightarrow> local.comp g f = g"
        using assms seq_char comp_char by metis
      show "g = One \<Longrightarrow> comp g f = f"
        using assms seq_char comp_char by metis
    qed

    lemma arr_mkArr:
    assumes "x \<in> Arr"
    shows "arr (mkArr x)"
      using assms mkArr_def arr_char image_eqI by blast

    lemma toArr_in_Arr:
    assumes "arr f" and "\<not>ide f"
    shows "toArr f \<in> Arr"
    proof -
      have "\<And>a. a \<in> Arr \<Longrightarrow> FC.Path (Rep_arr (mkArr a)) = [a]"
        by (metis AC.domain_closed Abs_arr_inverse FC.Path_mkArr FC.arr_char FC.arr_single
                  mkArr_def)
      hence "hd (FC.Path (Rep_arr f)) \<in> Arr"
        using arr_char assms(1) assms(2) ide_char by auto
      thus ?thesis
        by (simp add: toArr_def)
    qed

    lemma toArr_mkArr [simp]:
    assumes "x \<in> Arr"
    shows "toArr (mkArr x) = x"
      using assms mkArr_def toArr_def
      by (metis Abs_arr_inverse FC.G.path_single_Arr UNIV_I FC.Path_mkArr FC.mkArr_not_Null
                list.sel(1))

    lemma mkArr_toArr [simp]:
    assumes "arr f" and "\<not>ide f"
    shows "mkArr (toArr f) = f"
      using assms arr_char ide_char imageE toArr_mkArr by auto

  end

  sublocale quiver \<subseteq> category comp
    using is_category by auto

  section "Parallel Pairs"

  text{*
    A parallel pair is a quiver with two non-identity arrows.
    It is important in the definition of equalizers.
  *}

  locale parallel_pair =
    Q: quiver "{False, True} :: bool set"
  begin

    typedef arr = "UNIV :: bool quiver.arr set" ..

    interpretation AC: abstracted_category Q.comp Abs_arr Rep_arr UNIV
      using Rep_arr_inverse Abs_arr_inverse apply unfold_locales by auto

    definition comp
    where "comp \<equiv> AC.comp"

    lemma is_category:
    shows "category comp"
    proof -
      have "category AC.comp" ..
      thus "category comp" using comp_def by metis
    qed

    interpretation category comp
      using is_category by auto

    definition Zero
    where "Zero \<equiv> Abs_arr Q.Zero"

    definition One
    where "One \<equiv> Abs_arr Q.One"

    definition j0
    where "j0 \<equiv> Abs_arr (Q.mkArr False)"

    definition j1
    where "j1 \<equiv> Abs_arr (Q.mkArr True)"

    lemma arr_char:
    shows "arr f \<longleftrightarrow> f = Zero \<or> f = One \<or> f = j0 \<or> f = j1"
    proof -
      have 1: "Rep_arr f = Q.Zero \<or> Rep_arr f = Q.One \<or> Rep_arr f \<in> Q.mkArr ` {False, True}
                 \<longrightarrow> arr f"
        by (simp add: AC.arr_char Q.arr_char local.comp_def)
      have 2: "\<forall>a. a \<in> UNIV \<longrightarrow> Rep_arr (Abs_arr a) = a"
        by (simp add: Abs_arr_inverse)
      hence 3: "Rep_arr (Abs_arr (Q.mkArr True)) = Q.mkArr True"
        by blast
      hence 4: "f = j1 \<longrightarrow> arr f"
        using 1 j1_def by auto
      have "f = j0 \<or> f = Zero \<or> f = One \<longrightarrow>arr f"
        using 1 2 Zero_def One_def by (metis (no_types) UNIV_I insertI1 j0_def rev_image_eqI)
      thus ?thesis
        using 2 3 4
        by (metis (full_types) AC.arr_char One_def Q.ide_char Q.mkArr_toArr Rep_arr_inject
            UNIV_I Zero_def j0_def j1_def comp_def)
    qed

    lemma ide_char:
    shows "ide a \<longleftrightarrow> a = Zero \<or> a = One"
      using arr_char
      by (metis (no_types, lifting) AC.ide_char Q.ide_char UNIV_I Zero_def ideD(1) j0_def j1_def
          comp_def Abs_arr_inverse One_def)

    lemma dom_char:
    shows "dom f = (if f = j0 \<or> f = j1 then Zero else if arr f then f else null)"
      using comp_def
      by (metis (full_types) AC.arr_char AC.dom_char Abs_arr_inverse One_def Q.dom_char Q.ide_char
          Q.not_ide_mkArr UNIV_I Zero_def arr_char j0_def j1_def)

    lemma cod_char:
    shows "cod f = (if f = j0 \<or> f = j1 then One else if arr f then f else null)"
      using comp_def
      by (metis (full_types) AC.arr_char AC.cod_char Abs_arr_inverse One_def Q.cod_char Q.ide_char
          Q.not_ide_mkArr UNIV_I Zero_def arr_char j0_def j1_def)

    lemma Zero_not_eq_One [simp]:
    shows "Zero \<noteq> One"
      using Zero_def One_def Q.Zero_def Q.One_def
      by (metis AC.domain_closed AC.rep_abs Q.dom_char Q.ideD(1) Q.ide_char Q.is_category
                Q.seq_char category.ide_cod)

    lemma j0_not_eq_j1 [simp]:
    shows "j0 \<noteq> j1"
      by (metis (full_types) Abs_arr_inverse Q.toArr_mkArr UNIV_I UNIV_bool j0_def j1_def)

    lemma Zero_not_eq_j0 [simp]:
    shows "Zero \<noteq> j0"
      using Zero_def j0_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma Zero_not_eq_j1 [simp]:
    shows "Zero \<noteq> j1"
      using Zero_def j1_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma One_not_eq_j0 [simp]:
    shows "One \<noteq> j0"
      using One_def j0_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma One_not_eq_j1 [simp]:
    shows "One \<noteq> j1"
      using One_def j1_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma dom_simp [simp]:
    shows "dom Zero = Zero"
    and "dom One = One"
    and "dom j0 = Zero"
    and "dom j1 = Zero"
      using dom_char arr_char by auto

    lemma cod_simp [simp]:
    shows "cod Zero = Zero"
    and "cod One = One"
    and "cod j0 = One"
    and "cod j1 = One"
      using cod_char arr_char by auto

    lemma seq_char:
    shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
    proof
      assume gf: "seq g f"
      have f: "arr f \<and> (f = Zero \<or> f = One \<or> f = j0 \<or> f = j1)" using gf arr_char by auto
      have g: "arr g \<and> (g = Zero \<or> g = One \<or> g = j0 \<or> g = j1)" using gf arr_char by auto
      have "f = Zero \<Longrightarrow> g \<noteq> One" using f g gf by force
      moreover have "f \<noteq> Zero \<Longrightarrow> g = One"
        using f g gf
        by (metis Zero_not_eq_One cod_simp(2) cod_simp(3) cod_simp(4)
                  dom_simp(1) dom_simp(3) dom_simp(4))
      ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
        using f g by blast
      next
      assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
      have "f = Zero \<Longrightarrow> seq g f" using gf arr_char by auto
      moreover have "g = One \<Longrightarrow> seq g f" using gf arr_char by auto
      ultimately show "seq g f" using gf by blast
    qed

    lemma comp_char:
    shows "comp g f = (if seq g f then
                         if f = Zero then g else if g = One then f else null
                       else null)"
    proof -
      have "\<not>seq g f \<Longrightarrow> comp g f = null"
        using comp_def AC.comp_char Q.comp_char seq_char by auto
      moreover have "seq g f \<Longrightarrow> f = Zero \<Longrightarrow> comp g f = g"
        using comp_arr_dom [of g] by fastforce
      moreover have "seq g f \<Longrightarrow> g = One \<Longrightarrow> comp g f = f"
        using comp_cod_arr [of f] by fastforce
      ultimately show ?thesis using seq_char by metis
    qed

    lemma comp_simp [simp]:
    assumes "seq g f"
    shows "f = Zero \<Longrightarrow> comp g f = g"
    and "g = One \<Longrightarrow> comp g f = f"
    proof -
      show "f = Zero \<Longrightarrow> comp g f = g"
        using assms comp_char by metis
      show "g = One \<Longrightarrow> comp g f = f"
        using assms comp_char seq_char by metis
    qed

  end

  sublocale parallel_pair \<subseteq> category comp
    using is_category by auto

end
