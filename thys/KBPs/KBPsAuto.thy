
(*
 * Knowledge-based programs.
 * (C)opyright 2011, Peter Gammie, peteg42 at gmail.com.
 * License: BSD
 *)

header {* Automata for KBPs *}

theory KBPsAuto
imports Main Extra KBPs
begin


record ('obs, 'aAct, 'ps) Protocol =
  pInit :: "'obs \<Rightarrow> 'ps"     pTrans :: "'obs \<Rightarrow> 'ps \<Rightarrow> 'ps"     pAct :: "'ps \<Rightarrow> 'aAct list"


context Environment begin

fun
  runP :: "('obs, 'aAct, 'ps) Protocol
       \<Rightarrow> 's Trace \<Rightarrow> 'a \<Rightarrow> 'ps"
where
  "runP p (tInit s) a = pInit p (envObs a s)"
| "runP p (t \<leadsto> s) a = pTrans p (envObs a s) (runP p t a)"

abbreviation
  actP :: "('obs, 'aAct, 'ps) Protocol
       \<Rightarrow> 's Trace \<Rightarrow> 'a \<Rightarrow> 'aAct list"
where
  "actP p t a \<equiv> pAct p (runP p t a)"

abbreviation
  runJP :: "('a \<Rightarrow> ('obs, 'aAct, 'ps) Protocol)
        \<Rightarrow> 's Trace \<Rightarrow> 'a \<Rightarrow> 'ps"
where
  "runJP jp \<equiv> \<lambda>t a. runP (jp a) t a"

abbreviation
  actJP :: "('a \<Rightarrow> ('obs, 'aAct, 'ps) Protocol)
        \<Rightarrow> 's Trace \<Rightarrow> 'a \<Rightarrow> 'aAct list"
where
  "actJP jp t \<equiv> \<lambda>a. pAct (jp a) (runJP jp t a)"

(* Similarly to \S\ref{sec:kbps-canonical-traces} we will reason about
the set of traces generated by a joint protocol in a fixed
environment. *)

inductive_set (in Environment)
  jpTraces :: "('a \<Rightarrow> ('obs, 'aAct, 'ps) Protocol) \<Rightarrow> 's Trace set"
    for jp :: "'a \<Rightarrow> ('obs, 'aAct, 'ps) Protocol"
where
  jptInit[intro]: "s \<in> set envInit \<Longrightarrow> tInit s \<in> jpTraces jp"
| jptStep[intro]: "\<lbrakk> t \<in> jpTraces jp;
                     eact \<in> set (envAction (tLast t));
                     \<And>a. aact a \<in> set (actJP jp t a);
                     s = envTrans eact aact (tLast t) \<rbrakk>
                   \<Longrightarrow> t \<leadsto> s \<in> jpTraces jp"

lemma jpTraces_init_inv[dest]:
  "tInit s \<in> jpTraces jp \<Longrightarrow> s \<in> set envInit"
  by (cases rule: jpTraces.cases) auto

lemma jpTraces_step_inv[dest]:
  "t \<leadsto> s \<in> jpTraces jp
    \<Longrightarrow> t \<in> jpTraces jp
     \<and> (\<exists>eact \<in> set (envAction (tLast t)).
        (\<exists>aact. (\<forall>a. aact a \<in> set (actJP jp t a))
          \<and> s = envTrans eact aact (tLast t)))"
  by (cases rule: jpTraces.cases) auto

lemma jpTraces_init_length_inv:
  "t \<in> jpTraces jp \<Longrightarrow> (tLength t = 0) \<longleftrightarrow> (\<exists>s. s \<in> set envInit \<and> t = tInit s)"
  by (induct t) (auto elim: jpTraces.cases)

lemma jpTraces_step_length_inv_aux:
  "t \<in> { t \<in> jpTraces jp . tLength t = Suc n }
    \<Longrightarrow> \<exists>t' s. t = t' \<leadsto> s
            \<and> t' \<in> jpTraces jp
            \<and> tLength t' = n
            \<and> (\<exists>eact \<in> set (envAction (tLast t')).
               (\<exists>aact. (\<forall>a. aact a \<in> set (actJP jp t' a))
                 \<and> s = envTrans eact aact (tLast t')))"
  by (induct t arbitrary: n) auto

lemma jpTraces_step_length_inv:
  "{ t \<in> jpTraces jp . tLength t = Suc n }
 = { t \<leadsto> s |eact aact t s. t \<in> { t \<in> jpTraces jp . tLength t = n }
              \<and> eact \<in> set (envAction (tLast t))
              \<and> (\<forall>a. aact a \<in> set (actJP jp t a))
              \<and> s = envTrans eact aact (tLast t) }"
  apply (rule set_eqI)
  apply rule
   apply (drule jpTraces_step_length_inv_aux)
   apply auto
  done

definition (in Environment)
  implements :: "('a \<Rightarrow> ('obs, 'aAct, 'ps) Protocol) \<Rightarrow> bool"
where
  "implements jp \<equiv> (\<forall>t \<in> jkbpC. set \<circ> actJP jp t = set \<circ> jAction mkMC t)"

lemma implementsI[intro]:
  "(\<And>t. t \<in> jkbpC \<Longrightarrow> set \<circ> actJP jp t = set \<circ> jAction mkMC t)
  \<Longrightarrow> implements jp"
  unfolding implements_def by simp

lemma implementsE[elim]:
  assumes impl: "implements jp"
      and tC: "t \<in> jkbpC"
     shows "set \<circ> actJP jp t = set \<circ> jAction mkMC t"
  using assms unfolding implements_def by simp

lemma implements_actJP_jAction:
   assumes impl: "implements jp"
       and tCn: "t \<in> jkbpCn n"
  shows "set (actJP jp t a) = set (jAction (mkMCn n) t a)" (is "?lhs = ?rhs")
proof -
  from tCn have tC: "t \<in> jkbpC" by blast
  hence "?lhs = (set \<circ> jAction mkMC t) a"
    using implementsE[OF impl, symmetric] by auto
  also have "... = set (jAction (mkMCn n) t a)"
    by (simp add: jkbpC_jkbpCn_jAction_eq[OF tCn])
  finally show ?thesis .
qed

lemma implements_represents:
  assumes impl: "implements jp"
  shows "represents (jpTraces jp)"
proof -
  { fix n
    have "{ t \<in> jpTraces jp . tLength t = n }
        = { t \<in> jkbpC . tLength t = n }"
    proof(induct n)
      case 0 thus ?case
        by (auto dest: jpTraces_init_length_inv iff: jkbpC_traces_of_length)
    next
      case (Suc n)
      hence indhyp: "{t \<in> jpTraces jp . tLength t = n} = jkbpCn n"
        by (simp add: jkbpC_traces_of_length)

      have "{t \<in> jpTraces jp. tLength t = Suc n}
          = {t \<leadsto> s |eact aact t s. t \<in> jkbpCn n
                      \<and> eact \<in> set (envAction (tLast t))
                      \<and> (\<forall>a. aact a \<in> set (actJP jp t a))
                      \<and> s = envTrans eact aact (tLast t) }"
        using indhyp by (simp add: jpTraces_step_length_inv)
      also have "... = jkbpCn (Suc n)"
        apply (auto iff: Let_def)
        apply (auto iff: implements_actJP_jAction[OF impl, symmetric])
        done
      finally show ?case by (auto iff: jkbpC_traces_of_length)
    qed }
  hence R: "jpTraces jp = jkbpC" by auto
  from R jkbpC_represents
  show "represents (jpTraces jp)" by simp
qed

lemma implements_ind_jkbpC:
  assumes acts: "\<And>a n t.
                  \<lbrakk> {t \<in> jpTraces jp. tLength t = n} = jkbpCn n; t \<in> jkbpCn n \<rbrakk>
                  \<Longrightarrow> actJP jp t a = jAction mkMC t a"
  shows "implements jp"
proof -
  let ?T = "jpTraces jp"

  from acts have acts':
      "\<And>n t. \<lbrakk> {t \<in> jpTraces jp. tLength t = n} = jkbpCn n; t \<in> jkbpCn n \<rbrakk>
          \<Longrightarrow> actJP jp t = jAction (mkMCn n) t"
    by (simp only: jkbpC_jkbpCn_jAction_eq)

  from acts have acts':
      "\<And>n t. \<lbrakk> {t \<in> jpTraces jp. tLength t = n} = jkbpCn n; t \<in> jkbpCn n \<rbrakk>
          \<Longrightarrow> actJP jp t = jAction (mkMCn n) t"
    apply -
    apply (rule ext)
    apply simp
    using jkbpC_jkbpCn_jAction_eq
    apply simp
    done

  { fix n
    have "{ t \<in> ?T . tLength t = n } = { t \<in> jkbpC . tLength t = n }"
    proof(induct n)
      case 0 thus ?case
        by (auto dest: jpTraces_init_length_inv iff: jkbpC_traces_of_length)
    next
      case (Suc n)
      hence indhyp: "{t \<in> ?T. tLength t = n} = jkbpCn n"
        by (simp add: jkbpC_traces_of_length)

      have "{t \<in> jpTraces jp. tLength t = Suc n}
          = {t \<leadsto> s |eact aact t s. t \<in> jkbpCn n
                      \<and> eact \<in> set (envAction (tLast t))
                      \<and> (\<forall>a. aact a \<in> set (actJP jp t a))
                      \<and> s = envTrans eact aact (tLast t) }"
        using indhyp by (simp add: jpTraces_step_length_inv)
      also have "... = jkbpCn (Suc n)"
        apply (auto iff: Let_def)
         apply (drule acts'[OF indhyp, symmetric])
         apply auto[1]
        apply (drule acts'[OF indhyp, symmetric])
        apply auto[1]
        done
      finally show ?case
        apply (auto iff: jkbpC_traces_of_length)
        done
    qed
    hence "\<forall>t\<in>jkbpCn n. actJP jp t = jAction (mkMCn n) t"
      apply clarsimp
      apply (rule acts')
       apply (auto iff: jkbpC_traces_of_length)
      done
    hence "\<forall>t\<in>jkbpCn n. actJP jp t = jAction mkMC t"
      apply clarsimp
      by ( rule sync_jview_jAction_eq[where n="n"]
         , auto iff: jkbpC_traces_of_length)
  }
  thus ?thesis
    unfolding implements_def jkbpC_def
    apply clarsimp
    done
qed

definition
  behaviourally_equiv :: "('a \<Rightarrow> ('obs, 'aAct, 'ps) Protocol)
                        \<Rightarrow> ('a \<Rightarrow> ('obs, 'aAct, 'ps') Protocol)
                        \<Rightarrow> bool"
where
  "behaviourally_equiv jp jp' \<equiv> (\<forall>t \<in> jkbpC. set \<circ> actJP jp t = set \<circ> actJP jp' t)"

lemma behaviourally_equivI[intro]:
  "(\<And>t. t \<in> jkbpC \<Longrightarrow> set \<circ> actJP jp t = set \<circ> actJP jp' t)
    \<Longrightarrow> behaviourally_equiv jp jp'"
  unfolding behaviourally_equiv_def by simp

lemma  behaviourally_equiv_implements:
  assumes "behaviourally_equiv jp jp'"
  shows "implements jp \<longleftrightarrow> implements jp'"
  using assms unfolding behaviourally_equiv_def implements_def by simp


definition mkAuto :: "'a \<Rightarrow> ('obs, 'aAct, 's Trace set) Protocol" where
  "mkAuto a \<equiv> \<lparr> pInit = \<lambda>obs. { t \<in> jkbpC . spr_jview a t = tInit obs },
                     pTrans = \<lambda>obs ps. { t |t t'. t \<in> jkbpC \<and> t' \<in> ps
                                              \<and> spr_jview a t = spr_jview a t' \<leadsto> obs },
                     pAct = \<lambda>ps. jAction mkMC (SOME t. t \<in> ps) a \<rparr>"

abbreviation "equiv_class a tobs \<equiv> { t \<in> jkbpC . spr_jview a t = tobs }"


lemma mkAuto_ec:
  assumes "t \<in> jkbpC"
  shows "runJP mkAuto t a = equiv_class a (spr_jview a t)"
  using assms by (induct t) (auto simp add: mkAuto_def spr_jview_def)

lemma mkAuto_implements: "implements mkAuto"
  apply (rule implements_ind_jkbpC)
  apply (subst mkAuto_def)
  apply simp
  apply (subgoal_tac "t \<in> jkbpC")
   using mkAuto_ec
   apply simp
   apply (rule S5n_jAction_eq)
    apply simp_all
    apply (rule_tac a=t in someI2)
     apply simp_all
    unfolding mkM_def
    apply auto
   done

end (* context *)


subsection{* A sufficient condition for finite-state implementations *}

locale SimEnvironment =
        Environment jkbp envInit envAction envTrans envVal envObs
    for jkbp :: "'a \<Rightarrow> ('a, 'p, 'aAct) KBP"
    and envInit :: "('s :: finite) list"
    and envAction :: "'s \<Rightarrow> 'eAct list"
    and envTrans :: "'eAct \<Rightarrow> ('a \<Rightarrow> 'aAct) \<Rightarrow> 's \<Rightarrow> 's"
    and envVal :: "'s \<Rightarrow> 'p \<Rightarrow> bool"
    and envObs :: "'a \<Rightarrow> 's \<Rightarrow> 'obs"

    -- "Simulation operations"
+ fixes simf :: "'s Trace \<Rightarrow> 'ss :: finite"
    and simRels :: "'a \<Rightarrow> ('ss \<times> 'ss) set"
    and simVal :: "'ss \<Rightarrow> 'p \<Rightarrow> bool"

    -- "Adequacy of representations"
    and simAbs :: "'rep \<Rightarrow> 'ss set"

    -- "Algorithmic operations"
    and simObs :: "'a \<Rightarrow> 'rep \<Rightarrow> 'obs"
    and simInit :: "'a \<Rightarrow> 'obs \<Rightarrow> 'rep"
    and simTrans :: "'a \<Rightarrow> 'rep \<Rightarrow> 'rep list"
    and simAction :: "'rep \<Rightarrow> 'a \<Rightarrow> 'aAct list"

  assumes simf: "sim mkMC (mkKripke (simf ` jkbpC) simRels simVal) simf"
      and simInit:
            "\<forall>a obs. obs \<in> envObs a ` set envInit
                   \<longrightarrow> simAbs (simInit a obs) = simf ` equiv_class a (tInit obs)"
      and simObs:
            "\<forall>a ec t. t \<in> jkbpC \<and> simAbs ec = simf ` equiv_class a (spr_jview a t)
                   \<longrightarrow> simObs a ec = envObs a (tLast t)"
      and simAction:
            "\<forall>a ec t. t \<in> jkbpC \<and> simAbs ec = simf ` equiv_class a (spr_jview a t)
                   \<longrightarrow> set (simAction ec a) = set (jAction mkMC t a)"
      and simTrans:
            "\<forall>a ec t. t \<in> jkbpC \<and> simAbs ec = simf ` equiv_class a (spr_jview a t)
                   \<longrightarrow> simAbs ` set (simTrans a ec)
                     = { simf ` equiv_class a (spr_jview a (t' \<leadsto> s)) |t' s.
                           t' \<leadsto> s \<in> jkbpC \<and> spr_jview a t' = spr_jview a t}"


subsection{* An effective construction *}

context SimEnvironment begin

(* Convert the locale assumptions from readable logic into
   Isabelle-usable rules. *)

lemma simInit'[iff]:
  "obs \<in> envObs a ` set envInit
     \<Longrightarrow> simAbs (simInit a obs)
       = simf ` equiv_class a (tInit obs)"
  using simInit by blast

lemma simObs'[iff]:
  "\<lbrakk> t \<in> jkbpC; simAbs ec = simf ` equiv_class a (spr_jview a t); tLength t > 0 \<rbrakk>
     \<Longrightarrow> simObs a ec = envObs a (tLast t)"
  using simObs by blast

lemma simAction'[iff]:
  "\<lbrakk> t \<in> jkbpC; simAbs ec = simf ` equiv_class a (spr_jview a t) \<rbrakk>
     \<Longrightarrow> set (simAction ec a) = set (jAction mkMC t a)"
  using simAction by blast

lemma simTrans':
  "\<lbrakk> t \<in> jkbpC; simAbs ec = simf ` equiv_class a (spr_jview a t) \<rbrakk>
     \<Longrightarrow> simAbs ` set (simTrans a ec)
       = { simf ` equiv_class a (spr_jview a (t' \<leadsto> s))
           |t' s. t' \<leadsto> s \<in> jkbpC \<and> spr_jview a t' = spr_jview a t}"
  using simTrans by blast

abbreviation
  "sim_equiv_class a tobs \<equiv> simf ` equiv_class a tobs"

abbreviation
  "jkbpCSn n \<equiv> simf ` jkbpCn n"

abbreviation
  "jkbpCS \<equiv> simf ` jkbpC"

abbreviation
  "mkMCSn n \<equiv> mkKripke (jkbpCSn n) simRels simVal"

abbreviation
  "mkMCS \<equiv> mkKripke jkbpCS simRels simVal"

lemma jkbpCSn_jkbpCS_subset:
  "jkbpCSn n \<subseteq> jkbpCS"
  by (rule image_mono[OF jkbpCn_jkbpC_subset])

lemma sim_submodel_aux:
  assumes s: "s \<in> worlds (mkMCSn n)"
  shows "sub_model mkMCS s = sub_model (mkMCSn n) s"
proof(rule sub_model_subset[where T="jkbpCSn n"])
  from s show "s \<in> worlds mkMCS"
    by (simp add: set_mp[OF jkbpCSn_jkbpCS_subset])
  from s show "s \<in> worlds (mkMCSn n)" by assumption
next
  fix a
  show "relations mkMCS a \<inter> jkbpCSn n \<times> jkbpCSn n
      = relations (mkMCSn n) a \<inter> jkbpCSn n \<times> jkbpCSn n"
    by (simp add: Int_ac Int_absorb1
                  relation_mono[OF jkbpCSn_jkbpCS_subset jkbpCSn_jkbpCS_subset])
next
  from s
  show "(\<Union>a. relations (mkMCSn n) a)\<^sup>* `` {s} \<subseteq> jkbpCSn n"
    apply (clarsimp simp del: mkKripke_simps)
    apply (erule kripke_rels_trc_worlds)
    apply auto
    done
next
  from s obtain t
    where st: "s = simf t"
      and tCn: "t \<in> jkbpCn n"
    by fastsimp
  from tCn have tC: "t \<in> jkbpC" by blast
  { fix t'
    assume tt': "(t, t') \<in> (\<Union>a. relations mkMC a)\<^sup>*"
    from tC tt' have t'C: "t' \<in> jkbpC"
      by - (erule kripke_rels_trc_worlds, simp_all)
    from tCn tt' have t'Len: "tLength t' = n"
      by (auto dest: sync_tLength_eq_trc[where as=UNIV])
    from t'C t'Len have "t' \<in> jkbpCn n"
      by - (erule jkbpC_tLength_inv) }
  hence "(\<Union>a. relations mkMC a)\<^sup>* `` {t} \<subseteq> jkbpCn n"
    by clarsimp
  hence "simf ` ((\<Union>a. relations mkMC a)\<^sup>* `` {t}) \<subseteq> jkbpCSn n"
    by (rule image_mono)
  with st tC
  show "(\<Union>a. relations mkMCS a)\<^sup>* `` {s} \<subseteq> jkbpCSn n"
    using sim_trc_commute[OF _ simf, where t=t]
    by simp
qed simp_all

lemma jkbpC_jkbpCSn_jAction_eq:
  assumes tCn: "t \<in> jkbpCn n"
  shows "jAction mkMC t = jAction (mkMCSn n) (simf t)"
       (is "?lhs = ?rhs")
proof -
  have "?lhs = jAction mkMCS (simf t)"
    by (simp add: simulation_jAction_eq simf jkbpCn_jkbpC_inc[OF tCn])
  also have "... = ?rhs"
    using tCn
    by - ( rule sub_model_jAction_eq[OF sim_submodel_aux, where w="simf t"]
         , auto intro: sub_model_world_refl )
  finally show ?thesis .
qed

lemma FIXME_simObs_simAbs_cong:
  assumes tC: "t \<in> jkbpC"
      and tL: "tLength t > 0"
      and ec: "simAbs ec = sim_equiv_class a (spr_jview a t)"
      and ec': "simAbs ec = simAbs ec'"
  shows "simObs a ec = simObs a ec'"
  using assms simObs[rule_format, where a=a and t=t] by simp

lemma FIXME_jAction_simAbs_cong:
  assumes tC: "t \<in> jkbpC"
      and ec: "simAbs ec = sim_equiv_class a (spr_jview a t)"
      and ec': "simAbs ec = simAbs ec'"
  shows "set (simAction ec a) = set (simAction ec' a)"
  using assms simAction[rule_format, where a=a and t=t] by simp

lemma FIXME_simTrans_simAbs_cong:
  assumes tC: "t \<in> jkbpC"
      and ec: "simAbs ec = sim_equiv_class a (spr_jview a t)"
      and ec': "simAbs ec = simAbs ec'"
  shows "simAbs ` set (simTrans a ec) = simAbs ` set (simTrans a ec')"
  using assms simTrans[rule_format, where a=a and t=t] by simp


definition mkAutoSim :: "'a \<Rightarrow> ('obs, 'aAct, 'rep) Protocol" where
  "mkAutoSim a \<equiv>
     \<lparr> pInit = simInit a,
        pTrans = \<lambda>obs ec. (SOME ec'. ec' \<in> set (simTrans a ec) \<and> simObs a ec' = obs),
        pAct = \<lambda>ec. simAction ec a \<rparr>"


lemma mkAutoSim_simps[simp]:
  "pInit (mkAutoSim a) = simInit a"
  "pTrans (mkAutoSim a) = (\<lambda>obs ec. (SOME ec'. ec' \<in> set (simTrans a ec) \<and> simObs a ec' = obs))"
  "pAct (mkAutoSim a) = (\<lambda>ec. simAction ec a)"
  unfolding mkAutoSim_def by simp_all

lemma mkAutoSim_ec:
  assumes tC: "t \<in> jkbpC"
  shows "simAbs (runJP mkAutoSim t a) = sim_equiv_class a (spr_jview a t)"
using tC
proof(induct t)
  case (tInit s) thus ?case by (auto simp: simInit spr_jview_def)
next
  case (tStep t s)
  hence tC: "t \<in> jkbpC" by blast

      from tC tStep
      have F: "simAbs ` set (simTrans a (runJP mkAutoSim t a))
             = { sim_equiv_class a (spr_jview a (t' \<leadsto> s))
                 |t' s. t' \<leadsto> s \<in> jkbpC \<and> spr_jview a t' = spr_jview a t}"
        using simTrans[rule_format, where a=a and t=t and ec="runJP mkAutoSim t a"]
        apply clarsimp
        done

      from tStep
      have G: "sim_equiv_class a (spr_jview a (t \<leadsto> s))
             \<in> { sim_equiv_class a (spr_jview a (t' \<leadsto> s))
                |t' s. t' \<leadsto> s \<in> jkbpC \<and> spr_jview a t' = spr_jview a t}"
        by auto

      from F G
      have H: "sim_equiv_class a (spr_jview a (t \<leadsto> s)) \<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))"
        by simp

      then obtain r
        where R: "r \<in> set (simTrans a (runJP mkAutoSim t a))"
        and S: "simAbs r = sim_equiv_class a (spr_jview a (t \<leadsto> s))"
        by auto

  show ?case
  proof(simp, rule someI2)
    from R S tStep tC
    show "r \<in> set (simTrans a (runJP mkAutoSim t a)) \<and> simObs a r = envObs a s" by (simp add: simObs[rule_format, where a=a and t="t\<leadsto>s"])
  next
    fix x assume x: "x \<in> set (simTrans a (runJP mkAutoSim t a)) \<and> simObs a x = envObs a s"

    from x
    have A: "simObs a x = envObs a s" by simp

    from x
    have "simAbs x \<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))" by simp
    with tStep tC
    have "simAbs x \<in> { sim_equiv_class a (spr_jview a (t' \<leadsto> s))
                         |t' s. t' \<leadsto> s \<in> jkbpC \<and> spr_jview a t' = spr_jview a t}"
      using simTrans[rule_format, where a=a and t=t] by simp
    then obtain t' s'
      where X: "simAbs x = sim_equiv_class a (spr_jview a (t' \<leadsto> s'))"
          and Y: "t' \<leadsto> s' \<in> jkbpC"
          and Z: "spr_jview a t' = spr_jview a t"
      by auto

    from A X Y Z
    show "simAbs x = sim_equiv_class a (spr_jview a (t \<leadsto> s))"
      using simObs[rule_format, where a=a and t="t'\<leadsto>s'" and ec=x, symmetric] by (simp add: spr_jview_def)
  qed
qed

lemma mkAutoSim_implements:
  "implements mkAutoSim"
  apply rule
  apply rule
  apply (auto dest: jkbpCn_jkbpC_inc iff: mkAutoSim_ec simAction)
  done

end (* context *)

end

