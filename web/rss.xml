<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>10 Apr 2020 00:00:00 +0000</pubDate>
    <item>
       <title>Formalization of an Algorithm for Greedily Computing Associative Aggregations on Sliding Windows</title>
              <link>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</link>
       <guid>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</guid>
       <dc:creator> Lukas Heimes, Dmitriy Traytel, Joshua Schneider       </dc:creator>
       <pubDate>10 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Basin et al.&#39;s &lt;a
href=&#34;https://doi.org/10.1016/j.ipl.2014.09.009&#34;&gt;sliding
window algorithm (SWA)&lt;/a&gt; is an algorithm for combining the
elements of subsequences of a sequence with an associative operator.
It is greedy and minimizes the number of operator applications. We
formalize the algorithm and verify its functional correctness. We
extend the algorithm with additional operations and provide an
alternative interface to the slide operation that does not require the
entire input sequence.</description>
    </item>
    <item>
       <title>A Comprehensive Framework for Saturation Theorem Proving</title>
              <link>https://www.isa-afp.org/entries/Saturation_Framework.html</link>
       <guid>https://www.isa-afp.org/entries/Saturation_Framework.html</guid>
       <dc:creator> Sophie Tourret       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization is the companion of the technical
report ‚ÄúA comprehensive framework for saturation theorem proving‚Äù,
itself companion of the eponym IJCAR 2020 paper, written by Uwe
Waldmann, Sophie Tourret, Simon Robillard and Jasmin Blanchette. It
verifies a framework for formal refutational completeness proofs of
abstract provers that implement saturation calculi, such as ordered
resolution or superposition, and allows to model entire prover
architectures in such a way that the static refutational completeness
of a calculus immediately implies the dynamic  refutational
completeness of a prover implementing the calculus using a variant of
the given clause loop.  The technical report ‚ÄúA comprehensive
framework for saturation theorem proving‚Äù is available &lt;a
href=&#34;http://matryoshka.gforge.inria.fr/pubs/satur_report.pdf&#34;&gt;on
the Matryoshka website&lt;/a&gt;. The names of the Isabelle lemmas and
theorems corresponding to the results in the report are indicated in
the margin of the report.</description>
    </item>
    <item>
       <title>Formalization of an Optimized Monitoring Algorithm for Metric First-Order Dynamic Logic with Aggregations</title>
              <link>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</link>
       <guid>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</guid>
       <dc:creator> Thibault Dardinier, Lukas Heimes, Martin Raszyk, Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
dynamic logic (MFODL), which combines the features of metric
first-order temporal logic (MFOTL) and metric dynamic logic. Thus,
MFODL supports real-time constraints, first-order parameters, and
regular expressions. Additionally, the monitor supports aggregation
operations such as count and sum. This formalization, which is
described in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/ijcar20-verimonplus/verimonplus.pdf&#34;&gt;
forthcoming paper at IJCAR 2020&lt;/a&gt;, significantly extends &lt;a
href=&#34;https://www.isa-afp.org/entries/MFOTL_Monitor.html&#34;&gt;previous
work on a verified monitor&lt;/a&gt; for MFOTL. Apart from the
addition of regular expressions and aggregations, we implemented &lt;a
href=&#34;https://www.isa-afp.org/entries/Generic_Join.html&#34;&gt;multi-way
joins&lt;/a&gt; and a specialized sliding window algorithm to further
optimize the monitor.</description>
    </item>
    <item>
       <title>Strong Eventual Consistency of the Collaborative Editing Framework WOOT</title>
              <link>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</link>
       <guid>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</guid>
       <dc:creator> Emin Karayel, Edgar Gonz√†lez       </dc:creator>
       <pubDate>25 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Commutative Replicated Data Types (CRDTs) are a promising new class of
data structures for large-scale shared mutable content in applications
that only require eventual consistency. The WithOut Operational
Transforms (WOOT) framework is a CRDT for collaborative text editing
introduced by Oster et al. (CSCW 2006) for which the eventual
consistency property was verified only for a bounded model to date. We
contribute a formal proof for WOOTs strong eventual consistency.</description>
    </item>
    <item>
       <title>Furstenberg's topology and his proof of the infinitude of primes</title>
              <link>https://www.isa-afp.org/entries/Furstenberg_Topology.html</link>
       <guid>https://www.isa-afp.org/entries/Furstenberg_Topology.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>22 Mar 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article gives a formal version of Furstenberg&#39;s
topological proof of the infinitude of primes. He defines a topology
on the integers based on arithmetic progressions (or, equivalently,
residue classes). Using some fairly obvious properties of this
topology, the infinitude of primes is then easily obtained.&lt;/p&gt;
&lt;p&gt;Apart from this, this topology is also fairly `nice&#39; in
general: it is second countable, metrizable, and perfect. All of these
(well-known) facts are formally proven, including an explicit metric
for the topology given by Zulfeqarr.&lt;/p&gt;</description>
    </item>
    <item>
       <title>An Under-Approximate Relational Logic</title>
              <link>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</guid>
       <dc:creator> Toby Murray       </dc:creator>
       <pubDate>12 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Recently, authors have proposed under-approximate logics for reasoning
about programs. So far, all such logics have been confined to
reasoning about individual program behaviours. Yet there exist many
over-approximate relational logics for reasoning about pairs of
programs and relating their behaviours. We present the first
under-approximate relational logic, for the simple imperative language
IMP. We prove our logic is both sound and complete. Additionally, we
show how reasoning in this logic can be decomposed into non-relational
reasoning in an under-approximate Hoare logic, mirroring Beringer‚Äôs
result for over-approximate relational logics. We illustrate the
application of our logic on some small examples in which we provably
demonstrate the presence of insecurity.</description>
    </item>
    <item>
       <title>Hello World</title>
              <link>https://www.isa-afp.org/entries/Hello_World.html</link>
       <guid>https://www.isa-afp.org/entries/Hello_World.html</guid>
       <dc:creator> Cornelius Diekmann, Lars Hupel       </dc:creator>
       <pubDate>07 Mar 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a formalization of the well-known
&#34;Hello, World!&#34; code, including a formal framework for
reasoning about IO. Our model is inspired by the handling of IO in
Haskell. We start by formalizing the üåç and embrace the IO monad
afterwards. Then we present a sample main :: IO (), followed by its
proof of correctness.</description>
    </item>
    <item>
       <title>Implementing the Goodstein Function in &lambda;-Calculus</title>
              <link>https://www.isa-afp.org/entries/Goodstein_Lambda.html</link>
       <guid>https://www.isa-afp.org/entries/Goodstein_Lambda.html</guid>
       <dc:creator> Bertram Felgenhauer       </dc:creator>
       <pubDate>21 Feb 2020 00:00:00 +0000</pubDate>
       <description>
In this formalization, we develop an implementation of the Goodstein
function G in plain &amp;lambda;-calculus, linked to a concise, self-contained
specification. The implementation works on a Church-encoded
representation of countable ordinals. The initial conversion to
hereditary base 2 is not covered, but the material is sufficient to
compute the particular value G(16), and easily extends to other fixed
arguments.</description>
    </item>
    <item>
       <title>A Generic Framework for Verified Compilers</title>
              <link>https://www.isa-afp.org/entries/VeriComp.html</link>
       <guid>https://www.isa-afp.org/entries/VeriComp.html</guid>
       <dc:creator> Martin Desharnais       </dc:creator>
       <pubDate>10 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This is a generic framework for formalizing compiler transformations.
It leverages Isabelle/HOL‚Äôs locales to abstract over concrete
languages and transformations. It states common definitions for
language semantics, program behaviours, forward and backward
simulations, and compilers. We provide generic operations, such as
simulation and compiler composition, and prove general (partial)
correctness theorems, resulting in reusable proof components.</description>
    </item>
    <item>
       <title>Arithmetic progressions and relative primes</title>
              <link>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</guid>
       <dc:creator> Jos√© Manuel Rodr√≠guez Caballero       </dc:creator>
       <pubDate>01 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This article provides a formalization of the solution obtained by the
author of the Problem ‚ÄúARITHMETIC PROGRESSIONS‚Äù from the
&lt;a href=&#34;https://www.ocf.berkeley.edu/~wwu/riddles/putnam.shtml&#34;&gt;
Putnam exam problems of 2002&lt;/a&gt;. The statement of the problem is
as follows: For which integers &lt;em&gt;n&lt;/em&gt; &gt; 1 does the set of positive
integers less than and relatively prime to &lt;em&gt;n&lt;/em&gt; constitute an
arithmetic progression?</description>
    </item>
    <item>
       <title>A Hierarchy of Algebras for Boolean Subsets</title>
              <link>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</link>
       <guid>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</guid>
       <dc:creator> Walter Guttmann, Bernhard M√∂ller       </dc:creator>
       <pubDate>31 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present a collection of axiom systems for the construction of
Boolean subalgebras of larger overall algebras. The subalgebras are
defined as the range of a complement-like operation on a semilattice.
This technique has been used, for example, with the antidomain
operation, dynamic negation and Stone algebras. We present a common
ground for these constructions based on a new equational
axiomatisation of Boolean algebras.</description>
    </item>
    <item>
       <title>Mersenne primes and the Lucas‚ÄìLehmer test</title>
              <link>https://www.isa-afp.org/entries/Mersenne_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Mersenne_Primes.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>17 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides formal proofs of basic properties of
Mersenne numbers, i. e. numbers of the form
2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; - 1, and especially of
Mersenne primes.&lt;/p&gt; &lt;p&gt;In particular, an efficient,
verified, and executable version of the Lucas&amp;ndash;Lehmer test is
developed. This test decides primality for Mersenne numbers in time
polynomial in &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Verified Approximation Algorithms</title>
              <link>https://www.isa-afp.org/entries/Approximation_Algorithms.html</link>
       <guid>https://www.isa-afp.org/entries/Approximation_Algorithms.html</guid>
       <dc:creator> Robin E√ümann, Tobias Nipkow, Simon Robillard       </dc:creator>
       <pubDate>16 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present the first formal verification of approximation algorithms
for NP-complete optimization problems: vertex cover, independent set,
load balancing, and bin packing. The proofs correct incompletenesses
in existing proofs and improve the approximation ratio in one case.</description>
    </item>
    <item>
       <title>Closest Pair of Points Algorithms</title>
              <link>https://www.isa-afp.org/entries/Closest_Pair_Points.html</link>
       <guid>https://www.isa-afp.org/entries/Closest_Pair_Points.html</guid>
       <dc:creator> Martin Rau, Tobias Nipkow       </dc:creator>
       <pubDate>13 Jan 2020 00:00:00 +0000</pubDate>
       <description>
This entry provides two related verified divide-and-conquer algorithms
solving the fundamental &lt;em&gt;Closest Pair of Points&lt;/em&gt;
problem in Computational Geometry. Functional correctness and the
optimal running time of &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) are
proved. Executable code is generated which is empirically competitive
with handwritten reference implementations.</description>
    </item>
    <item>
       <title>Skip Lists</title>
              <link>https://www.isa-afp.org/entries/Skip_Lists.html</link>
       <guid>https://www.isa-afp.org/entries/Skip_Lists.html</guid>
       <dc:creator> Max W. Haslbeck, Manuel Eberl       </dc:creator>
       <pubDate>09 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt; Skip lists are sorted linked lists enhanced with shortcuts
and are an alternative to binary search trees. A skip lists consists
of multiple levels of sorted linked lists where a list on level n is a
subsequence of the list on level n ‚àí 1. In the ideal case, elements
are skipped in such a way that a lookup in a skip lists takes O(log n)
time. In a randomised skip list the skipped elements are choosen
randomly. &lt;/p&gt; &lt;p&gt; This entry contains formalized proofs
of the textbook results about the expected height and the expected
length of a search path in a randomised skip list. &lt;/p&gt;</description>
    </item>
    <item>
       <title>Bicategories</title>
              <link>https://www.isa-afp.org/entries/Bicategory.html</link>
       <guid>https://www.isa-afp.org/entries/Bicategory.html</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>06 Jan 2020 00:00:00 +0000</pubDate>
       <description>
Taking as a starting point the author&#39;s previous work on
developing aspects of category theory in Isabelle/HOL, this article
gives a compatible formalization of the notion of
&#34;bicategory&#34; and develops a framework within which formal
proofs of facts about bicategories can be given.  The framework
includes a number of basic results, including the Coherence Theorem,
the Strictness Theorem, pseudofunctors and biequivalence, and facts
about internal equivalences and adjunctions in a bicategory.  As a
driving application and demonstration of the utility of the framework,
it is used to give a formal proof of a theorem, due to Carboni,
Kasangian, and Street, that characterizes up to biequivalence the
bicategories of spans in a category with pullbacks.  The formalization
effort necessitated the filling-in of many details that were not
evident from the brief presentation in the original paper, as well as
identifying a few minor corrections along the way.</description>
    </item>
    <item>
       <title>The Irrationality of Œ∂(3)</title>
              <link>https://www.isa-afp.org/entries/Zeta_3_Irrational.html</link>
       <guid>https://www.isa-afp.org/entries/Zeta_3_Irrational.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>27 Dec 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a formalisation of Beukers&#39;s
straightforward analytic proof that Œ∂(3) is irrational. This was first
proven by Ap√©ry (which is why this result is also often called
‚ÄòAp√©ry&#39;s Theorem‚Äô) using a more algebraic approach. This
formalisation follows &lt;a
href=&#34;http://people.math.sc.edu/filaseta/gradcourses/Math785/Math785Notes4.pdf&#34;&gt;Filaseta&#39;s
presentation&lt;/a&gt; of Beukers&#39;s proof.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Formalizing a Seligman-Style Tableau System for Hybrid Logic</title>
              <link>https://www.isa-afp.org/entries/Hybrid_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Hybrid_Logic.html</guid>
       <dc:creator> Asta Halkj√¶r From       </dc:creator>
       <pubDate>20 Dec 2019 00:00:00 +0000</pubDate>
       <description>
This work is a formalization of soundness and completeness proofs for
a Seligman-style tableau system for hybrid logic. The completeness
result is obtained via a synthetic approach using maximally consistent
sets of tableau blocks. The formalization differs from the cited work
in a few ways. First, to avoid the need to backtrack in the
construction of a tableau, the formalized system has no unnamed
initial segment, and therefore no Name rule. Second, I show that the
full Bridge rule is derivable in the system. Third, I start from rules
restricted to only extend the branch with new formulas, including only
witnessing diamonds that are not already witnessed, and show that the
unrestricted rules are derivable. Similarly, I start from simpler
versions of the @-rules and derive the general ones. These
restrictions are imposed to rule out some means of nontermination.</description>
    </item>
    <item>
       <title>The Poincar√©-Bendixson Theorem</title>
              <link>https://www.isa-afp.org/entries/Poincare_Bendixson.html</link>
       <guid>https://www.isa-afp.org/entries/Poincare_Bendixson.html</guid>
       <dc:creator> Fabian Immler, Yong Kiam Tan       </dc:creator>
       <pubDate>18 Dec 2019 00:00:00 +0000</pubDate>
       <description>
The Poincar√©-Bendixson theorem is a classical result in the study of
(continuous) dynamical systems. Colloquially, it restricts the
possible behaviors of planar dynamical systems: such systems cannot be
chaotic. In practice, it is a useful tool for proving the existence of
(limiting) periodic behavior in planar systems. The theorem is an
interesting and challenging benchmark for formalized mathematics
because proofs in the literature rely on geometric sketches and only
hint at symmetric cases. It also requires a substantial background of
mathematical theories, e.g., the Jordan curve theorem, real analysis,
ordinary differential equations, and limiting (long-term) behavior of
dynamical systems.</description>
    </item>
    <item>
       <title>Poincar√© Disc Model</title>
              <link>https://www.isa-afp.org/entries/Poincare_Disc.html</link>
       <guid>https://www.isa-afp.org/entries/Poincare_Disc.html</guid>
       <dc:creator> Danijela Simiƒá, Filip Mariƒá, Pierre Boutry       </dc:creator>
       <pubDate>16 Dec 2019 00:00:00 +0000</pubDate>
       <description>
We describe formalization of the Poincar√© disc model of hyperbolic
geometry within the Isabelle/HOL proof assistant. The model is defined
within the extended complex plane (one dimensional complex projectives
space &amp;#8450;P1), formalized in the AFP entry ‚ÄúComplex Geometry‚Äù.
Points, lines, congruence of pairs of points, betweenness of triples
of points, circles, and isometries are defined within the model. It is
shown that the model satisfies all Tarski&#39;s axioms except the
Euclid&#39;s axiom. It is shown that it satisfies its negation and
the limiting parallels axiom (which proves it to be a model of
hyperbolic geometry).</description>
    </item>
    <item>
       <title>Complex Geometry</title>
              <link>https://www.isa-afp.org/entries/Complex_Geometry.html</link>
       <guid>https://www.isa-afp.org/entries/Complex_Geometry.html</guid>
       <dc:creator> Filip Mariƒá, Danijela Simiƒá       </dc:creator>
       <pubDate>16 Dec 2019 00:00:00 +0000</pubDate>
       <description>
A formalization of geometry of complex numbers is presented.
Fundamental objects that are investigated are the complex plane
extended by a single infinite point, its objects (points, lines and
circles), and groups of transformations that act on them (e.g.,
inversions and M√∂bius transformations). Most objects are defined
algebraically, but correspondence with classical geometric definitions
is shown.</description>
    </item>
    <item>
       <title>Gauss Sums and the P√≥lya‚ÄìVinogradov Inequality</title>
              <link>https://www.isa-afp.org/entries/Gauss_Sums.html</link>
       <guid>https://www.isa-afp.org/entries/Gauss_Sums.html</guid>
       <dc:creator> Rodrigo Raya, Manuel Eberl       </dc:creator>
       <pubDate>10 Dec 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a full formalisation of Chapter 8 of
Apostol&#39;s &lt;em&gt;&lt;a
href=&#34;https://www.springer.com/de/book/9780387901633&#34;&gt;Introduction
to Analytic Number Theory&lt;/a&gt;&lt;/em&gt;. Subjects that are
covered are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;periodic arithmetic
functions and their finite Fourier series&lt;/li&gt;
&lt;li&gt;(generalised) Ramanujan sums&lt;/li&gt; &lt;li&gt;Gauss sums
and separable characters&lt;/li&gt; &lt;li&gt;induced moduli and
primitive characters&lt;/li&gt; &lt;li&gt;the
P√≥lya&amp;mdash;Vinogradov inequality&lt;/li&gt; &lt;/ul&gt;</description>
    </item>
    <item>
       <title>An Efficient Generalization of Counting Sort for Large, possibly Infinite Key Ranges</title>
              <link>https://www.isa-afp.org/entries/Generalized_Counting_Sort.html</link>
       <guid>https://www.isa-afp.org/entries/Generalized_Counting_Sort.html</guid>
       <dc:creator> Pasquale Noce       </dc:creator>
       <pubDate>04 Dec 2019 00:00:00 +0000</pubDate>
       <description>
Counting sort is a well-known algorithm that sorts objects of any kind
mapped to integer keys, or else to keys in one-to-one correspondence
with some subset of the integers (e.g. alphabet letters). However, it
is suitable for direct use, viz. not just as a subroutine of another
sorting algorithm (e.g. radix sort), only if the key range is not
significantly larger than the number of the objects to be sorted.
This paper describes a tail-recursive generalization of counting sort
making use of a bounded number of counters, suitable for direct use in
case of a large, or even infinite key range of any kind, subject to
the only constraint of being a subset of an arbitrary linear order.
After performing a pen-and-paper analysis of how such algorithm has to
be designed to maximize its efficiency, this paper formalizes the
resulting generalized counting sort (GCsort) algorithm and then
formally proves its correctness properties, namely that (a) the
counters&#39; number is maximized never exceeding the fixed upper
bound, (b) objects are conserved, (c) objects get sorted, and (d) the
algorithm is stable.</description>
    </item>
    <item>
       <title>Interval Arithmetic on 32-bit Words</title>
              <link>https://www.isa-afp.org/entries/Interval_Arithmetic_Word32.html</link>
       <guid>https://www.isa-afp.org/entries/Interval_Arithmetic_Word32.html</guid>
       <dc:creator> Brandon Bohrer       </dc:creator>
       <pubDate>27 Nov 2019 00:00:00 +0000</pubDate>
       <description>
Interval_Arithmetic implements conservative interval arithmetic
computations, then uses this interval arithmetic to implement a simple
programming language where all terms have 32-bit signed word values,
with explicit infinities for terms outside the representable bounds.
Our target use case is interpreters for languages that must have a
well-understood low-level behavior.  We include a formalization of
bounded-length strings which are used for the identifiers of our
language. Bounded-length identifiers are useful in some applications,
for example the &lt;a href=&#34;https://www.isa-afp.org/entries/Differential_Dynamic_Logic.html&#34;&gt;Differential_Dynamic_Logic&lt;/a&gt; article,
where a Euclidean space indexed by identifiers demands that identifiers
are finitely many.</description>
    </item>
    <item>
       <title>Zermelo Fraenkel Set Theory in Higher-Order Logic</title>
              <link>https://www.isa-afp.org/entries/ZFC_in_HOL.html</link>
       <guid>https://www.isa-afp.org/entries/ZFC_in_HOL.html</guid>
       <dc:creator> Lawrence C. Paulson       </dc:creator>
       <pubDate>24 Oct 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry is a new formalisation of ZFC set theory in Isabelle/HOL. It is
logically equivalent to Obua&#39;s HOLZF; the point is to have the closest
possible integration with the rest of Isabelle/HOL, minimising the amount of
new notations and exploiting type classes.&lt;/p&gt;
&lt;p&gt;There is a type &lt;em&gt;V&lt;/em&gt; of sets and a function &lt;em&gt;elts :: V =&amp;gt; V
set&lt;/em&gt; mapping a set to its elements. Classes simply have type &lt;em&gt;V
set&lt;/em&gt;, and a predicate identifies the small classes: those that correspond
to actual sets. Type classes connected with orders and lattices are used to
minimise the amount of new notation for concepts such as the subset relation,
union and intersection. Basic concepts ‚Äî Cartesian products, disjoint sums,
natural numbers, functions, etc. ‚Äî are formalised.&lt;/p&gt;
&lt;p&gt;More advanced set-theoretic concepts, such as transfinite induction,
ordinals, cardinals and the transitive closure of a set, are also provided.
The definition of addition and multiplication for general sets (not just
ordinals) follows Kirby.&lt;/p&gt;
&lt;p&gt;The theory provides two type classes with the aim of facilitating
developments that combine &lt;em&gt;V&lt;/em&gt; with other Isabelle/HOL types:
&lt;em&gt;embeddable&lt;/em&gt;, the class of types that can be injected into &lt;em&gt;V&lt;/em&gt;
(including &lt;em&gt;V&lt;/em&gt; itself as well as &lt;em&gt;V*V&lt;/em&gt;, etc.), and
&lt;em&gt;small&lt;/em&gt;, the class of types that correspond to some ZF set.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Isabelle/C</title>
              <link>https://www.isa-afp.org/entries/Isabelle_C.html</link>
       <guid>https://www.isa-afp.org/entries/Isabelle_C.html</guid>
       <dc:creator> Fr√©d√©ric Tuong, Burkhart Wolff       </dc:creator>
       <pubDate>22 Oct 2019 00:00:00 +0000</pubDate>
       <description>
We present a framework for C code in C11 syntax deeply integrated into
the Isabelle/PIDE development environment. Our framework provides an
abstract interface for verification back-ends to be plugged-in
independently. Thus, various techniques such as deductive program
verification or white-box testing can be applied to the same source,
which is part of an integrated PIDE document model. Semantic back-ends
are free to choose the supported C fragment and its semantics. In
particular, they can differ on the chosen memory model or the
specification mechanism for framing conditions. Our framework supports
semantic annotations of C sources in the form of comments. Annotations
serve to locally control back-end settings, and can express the term
focus to which an annotation refers. Both the logical and the
syntactic context are available when semantic annotations are
evaluated. As a consequence, a formula in an annotation can refer both
to HOL or C variables. Our approach demonstrates the degree of
maturity and expressive power the Isabelle/PIDE sub-system has
achieved in recent years. Our integration technique employs Lex and
Yacc style grammars to ensure efficient deterministic parsing.  This
is the core-module of Isabelle/C; the AFP package for Clean and
Clean_wrapper as well as AutoCorres and AutoCorres_wrapper (available
via git) are applications of this front-end.</description>
    </item>
    <item>
       <title>VerifyThis 2019 -- Polished Isabelle Solutions</title>
              <link>https://www.isa-afp.org/entries/VerifyThis2019.html</link>
       <guid>https://www.isa-afp.org/entries/VerifyThis2019.html</guid>
       <dc:creator> Peter Lammich, Simon Wimmer       </dc:creator>
       <pubDate>16 Oct 2019 00:00:00 +0000</pubDate>
       <description>
VerifyThis 2019 (http://www.pm.inf.ethz.ch/research/verifythis.html)
was a program verification competition associated with ETAPS 2019. It
was the 8th event in the VerifyThis competition series. In this entry,
we present polished and completed versions of our solutions that we
created during the competition.</description>
    </item>
    <item>
       <title>Aristotle's Assertoric Syllogistic</title>
              <link>https://www.isa-afp.org/entries/Aristotles_Assertoric_Syllogistic.html</link>
       <guid>https://www.isa-afp.org/entries/Aristotles_Assertoric_Syllogistic.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki       </dc:creator>
       <pubDate>08 Oct 2019 00:00:00 +0000</pubDate>
       <description>
We formalise with Isabelle/HOL some basic elements of Aristotle&#39;s
assertoric syllogistic following the &lt;a
href=&#34;https://plato.stanford.edu/entries/aristotle-logic/&#34;&gt;article from the Stanford Encyclopedia of Philosophy by Robin Smith.&lt;/a&gt; To
this end, we use a set theoretic formulation (covering both individual
and general predication). In particular, we formalise the deductions
in the Figures and after that we present Aristotle&#39;s
metatheoretical observation that all deductions in the Figures can in
fact be reduced to either Barbara or Celarent. As the formal proofs
prove to be straightforward, the interest of this entry lies in
illustrating the functionality of Isabelle and high efficiency of
Sledgehammer for simple exercises in philosophy.</description>
    </item>
    <item>
       <title>Sigma Protocols and Commitment Schemes</title>
              <link>https://www.isa-afp.org/entries/Sigma_Commit_Crypto.html</link>
       <guid>https://www.isa-afp.org/entries/Sigma_Commit_Crypto.html</guid>
       <dc:creator> David Butler, Andreas Lochbihler       </dc:creator>
       <pubDate>07 Oct 2019 00:00:00 +0000</pubDate>
       <description>
We use CryptHOL to formalise commitment schemes and Sigma-protocols.
Both are widely used fundamental two party cryptographic primitives.
Security for commitment schemes is considered using game-based
definitions whereas the security of Sigma-protocols is considered
using both the game-based and simulation-based security paradigms. In
this work, we first define security for both primitives and then prove
secure multiple case studies: the Schnorr, Chaum-Pedersen and
Okamoto Sigma-protocols as well as a construction that allows for
compound (AND and OR statements) Sigma-protocols and the Pedersen and
Rivest commitment schemes. We also prove that commitment schemes can
be constructed from Sigma-protocols. We formalise this proof at an
abstract level, only assuming the existence of a Sigma-protocol;
consequently, the instantiations of this result for the concrete
Sigma-protocols we consider come for free.</description>
    </item>
    <item>
       <title>Clean - An Abstract Imperative Programming Language and its Theory</title>
              <link>https://www.isa-afp.org/entries/Clean.html</link>
       <guid>https://www.isa-afp.org/entries/Clean.html</guid>
       <dc:creator> Fr√©d√©ric Tuong, Burkhart Wolff       </dc:creator>
       <pubDate>04 Oct 2019 00:00:00 +0000</pubDate>
       <description>
Clean is based on a simple, abstract execution model for an imperative
target language. ‚ÄúAbstract‚Äù is understood in contrast to ‚ÄúConcrete
Semantics‚Äù; alternatively, the term ‚Äúshallow-style embedding‚Äù could be
used. It strives for a type-safe notion of program-variables, an
incremental construction of the typed state-space, support of
incremental verification, and open-world extensibility of new type
definitions being intertwined with the program definitions. Clean is
based on a ‚Äúno-frills‚Äù state-exception monad with the usual
definitions of bind and unit for the compositional glue of state-based
computations. Clean offers conditionals and loops supporting C-like
control-flow operators such as break and return. The state-space
construction is based on the extensible record package. Direct
recursion of procedures is supported. Clean‚Äôs design strives for
extreme simplicity. It is geared towards symbolic execution and proven
correct verification tools. The underlying libraries of this package,
however, deliberately restrict themselves to the most elementary
infrastructure for these tasks. The package is intended to serve as
demonstrator semantic backend for Isabelle/C, or for the
test-generation techniques.</description>
    </item>
  </channel>
</rss>
