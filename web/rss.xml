<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>04 Dec 2019 00:00:00 +0000</pubDate>
    <item>
       <title>An Efficient Generalization of Counting Sort for Large, possibly Infinite Key Ranges</title>
              <link>https://www.isa-afp.org/entries/Generalized_Counting_Sort.html</link>
       <guid>https://www.isa-afp.org/entries/Generalized_Counting_Sort.html</guid>
       <dc:creator> Pasquale Noce       </dc:creator>
       <pubDate>04 Dec 2019 00:00:00 +0000</pubDate>
       <description>
Counting sort is a well-known algorithm that sorts objects of any kind
mapped to integer keys, or else to keys in one-to-one correspondence
with some subset of the integers (e.g. alphabet letters). However, it
is suitable for direct use, viz. not just as a subroutine of another
sorting algorithm (e.g. radix sort), only if the key range is not
significantly larger than the number of the objects to be sorted.
This paper describes a tail-recursive generalization of counting sort
making use of a bounded number of counters, suitable for direct use in
case of a large, or even infinite key range of any kind, subject to
the only constraint of being a subset of an arbitrary linear order.
After performing a pen-and-paper analysis of how such algorithm has to
be designed to maximize its efficiency, this paper formalizes the
resulting generalized counting sort (GCsort) algorithm and then
formally proves its correctness properties, namely that (a) the
counters&#39; number is maximized never exceeding the fixed upper
bound, (b) objects are conserved, (c) objects get sorted, and (d) the
algorithm is stable.</description>
    </item>
    <item>
       <title>Interval Arithmetic on 32-bit Words</title>
              <link>https://www.isa-afp.org/entries/Interval_Arithmetic_Word32.html</link>
       <guid>https://www.isa-afp.org/entries/Interval_Arithmetic_Word32.html</guid>
       <dc:creator> Brandon Bohrer       </dc:creator>
       <pubDate>27 Nov 2019 00:00:00 +0000</pubDate>
       <description>
Interval_Arithmetic implements conservative interval arithmetic
computations, then uses this interval arithmetic to implement a simple
programming language where all terms have 32-bit signed word values,
with explicit infinities for terms outside the representable bounds.
Our target use case is interpreters for languages that must have a
well-understood low-level behavior.  We include a formalization of
bounded-length strings which are used for the identifiers of our
language. Bounded-length identifiers are useful in some applications,
for example the &lt;a href=&#34;https://www.isa-afp.org/entries/Differential_Dynamic_Logic.html&#34;&gt;Differential_Dynamic_Logic&lt;/a&gt; article,
where a Euclidean space indexed by identifiers demands that identifiers
are finitely many.</description>
    </item>
    <item>
       <title>Zermelo Fraenkel Set Theory in Higher-Order Logic</title>
              <link>https://www.isa-afp.org/entries/ZFC_in_HOL.html</link>
       <guid>https://www.isa-afp.org/entries/ZFC_in_HOL.html</guid>
       <dc:creator> Lawrence C. Paulson       </dc:creator>
       <pubDate>24 Oct 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry is a new formalisation of ZFC set theory in Isabelle/HOL. It is
logically equivalent to Obua&#39;s HOLZF; the point is to have the closest
possible integration with the rest of Isabelle/HOL, minimising the amount of
new notations and exploiting type classes.&lt;/p&gt;
&lt;p&gt;There is a type &lt;em&gt;V&lt;/em&gt; of sets and a function &lt;em&gt;elts :: V =&amp;gt; V
set&lt;/em&gt; mapping a set to its elements. Classes simply have type &lt;em&gt;V
set&lt;/em&gt;, and a predicate identifies the small classes: those that correspond
to actual sets. Type classes connected with orders and lattices are used to
minimise the amount of new notation for concepts such as the subset relation,
union and intersection. Basic concepts — Cartesian products, disjoint sums,
natural numbers, functions, etc. — are formalised.&lt;/p&gt;
&lt;p&gt;More advanced set-theoretic concepts, such as transfinite induction,
ordinals, cardinals and the transitive closure of a set, are also provided.
The definition of addition and multiplication for general sets (not just
ordinals) follows Kirby.&lt;/p&gt;
&lt;p&gt;The theory provides two type classes with the aim of facilitating
developments that combine &lt;em&gt;V&lt;/em&gt; with other Isabelle/HOL types:
&lt;em&gt;embeddable&lt;/em&gt;, the class of types that can be injected into &lt;em&gt;V&lt;/em&gt;
(including &lt;em&gt;V&lt;/em&gt; itself as well as &lt;em&gt;V*V&lt;/em&gt;, etc.), and
&lt;em&gt;small&lt;/em&gt;, the class of types that correspond to some ZF set.&lt;/p&gt;</description>
    </item>
    <item>
       <title>VerifyThis 2019 -- Polished Isabelle Solutions</title>
              <link>https://www.isa-afp.org/entries/VerifyThis2019.html</link>
       <guid>https://www.isa-afp.org/entries/VerifyThis2019.html</guid>
       <dc:creator> Peter Lammich, Simon Wimmer       </dc:creator>
       <pubDate>16 Oct 2019 00:00:00 +0000</pubDate>
       <description>
VerifyThis 2019 (http://www.pm.inf.ethz.ch/research/verifythis.html)
was a program verification competition associated with ETAPS 2019. It
was the 8th event in the VerifyThis competition series. In this entry,
we present polished and completed versions of our solutions that we
created during the competition.</description>
    </item>
    <item>
       <title>Aristotle's Assertoric Syllogistic</title>
              <link>https://www.isa-afp.org/entries/Aristotles_Assertoric_Syllogistic.html</link>
       <guid>https://www.isa-afp.org/entries/Aristotles_Assertoric_Syllogistic.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki       </dc:creator>
       <pubDate>08 Oct 2019 00:00:00 +0000</pubDate>
       <description>
We formalise with Isabelle/HOL some basic elements of Aristotle&#39;s
assertoric syllogistic following the &lt;a
href=&#34;https://plato.stanford.edu/entries/aristotle-logic/&#34;&gt;article from the Stanford Encyclopedia of Philosophy by Robin Smith.&lt;/a&gt; To
this end, we use a set theoretic formulation (covering both individual
and general predication). In particular, we formalise the deductions
in the Figures and after that we present Aristotle&#39;s
metatheoretical observation that all deductions in the Figures can in
fact be reduced to either Barbara or Celarent. As the formal proofs
prove to be straightforward, the interest of this entry lies in
illustrating the functionality of Isabelle and high efficiency of
Sledgehammer for simple exercises in philosophy.</description>
    </item>
    <item>
       <title>Sigma Protocols and Commitment Schemes</title>
              <link>https://www.isa-afp.org/entries/Sigma_Commit_Crypto.html</link>
       <guid>https://www.isa-afp.org/entries/Sigma_Commit_Crypto.html</guid>
       <dc:creator> David Butler, Andreas Lochbihler       </dc:creator>
       <pubDate>07 Oct 2019 00:00:00 +0000</pubDate>
       <description>
We use CryptHOL to formalise commitment schemes and Sigma-protocols.
Both are widely used fundamental two party cryptographic primitives.
Security for commitment schemes is considered using game-based
definitions whereas the security of Sigma-protocols is considered
using both the game-based and simulation-based security paradigms. In
this work, we first define security for both primitives and then prove
secure multiple case studies: the Schnorr, Chaum-Pedersen and
Okamoto Sigma-protocols as well as a construction that allows for
compound (AND and OR statements) Sigma-protocols and the Pedersen and
Rivest commitment schemes. We also prove that commitment schemes can
be constructed from Sigma-protocols. We formalise this proof at an
abstract level, only assuming the existence of a Sigma-protocol;
consequently, the instantiations of this result for the concrete
Sigma-protocols we consider come for free.</description>
    </item>
    <item>
       <title>Clean - An Abstract Imperative Programming Language and its Theory</title>
              <link>https://www.isa-afp.org/entries/Clean.html</link>
       <guid>https://www.isa-afp.org/entries/Clean.html</guid>
       <dc:creator> Frédéric Tuong, Burkhart Wolff       </dc:creator>
       <pubDate>04 Oct 2019 00:00:00 +0000</pubDate>
       <description>
Clean is based on a simple, abstract execution model for an imperative
target language. “Abstract” is understood in contrast to “Concrete
Semantics”; alternatively, the term “shallow-style embedding” could be
used. It strives for a type-safe notion of program-variables, an
incremental construction of the typed state-space, support of
incremental verification, and open-world extensibility of new type
definitions being intertwined with the program definitions. Clean is
based on a “no-frills” state-exception monad with the usual
definitions of bind and unit for the compositional glue of state-based
computations. Clean offers conditionals and loops supporting C-like
control-flow operators such as break and return. The state-space
construction is based on the extensible record package. Direct
recursion of procedures is supported. Clean’s design strives for
extreme simplicity. It is geared towards symbolic execution and proven
correct verification tools. The underlying libraries of this package,
however, deliberately restrict themselves to the most elementary
infrastructure for these tasks. The package is intended to serve as
demonstrator semantic backend for Isabelle/C, or for the
test-generation techniques.</description>
    </item>
    <item>
       <title>Formalization of Multiway-Join Algorithms</title>
              <link>https://www.isa-afp.org/entries/Generic_Join.html</link>
       <guid>https://www.isa-afp.org/entries/Generic_Join.html</guid>
       <dc:creator> Thibault Dardinier       </dc:creator>
       <pubDate>16 Sep 2019 00:00:00 +0000</pubDate>
       <description>
Worst-case optimal multiway-join algorithms are recent seminal
achievement of the database community. These algorithms compute the
natural join of multiple relational databases and improve in the worst
case over traditional query plan optimizations of nested binary joins.
In 2014, &lt;a
href=&#34;https://doi.org/10.1145/2590989.2590991&#34;&gt;Ngo, Ré,
and Rudra&lt;/a&gt; gave a unified presentation of different multi-way
join algorithms. We formalized and proved correct their &#34;Generic
Join&#34; algorithm and extended it to support negative joins.</description>
    </item>
    <item>
       <title>Verification Components for Hybrid Systems</title>
              <link>https://www.isa-afp.org/entries/Hybrid_Systems_VCs.html</link>
       <guid>https://www.isa-afp.org/entries/Hybrid_Systems_VCs.html</guid>
       <dc:creator> Jonathan Julian Huerta y Munive       </dc:creator>
       <pubDate>10 Sep 2019 00:00:00 +0000</pubDate>
       <description>
These components formalise a semantic framework for the deductive
verification of hybrid systems. They support reasoning about
continuous evolutions of hybrid programs in the style of differential
dynamics logic. Vector fields or flows model these evolutions, and
their verification is done with invariants for the former or orbits
for the latter. Laws of modal Kleene algebra or categorical predicate
transformers implement the verification condition generation. Examples
show the approach at work.</description>
    </item>
    <item>
       <title>Fourier Series</title>
              <link>https://www.isa-afp.org/entries/Fourier.html</link>
       <guid>https://www.isa-afp.org/entries/Fourier.html</guid>
       <dc:creator> Lawrence C Paulson       </dc:creator>
       <pubDate>06 Sep 2019 00:00:00 +0000</pubDate>
       <description>
This development formalises the square integrable functions over the
reals and the basics of Fourier series. It culminates with a proof
that every well-behaved periodic function can be approximated by a
Fourier series. The material is ported from HOL Light:
https://github.com/jrh13/hol-light/blob/master/100/fourier.ml</description>
    </item>
    <item>
       <title>A Case Study in Basic Algebra</title>
              <link>https://www.isa-afp.org/entries/Jacobson_Basic_Algebra.html</link>
       <guid>https://www.isa-afp.org/entries/Jacobson_Basic_Algebra.html</guid>
       <dc:creator> Clemens Ballarin       </dc:creator>
       <pubDate>30 Aug 2019 00:00:00 +0000</pubDate>
       <description>
The focus of this case study is re-use in abstract algebra.  It
contains locale-based formalisations of selected parts of set, group
and ring theory from Jacobson&#39;s &lt;i&gt;Basic Algebra&lt;/i&gt;
leading to the respective fundamental homomorphism theorems.  The
study is not intended as a library base for abstract algebra.  It
rather explores an approach towards abstract algebra in Isabelle.</description>
    </item>
    <item>
       <title>Formalisation of an Adaptive State Counting Algorithm</title>
              <link>https://www.isa-afp.org/entries/Adaptive_State_Counting.html</link>
       <guid>https://www.isa-afp.org/entries/Adaptive_State_Counting.html</guid>
       <dc:creator> Robert Sachtleben       </dc:creator>
       <pubDate>16 Aug 2019 00:00:00 +0000</pubDate>
       <description>
This entry provides a formalisation of a refinement of an adaptive
state counting algorithm, used to test for reduction between finite
state machines. The algorithm has been originally presented by Hierons
in the paper &lt;a
href=&#34;https://doi.org/10.1109/TC.2004.85&#34;&gt;Testing from a
Non-Deterministic Finite State Machine Using Adaptive State
Counting&lt;/a&gt;.  Definitions for finite state machines and
adaptive test cases are given and many useful theorems are derived
from these. The algorithm is formalised using mutually recursive
functions, for which it is proven that the generated test suite is
sufficient to test for reduction against finite state machines of a
certain fault domain. Additionally, the algorithm is specified in a
simple WHILE-language and its correctness is shown using Hoare-logic.</description>
    </item>
    <item>
       <title>Laplace Transform</title>
              <link>https://www.isa-afp.org/entries/Laplace_Transform.html</link>
       <guid>https://www.isa-afp.org/entries/Laplace_Transform.html</guid>
       <dc:creator> Fabian Immler       </dc:creator>
       <pubDate>14 Aug 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the Laplace transform and concrete Laplace
transforms for arithmetic functions, frequency shift, integration and
(higher) differentiation in the time domain. It proves Lerch&#39;s
lemma and uniqueness of the Laplace transform for continuous
functions. In order to formalize the foundational assumptions, this
entry contains a formalization of piecewise continuous functions and
functions of exponential order.</description>
    </item>
    <item>
       <title>Linear Programming</title>
              <link>https://www.isa-afp.org/entries/Linear_Programming.html</link>
       <guid>https://www.isa-afp.org/entries/Linear_Programming.html</guid>
       <dc:creator> Julian Parsert, Cezary Kaliszyk       </dc:creator>
       <pubDate>06 Aug 2019 00:00:00 +0000</pubDate>
       <description>
We use the previous formalization of the general simplex algorithm to
formulate an algorithm for solving linear programs. We encode the
linear programs using only linear constraints. Solving these
constraints also solves the original linear program. This algorithm is
proven to be sound by applying the weak duality theorem which is also
part of this formalization.</description>
    </item>
    <item>
       <title>Communicating Concurrent Kleene Algebra for Distributed Systems Specification</title>
              <link>https://www.isa-afp.org/entries/C2KA_DistributedSystems.html</link>
       <guid>https://www.isa-afp.org/entries/C2KA_DistributedSystems.html</guid>
       <dc:creator> Maxime Buyse, Jason Jaskolka       </dc:creator>
       <pubDate>06 Aug 2019 00:00:00 +0000</pubDate>
       <description>
Communicating Concurrent Kleene Algebra (C²KA) is a mathematical
framework for capturing the communicating and concurrent behaviour of
agents in distributed systems. It extends Hoare et al.&#39;s
Concurrent Kleene Algebra (CKA) with communication actions through the
notions of stimuli and shared environments. C²KA has applications in
studying system-level properties of distributed systems such as
safety, security, and reliability. In this work, we formalize results
about C²KA and its application for distributed systems specification.
We first formalize the stimulus structure and behaviour structure
(CKA). Next, we combine them to formalize C²KA and its properties.
Then, we formalize notions and properties related to the topology of
distributed systems and the potential for communication via stimuli
and via shared environments of agents, all within the algebraic
setting of C²KA.</description>
    </item>
    <item>
       <title>Selected Problems from the International Mathematical Olympiad 2019</title>
              <link>https://www.isa-afp.org/entries/IMO2019.html</link>
       <guid>https://www.isa-afp.org/entries/IMO2019.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>05 Aug 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains formalisations of the answers to three of
the six problem of the International Mathematical Olympiad 2019,
namely Q1, Q4, and Q5.&lt;/p&gt; &lt;p&gt;The reason why these
problems were chosen is that they are particularly amenable to
formalisation: they can be solved with minimal use of libraries. The
remaining three concern geometry and graph theory, which, in the
author&#39;s opinion, are more difficult to formalise resp. require a
more complex library.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Stellar Quorum Systems</title>
              <link>https://www.isa-afp.org/entries/Stellar_Quorums.html</link>
       <guid>https://www.isa-afp.org/entries/Stellar_Quorums.html</guid>
       <dc:creator> Giuliano Losa       </dc:creator>
       <pubDate>01 Aug 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the static properties of personal Byzantine quorum
systems (PBQSs) and Stellar quorum systems, as described in the paper
``Stellar Consensus by Reduction&#39;&#39; (to appear at DISC 2019).</description>
    </item>
    <item>
       <title>A Formal Development of a Polychronous Polytimed Coordination Language</title>
              <link>https://www.isa-afp.org/entries/TESL_Language.html</link>
       <guid>https://www.isa-afp.org/entries/TESL_Language.html</guid>
       <dc:creator> Hai Nguyen Van, Frédéric Boulanger, Burkhart Wolff       </dc:creator>
       <pubDate>30 Jul 2019 00:00:00 +0000</pubDate>
       <description>
The design of complex systems involves different formalisms for
modeling their different parts or aspects. The global model of a
system may therefore consist of a coordination of concurrent
sub-models that use different paradigms.  We develop here a theory for
a language used to specify the timed coordination of such
heterogeneous subsystems by addressing the following issues:
&lt;ul&gt;&lt;li&gt;the
behavior of the sub-systems is observed only at a series of discrete
instants,&lt;/li&gt;&lt;li&gt;events may occur in different sub-systems at unrelated
times, leading to polychronous systems, which do not necessarily have
a common base clock,&lt;/li&gt;&lt;li&gt;coordination between subsystems involves
causality, so the occurrence of an event may enforce the occurrence of
other events, possibly after a certain duration has elapsed or an
event has occurred a given number of times,&lt;/li&gt;&lt;li&gt;the domain of time
(discrete, rational, continuous...) may be different in the
subsystems, leading to polytimed systems,&lt;/li&gt;&lt;li&gt;the time frames of
different sub-systems may be related (for instance, time in a GPS
satellite and in a GPS receiver on Earth are related although they are
not the same).&lt;/li&gt;&lt;/ul&gt;
Firstly, a denotational semantics of the language is
defined. Then, in order to be able to incrementally check the behavior
of systems, an operational semantics is given, with proofs of
progress, soundness and completeness with regard to the denotational
semantics. These proofs are made according to a setup that can scale
up when new operators are added to the language. In order for
specifications to be composed in a clean way, the language should be
invariant by stuttering (i.e., adding observation instants at which
nothing happens). The proof of this invariance is also given.</description>
    </item>
    <item>
       <title>Szpilrajn Extension Theorem</title>
              <link>https://www.isa-afp.org/entries/Szpilrajn.html</link>
       <guid>https://www.isa-afp.org/entries/Szpilrajn.html</guid>
       <dc:creator> Peter Zeller       </dc:creator>
       <pubDate>27 Jul 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the Szpilrajn extension theorem, also known as
order-extension principal: Every strict partial order can be extended
to a strict linear order.</description>
    </item>
    <item>
       <title>A Sequent Calculus for First-Order Logic</title>
              <link>https://www.isa-afp.org/entries/FOL_Seq_Calc1.html</link>
       <guid>https://www.isa-afp.org/entries/FOL_Seq_Calc1.html</guid>
       <dc:creator> Andreas Halkjær From       </dc:creator>
       <pubDate>18 Jul 2019 00:00:00 +0000</pubDate>
       <description>
This work formalizes soundness and completeness of a one-sided sequent
calculus for first-order logic. The completeness is shown via a
translation from a complete semantic tableau calculus, the proof of
which is based on the First-Order Logic According to Fitting theory.
The calculi and proof techniques are taken from Ben-Ari&#39;s
Mathematical Logic for Computer Science.</description>
    </item>
    <item>
       <title>A Verified Code Generator from Isabelle/HOL to CakeML</title>
              <link>https://www.isa-afp.org/entries/CakeML_Codegen.html</link>
       <guid>https://www.isa-afp.org/entries/CakeML_Codegen.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>08 Jul 2019 00:00:00 +0000</pubDate>
       <description>
This entry contains the formalization that accompanies my PhD thesis
(see https://lars.hupel.info/research/codegen/). I develop a verified
compilation toolchain from executable specifications in Isabelle/HOL
to CakeML abstract syntax trees. This improves over the
state-of-the-art in Isabelle by providing a trustworthy procedure for
code generation.</description>
    </item>
    <item>
       <title>Formalization of a Monitoring Algorithm for Metric First-Order Temporal Logic</title>
              <link>https://www.isa-afp.org/entries/MFOTL_Monitor.html</link>
       <guid>https://www.isa-afp.org/entries/MFOTL_Monitor.html</guid>
       <dc:creator> Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>04 Jul 2019 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
temporal logic (MFOTL), an expressive extension of linear temporal
logic with real-time constraints and first-order quantification. The
verified monitor implements a simplified variant of the algorithm used
in the efficient MonPoly monitoring tool. The formalization is
presented in a forthcoming &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/rv19-verimon/verimon.pdf&#34;&gt;RV
2019 paper&lt;/a&gt;, which also compares the output of the verified
monitor to that of other monitoring tools on randomly generated
inputs. This case study revealed several errors in the optimized but
unverified tools.</description>
    </item>
    <item>
       <title>Complete Non-Orders and Fixed Points</title>
              <link>https://www.isa-afp.org/entries/Complete_Non_Orders.html</link>
       <guid>https://www.isa-afp.org/entries/Complete_Non_Orders.html</guid>
       <dc:creator> Akihisa Yamada, Jérémy Dubut       </dc:creator>
       <pubDate>27 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We develop an Isabelle/HOL library of order-theoretic concepts, such
as various completeness conditions and fixed-point theorems. We keep
our formalization as general as possible: we reprove several
well-known results about complete orders, often without any properties
of ordering, thus complete non-orders. In particular, we generalize
the Knaster–Tarski theorem so that we ensure the existence of a
quasi-fixed point of monotone maps over complete non-orders, and show
that the set of quasi-fixed points is complete under a mild
condition—attractivity—which is implied by either antisymmetry or
transitivity. This result generalizes and strengthens a result by
Stauti and Maaden. Finally, we recover Kleene’s fixed-point theorem
for omega-complete non-orders, again using attractivity to prove that
Kleene’s fixed points are least quasi-fixed points.</description>
    </item>
    <item>
       <title>Priority Search Trees</title>
              <link>https://www.isa-afp.org/entries/Priority_Search_Trees.html</link>
       <guid>https://www.isa-afp.org/entries/Priority_Search_Trees.html</guid>
       <dc:creator> Peter Lammich, Tobias Nipkow       </dc:creator>
       <pubDate>25 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We present a new, purely functional, simple and efficient data
structure combining a search tree and a priority queue, which we call
a &lt;em&gt;priority search tree&lt;/em&gt;. The salient feature of priority search
trees is that they offer a decrease-key operation, something that is
missing from other simple, purely functional priority queue
implementations. Priority search trees can be implemented on top of
any search tree. This entry does the implementation for red-black
trees.  This entry formalizes the first part of our ITP-2019 proof
pearl &lt;em&gt;Purely Functional, Simple and Efficient Priority
Search Trees and Applications to Prim and Dijkstra&lt;/em&gt;.</description>
    </item>
    <item>
       <title>Purely Functional, Simple, and Efficient Implementation of Prim and Dijkstra</title>
              <link>https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</link>
       <guid>https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</guid>
       <dc:creator> Peter Lammich, Tobias Nipkow       </dc:creator>
       <pubDate>25 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We verify purely functional, simple and efficient implementations of
Prim&#39;s and Dijkstra&#39;s algorithms. This constitutes the first
verification of an executable and even efficient version of
Prim&#39;s algorithm. This entry formalizes the second part of our
ITP-2019 proof pearl &lt;em&gt;Purely Functional, Simple and Efficient
Priority Search Trees and Applications to Prim and Dijkstra&lt;/em&gt;.</description>
    </item>
    <item>
       <title>Linear Inequalities</title>
              <link>https://www.isa-afp.org/entries/Linear_Inequalities.html</link>
       <guid>https://www.isa-afp.org/entries/Linear_Inequalities.html</guid>
       <dc:creator> Ralph Bottesch, Alban Reynaud, René Thiemann       </dc:creator>
       <pubDate>21 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We formalize results about linear inqualities, mainly from
Schrijver&#39;s book. The main results are the proof of the
fundamental theorem on linear inequalities, Farkas&#39; lemma,
Carathéodory&#39;s theorem, the Farkas-Minkowsky-Weyl theorem, the
decomposition theorem of polyhedra, and Meyer&#39;s result that the
integer hull of a polyhedron is a polyhedron itself. Several theorems
include bounds on the appearing numbers, and in particular we provide
an a-priori bound on mixed-integer solutions of linear inequalities.</description>
    </item>
    <item>
       <title>Hilbert's Nullstellensatz</title>
              <link>https://www.isa-afp.org/entries/Nullstellensatz.html</link>
       <guid>https://www.isa-afp.org/entries/Nullstellensatz.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>16 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes Hilbert&#39;s Nullstellensatz, an important
theorem in algebraic geometry that can be viewed as the generalization
of the Fundamental Theorem of Algebra to multivariate polynomials: If
a set of (multivariate) polynomials over an algebraically closed field
has no common zero, then the ideal it generates is the entire
polynomial ring. The formalization proves several equivalent versions
of this celebrated theorem: the weak Nullstellensatz, the strong
Nullstellensatz (connecting algebraic varieties and radical ideals),
and the field-theoretic Nullstellensatz. The formalization follows
Chapter 4.1. of &lt;a
href=&#34;https://link.springer.com/book/10.1007/978-0-387-35651-8&#34;&gt;Ideals,
Varieties, and Algorithms&lt;/a&gt; by Cox, Little and O&#39;Shea.</description>
    </item>
    <item>
       <title>Gröbner Bases, Macaulay Matrices and Dubé's Degree Bounds</title>
              <link>https://www.isa-afp.org/entries/Groebner_Macaulay.html</link>
       <guid>https://www.isa-afp.org/entries/Groebner_Macaulay.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>15 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the connection between Gröbner bases and
Macaulay matrices (sometimes also referred to as `generalized
Sylvester matrices&#39;). In particular, it contains a method for
computing Gröbner bases, which proceeds by first constructing some
Macaulay matrix of the initial set of polynomials, then row-reducing
this matrix, and finally converting the result back into a set of
polynomials. The output is shown to be a Gröbner basis if the Macaulay
matrix constructed in the first step is sufficiently large. In order
to obtain concrete upper bounds on the size of the matrix (and hence
turn the method into an effectively executable algorithm), Dubé&#39;s
degree bounds on Gröbner bases are utilized; consequently, they are
also part of the formalization.</description>
    </item>
    <item>
       <title>Binary Heaps for IMP2</title>
              <link>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</link>
       <guid>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</guid>
       <dc:creator> Simon Griebel       </dc:creator>
       <pubDate>13 Jun 2019 00:00:00 +0000</pubDate>
       <description>
In this submission array-based binary minimum heaps are formalized.
The correctness of the following heap operations is proved: insert,
get-min, delete-min and make-heap. These are then used to verify an
in-place heapsort. The formalization is based on IMP2, an imperative
program verification framework implemented in Isabelle/HOL. The
verified heap functions are iterative versions of the partly recursive
functions found in &#34;Algorithms and Data Structures – The Basic
Toolbox&#34; by K. Mehlhorn and P. Sanders and &#34;Introduction to
Algorithms&#34; by T. H. Cormen, C. E. Leiserson, R. L. Rivest and C.
Stein.</description>
    </item>
    <item>
       <title>Differential Game Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Game_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Differential_Game_Logic.html</guid>
       <dc:creator> André Platzer       </dc:creator>
       <pubDate>03 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This formalization provides differential game logic (dGL), a logic for
proving properties of hybrid game. In addition to the syntax and
semantics, it formalizes a uniform substitution calculus for dGL.
Church&#39;s uniform substitutions substitute a term or formula for a
function or predicate symbol everywhere. The uniform substitutions for
dGL also substitute hybrid games for a game symbol everywhere. We
prove soundness of one-pass uniform substitutions and the axioms of
differential game logic with respect to their denotational semantics.
One-pass uniform substitutions are faster by postponing
soundness-critical admissibility checks with a linear pass homomorphic
application and regain soundness by a variable condition at the
replacements.  The formalization is based on prior non-mechanized
soundness proofs for dGL.</description>
    </item>
  </channel>
</rss>
