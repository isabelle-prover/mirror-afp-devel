<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>16 Sep 2019 00:00:00 +0000</pubDate>
    <item>
       <title>Formalization of Multiway-Join Algorithms</title>
              <link>https://www.isa-afp.org/entries/Generic_Join.html</link>
       <guid>https://www.isa-afp.org/entries/Generic_Join.html</guid>
       <dc:creator> Thibault Dardinier       </dc:creator>
       <pubDate>16 Sep 2019 00:00:00 +0000</pubDate>
       <description>
Worst-case optimal multiway-join algorithms are recent seminal
achievement of the database community. These algorithms compute the
natural join of multiple relational databases and improve in the worst
case over traditional query plan optimizations of nested binary joins.
In 2014, &lt;a
href=&#34;https://doi.org/10.1145/2590989.2590991&#34;&gt;Ngo, Ré,
and Rudra&lt;/a&gt; gave a unified presentation of different multi-way
join algorithms. We formalized and proved correct their &#34;Generic
Join&#34; algorithm and extended it to support negative joins.</description>
    </item>
    <item>
       <title>Verification Components for Hybrid Systems</title>
              <link>https://www.isa-afp.org/entries/Hybrid_Systems_VCs.html</link>
       <guid>https://www.isa-afp.org/entries/Hybrid_Systems_VCs.html</guid>
       <dc:creator> Jonathan Julian Huerta y Munive       </dc:creator>
       <pubDate>10 Sep 2019 00:00:00 +0000</pubDate>
       <description>
These components formalise a semantic framework for the deductive
verification of hybrid systems. They support reasoning about
continuous evolutions of hybrid programs in the style of differential
dynamics logic. Vector fields or flows model these evolutions, and
their verification is done with invariants for the former or orbits
for the latter. Laws of modal Kleene algebra or categorical predicate
transformers implement the verification condition generation. Examples
show the approach at work.</description>
    </item>
    <item>
       <title>Fourier Series</title>
              <link>https://www.isa-afp.org/entries/Fourier.html</link>
       <guid>https://www.isa-afp.org/entries/Fourier.html</guid>
       <dc:creator> Lawrence C Paulson       </dc:creator>
       <pubDate>06 Sep 2019 00:00:00 +0000</pubDate>
       <description>
This development formalises the square integrable functions over the
reals and the basics of Fourier series. It culminates with a proof
that every well-behaved periodic function can be approximated by a
Fourier series. The material is ported from HOL Light:
https://github.com/jrh13/hol-light/blob/master/100/fourier.ml</description>
    </item>
    <item>
       <title>A Case Study in Basic Algebra</title>
              <link>https://www.isa-afp.org/entries/Jacobson_Basic_Algebra.html</link>
       <guid>https://www.isa-afp.org/entries/Jacobson_Basic_Algebra.html</guid>
       <dc:creator> Clemens Ballarin       </dc:creator>
       <pubDate>30 Aug 2019 00:00:00 +0000</pubDate>
       <description>
The focus of this case study is re-use in abstract algebra.  It
contains locale-based formalisations of selected parts of set, group
and ring theory from Jacobson&#39;s &lt;i&gt;Basic Algebra&lt;/i&gt;
leading to the respective fundamental homomorphism theorems.  The
study is not intended as a library base for abstract algebra.  It
rather explores an approach towards abstract algebra in Isabelle.</description>
    </item>
    <item>
       <title>Formalisation of an Adaptive State Counting Algorithm</title>
              <link>https://www.isa-afp.org/entries/Adaptive_State_Counting.html</link>
       <guid>https://www.isa-afp.org/entries/Adaptive_State_Counting.html</guid>
       <dc:creator> Robert Sachtleben       </dc:creator>
       <pubDate>16 Aug 2019 00:00:00 +0000</pubDate>
       <description>
This entry provides a formalisation of a refinement of an adaptive
state counting algorithm, used to test for reduction between finite
state machines. The algorithm has been originally presented by Hierons
in the paper &lt;a
href=&#34;https://doi.org/10.1109/TC.2004.85&#34;&gt;Testing from a
Non-Deterministic Finite State Machine Using Adaptive State
Counting&lt;/a&gt;.  Definitions for finite state machines and
adaptive test cases are given and many useful theorems are derived
from these. The algorithm is formalised using mutually recursive
functions, for which it is proven that the generated test suite is
sufficient to test for reduction against finite state machines of a
certain fault domain. Additionally, the algorithm is specified in a
simple WHILE-language and its correctness is shown using Hoare-logic.</description>
    </item>
    <item>
       <title>Laplace Transform</title>
              <link>https://www.isa-afp.org/entries/Laplace_Transform.html</link>
       <guid>https://www.isa-afp.org/entries/Laplace_Transform.html</guid>
       <dc:creator> Fabian Immler       </dc:creator>
       <pubDate>14 Aug 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the Laplace transform and concrete Laplace
transforms for arithmetic functions, frequency shift, integration and
(higher) differentiation in the time domain. It proves Lerch&#39;s
lemma and uniqueness of the Laplace transform for continuous
functions. In order to formalize the foundational assumptions, this
entry contains a formalization of piecewise continuous functions and
functions of exponential order.</description>
    </item>
    <item>
       <title>Linear Programming</title>
              <link>https://www.isa-afp.org/entries/Linear_Programming.html</link>
       <guid>https://www.isa-afp.org/entries/Linear_Programming.html</guid>
       <dc:creator> Julian Parsert, Cezary Kaliszyk       </dc:creator>
       <pubDate>06 Aug 2019 00:00:00 +0000</pubDate>
       <description>
We use the previous formalization of the general simplex algorithm to
formulate an algorithm for solving linear programs. We encode the
linear programs using only linear constraints. Solving these
constraints also solves the original linear program. This algorithm is
proven to be sound by applying the weak duality theorem which is also
part of this formalization.</description>
    </item>
    <item>
       <title>Communicating Concurrent Kleene Algebra for Distributed Systems Specification</title>
              <link>https://www.isa-afp.org/entries/C2KA_DistributedSystems.html</link>
       <guid>https://www.isa-afp.org/entries/C2KA_DistributedSystems.html</guid>
       <dc:creator> Maxime Buyse, Jason Jaskolka       </dc:creator>
       <pubDate>06 Aug 2019 00:00:00 +0000</pubDate>
       <description>
Communicating Concurrent Kleene Algebra (C²KA) is a mathematical
framework for capturing the communicating and concurrent behaviour of
agents in distributed systems. It extends Hoare et al.&#39;s
Concurrent Kleene Algebra (CKA) with communication actions through the
notions of stimuli and shared environments. C²KA has applications in
studying system-level properties of distributed systems such as
safety, security, and reliability. In this work, we formalize results
about C²KA and its application for distributed systems specification.
We first formalize the stimulus structure and behaviour structure
(CKA). Next, we combine them to formalize C²KA and its properties.
Then, we formalize notions and properties related to the topology of
distributed systems and the potential for communication via stimuli
and via shared environments of agents, all within the algebraic
setting of C²KA.</description>
    </item>
    <item>
       <title>Selected Problems from the International Mathematical Olympiad 2019</title>
              <link>https://www.isa-afp.org/entries/IMO2019.html</link>
       <guid>https://www.isa-afp.org/entries/IMO2019.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>05 Aug 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains formalisations of the answers to three of
the six problem of the International Mathematical Olympiad 2019,
namely Q1, Q4, and Q5.&lt;/p&gt; &lt;p&gt;The reason why these
problems were chosen is that they are particularly amenable to
formalisation: they can be solved with minimal use of libraries. The
remaining three concern geometry and graph theory, which, in the
author&#39;s opinion, are more difficult to formalise resp. require a
more complex library.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Stellar Quorum Systems</title>
              <link>https://www.isa-afp.org/entries/Stellar_Quorums.html</link>
       <guid>https://www.isa-afp.org/entries/Stellar_Quorums.html</guid>
       <dc:creator> Giuliano Losa       </dc:creator>
       <pubDate>01 Aug 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the static properties of personal Byzantine quorum
systems (PBQSs) and Stellar quorum systems, as described in the paper
``Stellar Consensus by Reduction&#39;&#39; (to appear at DISC 2019).</description>
    </item>
    <item>
       <title>A Formal Development of a Polychronous Polytimed Coordination Language</title>
              <link>https://www.isa-afp.org/entries/TESL_Language.html</link>
       <guid>https://www.isa-afp.org/entries/TESL_Language.html</guid>
       <dc:creator> Hai Nguyen Van, Frédéric Boulanger, Burkhart Wolff       </dc:creator>
       <pubDate>30 Jul 2019 00:00:00 +0000</pubDate>
       <description>
The design of complex systems involves different formalisms for
modeling their different parts or aspects. The global model of a
system may therefore consist of a coordination of concurrent
sub-models that use different paradigms.  We develop here a theory for
a language used to specify the timed coordination of such
heterogeneous subsystems by addressing the following issues:
&lt;ul&gt;&lt;li&gt;the
behavior of the sub-systems is observed only at a series of discrete
instants,&lt;/li&gt;&lt;li&gt;events may occur in different sub-systems at unrelated
times, leading to polychronous systems, which do not necessarily have
a common base clock,&lt;/li&gt;&lt;li&gt;coordination between subsystems involves
causality, so the occurrence of an event may enforce the occurrence of
other events, possibly after a certain duration has elapsed or an
event has occurred a given number of times,&lt;/li&gt;&lt;li&gt;the domain of time
(discrete, rational, continuous...) may be different in the
subsystems, leading to polytimed systems,&lt;/li&gt;&lt;li&gt;the time frames of
different sub-systems may be related (for instance, time in a GPS
satellite and in a GPS receiver on Earth are related although they are
not the same).&lt;/li&gt;&lt;/ul&gt;
Firstly, a denotational semantics of the language is
defined. Then, in order to be able to incrementally check the behavior
of systems, an operational semantics is given, with proofs of
progress, soundness and completeness with regard to the denotational
semantics. These proofs are made according to a setup that can scale
up when new operators are added to the language. In order for
specifications to be composed in a clean way, the language should be
invariant by stuttering (i.e., adding observation instants at which
nothing happens). The proof of this invariance is also given.</description>
    </item>
    <item>
       <title>Szpilrajn Extension Theorem</title>
              <link>https://www.isa-afp.org/entries/Szpilrajn.html</link>
       <guid>https://www.isa-afp.org/entries/Szpilrajn.html</guid>
       <dc:creator> Peter Zeller       </dc:creator>
       <pubDate>27 Jul 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the Szpilrajn extension theorem, also known as
order-extension principal: Every strict partial order can be extended
to a strict linear order.</description>
    </item>
    <item>
       <title>A Sequent Calculus for First-Order Logic</title>
              <link>https://www.isa-afp.org/entries/FOL_Seq_Calc1.html</link>
       <guid>https://www.isa-afp.org/entries/FOL_Seq_Calc1.html</guid>
       <dc:creator> Andreas Halkjær From       </dc:creator>
       <pubDate>18 Jul 2019 00:00:00 +0000</pubDate>
       <description>
This work formalizes soundness and completeness of a one-sided sequent
calculus for first-order logic. The completeness is shown via a
translation from a complete semantic tableau calculus, the proof of
which is based on the First-Order Logic According to Fitting theory.
The calculi and proof techniques are taken from Ben-Ari&#39;s
Mathematical Logic for Computer Science.</description>
    </item>
    <item>
       <title>A Verified Code Generator from Isabelle/HOL to CakeML</title>
              <link>https://www.isa-afp.org/entries/CakeML_Codegen.html</link>
       <guid>https://www.isa-afp.org/entries/CakeML_Codegen.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>08 Jul 2019 00:00:00 +0000</pubDate>
       <description>
This entry contains the formalization that accompanies my PhD thesis
(see https://lars.hupel.info/research/codegen/). I develop a verified
compilation toolchain from executable specifications in Isabelle/HOL
to CakeML abstract syntax trees. This improves over the
state-of-the-art in Isabelle by providing a trustworthy procedure for
code generation.</description>
    </item>
    <item>
       <title>Formalization of a Monitoring Algorithm for Metric First-Order Temporal Logic</title>
              <link>https://www.isa-afp.org/entries/MFOTL_Monitor.html</link>
       <guid>https://www.isa-afp.org/entries/MFOTL_Monitor.html</guid>
       <dc:creator> Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>04 Jul 2019 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
temporal logic (MFOTL), an expressive extension of linear temporal
logic with real-time constraints and first-order quantification. The
verified monitor implements a simplified variant of the algorithm used
in the efficient MonPoly monitoring tool. The formalization is
presented in a forthcoming &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/rv19-verimon/verimon.pdf&#34;&gt;RV
2019 paper&lt;/a&gt;, which also compares the output of the verified
monitor to that of other monitoring tools on randomly generated
inputs. This case study revealed several errors in the optimized but
unverified tools.</description>
    </item>
    <item>
       <title>Complete Non-Orders and Fixed Points</title>
              <link>https://www.isa-afp.org/entries/Complete_Non_Orders.html</link>
       <guid>https://www.isa-afp.org/entries/Complete_Non_Orders.html</guid>
       <dc:creator> Akihisa Yamada, Jérémy Dubut       </dc:creator>
       <pubDate>27 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We develop an Isabelle/HOL library of order-theoretic concepts, such
as various completeness conditions and fixed-point theorems. We keep
our formalization as general as possible: we reprove several
well-known results about complete orders, often without any properties
of ordering, thus complete non-orders. In particular, we generalize
the Knaster–Tarski theorem so that we ensure the existence of a
quasi-fixed point of monotone maps over complete non-orders, and show
that the set of quasi-fixed points is complete under a mild
condition—attractivity—which is implied by either antisymmetry or
transitivity. This result generalizes and strengthens a result by
Stauti and Maaden. Finally, we recover Kleene’s fixed-point theorem
for omega-complete non-orders, again using attractivity to prove that
Kleene’s fixed points are least quasi-fixed points.</description>
    </item>
    <item>
       <title>Priority Search Trees</title>
              <link>https://www.isa-afp.org/entries/Priority_Search_Trees.html</link>
       <guid>https://www.isa-afp.org/entries/Priority_Search_Trees.html</guid>
       <dc:creator> Peter Lammich, Tobias Nipkow       </dc:creator>
       <pubDate>25 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We present a new, purely functional, simple and efficient data
structure combining a search tree and a priority queue, which we call
a &lt;em&gt;priority search tree&lt;/em&gt;. The salient feature of priority search
trees is that they offer a decrease-key operation, something that is
missing from other simple, purely functional priority queue
implementations. Priority search trees can be implemented on top of
any search tree. This entry does the implementation for red-black
trees.  This entry formalizes the first part of our ITP-2019 proof
pearl &lt;em&gt;Purely Functional, Simple and Efficient Priority
Search Trees and Applications to Prim and Dijkstra&lt;/em&gt;.</description>
    </item>
    <item>
       <title>Purely Functional, Simple, and Efficient Implementation of Prim and Dijkstra</title>
              <link>https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</link>
       <guid>https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</guid>
       <dc:creator> Peter Lammich, Tobias Nipkow       </dc:creator>
       <pubDate>25 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We verify purely functional, simple and efficient implementations of
Prim&#39;s and Dijkstra&#39;s algorithms. This constitutes the first
verification of an executable and even efficient version of
Prim&#39;s algorithm. This entry formalizes the second part of our
ITP-2019 proof pearl &lt;em&gt;Purely Functional, Simple and Efficient
Priority Search Trees and Applications to Prim and Dijkstra&lt;/em&gt;.</description>
    </item>
    <item>
       <title>Linear Inequalities</title>
              <link>https://www.isa-afp.org/entries/Linear_Inequalities.html</link>
       <guid>https://www.isa-afp.org/entries/Linear_Inequalities.html</guid>
       <dc:creator> Ralph Bottesch, Alban Reynaud, René Thiemann       </dc:creator>
       <pubDate>21 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We formalize results about linear inqualities, mainly from
Schrijver&#39;s book. The main results are the proof of the
fundamental theorem on linear inequalities, Farkas&#39; lemma,
Carathéodory&#39;s theorem, the Farkas-Minkowsky-Weyl theorem, the
decomposition theorem of polyhedra, and Meyer&#39;s result that the
integer hull of a polyhedron is a polyhedron itself. Several theorems
include bounds on the appearing numbers, and in particular we provide
an a-priori bound on mixed-integer solutions of linear inequalities.</description>
    </item>
    <item>
       <title>Hilbert's Nullstellensatz</title>
              <link>https://www.isa-afp.org/entries/Nullstellensatz.html</link>
       <guid>https://www.isa-afp.org/entries/Nullstellensatz.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>16 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes Hilbert&#39;s Nullstellensatz, an important
theorem in algebraic geometry that can be viewed as the generalization
of the Fundamental Theorem of Algebra to multivariate polynomials: If
a set of (multivariate) polynomials over an algebraically closed field
has no common zero, then the ideal it generates is the entire
polynomial ring. The formalization proves several equivalent versions
of this celebrated theorem: the weak Nullstellensatz, the strong
Nullstellensatz (connecting algebraic varieties and radical ideals),
and the field-theoretic Nullstellensatz. The formalization follows
Chapter 4.1. of &lt;a
href=&#34;https://link.springer.com/book/10.1007/978-0-387-35651-8&#34;&gt;Ideals,
Varieties, and Algorithms&lt;/a&gt; by Cox, Little and O&#39;Shea.</description>
    </item>
    <item>
       <title>Gröbner Bases, Macaulay Matrices and Dubé's Degree Bounds</title>
              <link>https://www.isa-afp.org/entries/Groebner_Macaulay.html</link>
       <guid>https://www.isa-afp.org/entries/Groebner_Macaulay.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>15 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the connection between Gröbner bases and
Macaulay matrices (sometimes also referred to as `generalized
Sylvester matrices&#39;). In particular, it contains a method for
computing Gröbner bases, which proceeds by first constructing some
Macaulay matrix of the initial set of polynomials, then row-reducing
this matrix, and finally converting the result back into a set of
polynomials. The output is shown to be a Gröbner basis if the Macaulay
matrix constructed in the first step is sufficiently large. In order
to obtain concrete upper bounds on the size of the matrix (and hence
turn the method into an effectively executable algorithm), Dubé&#39;s
degree bounds on Gröbner bases are utilized; consequently, they are
also part of the formalization.</description>
    </item>
    <item>
       <title>Binary Heaps for IMP2</title>
              <link>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</link>
       <guid>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</guid>
       <dc:creator> Simon Griebel       </dc:creator>
       <pubDate>13 Jun 2019 00:00:00 +0000</pubDate>
       <description>
In this submission array-based binary minimum heaps are formalized.
The correctness of the following heap operations is proved: insert,
get-min, delete-min and make-heap. These are then used to verify an
in-place heapsort. The formalization is based on IMP2, an imperative
program verification framework implemented in Isabelle/HOL. The
verified heap functions are iterative versions of the partly recursive
functions found in &#34;Algorithms and Data Structures – The Basic
Toolbox&#34; by K. Mehlhorn and P. Sanders and &#34;Introduction to
Algorithms&#34; by T. H. Cormen, C. E. Leiserson, R. L. Rivest and C.
Stein.</description>
    </item>
    <item>
       <title>Differential Game Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Game_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Differential_Game_Logic.html</guid>
       <dc:creator> André Platzer       </dc:creator>
       <pubDate>03 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This formalization provides differential game logic (dGL), a logic for
proving properties of hybrid game. In addition to the syntax and
semantics, it formalizes a uniform substitution calculus for dGL.
Church&#39;s uniform substitutions substitute a term or formula for a
function or predicate symbol everywhere. The uniform substitutions for
dGL also substitute hybrid games for a game symbol everywhere. We
prove soundness of one-pass uniform substitutions and the axioms of
differential game logic with respect to their denotational semantics.
One-pass uniform substitutions are faster by postponing
soundness-critical admissibility checks with a linear pass homomorphic
application and regain soundness by a variable condition at the
replacements.  The formalization is based on prior non-mechanized
soundness proofs for dGL.</description>
    </item>
    <item>
       <title>Multidimensional Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/KD_Tree.html</link>
       <guid>https://www.isa-afp.org/entries/KD_Tree.html</guid>
       <dc:creator> Martin Rau       </dc:creator>
       <pubDate>30 May 2019 00:00:00 +0000</pubDate>
       <description>
This entry provides a formalization of multidimensional binary trees,
also known as k-d trees. It includes a balanced build algorithm as
well as the nearest neighbor algorithm and the range search algorithm.
It is based on the papers &lt;a
href=&#34;https://dl.acm.org/citation.cfm?doid=361002.361007&#34;&gt;Multidimensional
binary search trees used for associative searching&lt;/a&gt; and &lt;a
href=&#34;https://dl.acm.org/citation.cfm?doid=355744.355745&#34;&gt;
An Algorithm for Finding Best Matches in Logarithmic Expected
Time&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Formalization of Generic Authenticated Data Structures</title>
              <link>https://www.isa-afp.org/entries/LambdaAuth.html</link>
       <guid>https://www.isa-afp.org/entries/LambdaAuth.html</guid>
       <dc:creator> Matthias Brun, Dmitriy Traytel       </dc:creator>
       <pubDate>14 May 2019 00:00:00 +0000</pubDate>
       <description>
Authenticated data structures are a technique for outsourcing data
storage and maintenance to an untrusted server. The server is required
to produce an efficiently checkable and cryptographically secure proof
that it carried out precisely the requested computation. &lt;a
href=&#34;https://doi.org/10.1145/2535838.2535851&#34;&gt;Miller et
al.&lt;/a&gt; introduced &amp;lambda;&amp;bull; (pronounced
&lt;i&gt;lambda auth&lt;/i&gt;)&amp;mdash;a functional programming
language with a built-in primitive authentication construct, which
supports a wide range of user-specified authenticated data structures
while guaranteeing certain correctness and security properties for all
well-typed programs. We formalize &amp;lambda;&amp;bull; and prove its
correctness and security properties. With Isabelle&#39;s help, we
uncover and repair several mistakes in the informal proofs and lemma
statements. Our findings are summarized in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/lambdaauth/lambdaauth.pdf&#34;&gt;paper
draft&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Multi-Party Computation</title>
              <link>https://www.isa-afp.org/entries/Multi_Party_Computation.html</link>
       <guid>https://www.isa-afp.org/entries/Multi_Party_Computation.html</guid>
       <dc:creator> David Aspinall, David Butler       </dc:creator>
       <pubDate>09 May 2019 00:00:00 +0000</pubDate>
       <description>
We use CryptHOL to consider Multi-Party Computation (MPC) protocols.
MPC was first considered by Yao in 1983 and recent advances in
efficiency and an increased demand mean it is now deployed in the real
world. Security is considered using the real/ideal world paradigm. We
first define security in the semi-honest security setting where
parties are assumed not to deviate from the protocol transcript. In
this setting we prove multiple Oblivious Transfer (OT) protocols
secure and then show security for the gates of the GMW protocol. We
then define malicious security, this is a stronger notion of security
where parties are assumed to be fully corrupted by an adversary. In
this setting we again consider OT, as it is a fundamental building
block of almost all MPC protocols.</description>
    </item>
    <item>
       <title>HOL-CSP Version 2.0</title>
              <link>https://www.isa-afp.org/entries/HOL-CSP.html</link>
       <guid>https://www.isa-afp.org/entries/HOL-CSP.html</guid>
       <dc:creator> Safouan Taha, Lina Ye, Burkhart Wolff       </dc:creator>
       <pubDate>26 Apr 2019 00:00:00 +0000</pubDate>
       <description>
This is a complete formalization of the work of Hoare and Roscoe on
the denotational semantics of the Failure/Divergence Model of CSP. It
follows essentially the presentation of CSP in Roscoe’s Book ”Theory
and Practice of Concurrency” [8] and the semantic details in a joint
Paper of Roscoe and Brooks ”An improved failures model for
communicating processes&#34;.  The present work is based on a prior
formalization attempt, called HOL-CSP 1.0, done in 1997 by H. Tej and
B. Wolff with the Isabelle proof technology available at that time.
This work revealed minor, but omnipresent foundational errors in key
concepts like the process invariant. The present version HOL-CSP
profits from substantially improved libraries (notably HOLCF),
improved automated proof techniques, and structured proof techniques
in Isar and is substantially shorter but more complete.</description>
    </item>
    <item>
       <title>A Compositional and Unified Translation of LTL into ω-Automata</title>
              <link>https://www.isa-afp.org/entries/LTL_Master_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/LTL_Master_Theorem.html</guid>
       <dc:creator> Benedikt Seidl, Salomon Sickert       </dc:creator>
       <pubDate>16 Apr 2019 00:00:00 +0000</pubDate>
       <description>
We present a formalisation of the unified translation approach of
linear temporal logic (LTL) into ω-automata from [1]. This approach
decomposes LTL formulas into ``simple&#39;&#39; languages and allows
a clear separation of concerns: first, we formalise the purely logical
result yielding this decomposition; second, we instantiate this
generic theory to obtain a construction for deterministic
(state-based) Rabin automata (DRA). We extract from this particular
instantiation an executable tool translating LTL to DRAs. To the best
of our knowledge this is the first verified translation from LTL to
DRAs that is proven to be double exponential in the worst case which
asymptotically matches the known lower bound.
&lt;p&gt;
[1] Javier Esparza, Jan Kretínský, Salomon Sickert. One Theorem to Rule Them All:
A Unified Translation of LTL into ω-Automata. LICS 2018</description>
    </item>
    <item>
       <title>A General Theory of Syntax with Bindings</title>
              <link>https://www.isa-afp.org/entries/Binding_Syntax_Theory.html</link>
       <guid>https://www.isa-afp.org/entries/Binding_Syntax_Theory.html</guid>
       <dc:creator> Lorenzo Gheri, Andrei Popescu       </dc:creator>
       <pubDate>06 Apr 2019 00:00:00 +0000</pubDate>
       <description>
We formalize a theory of syntax with bindings that has been developed
and refined over the last decade to support several large
formalization efforts. Terms are defined for an arbitrary number of
constructors of varying numbers of inputs, quotiented to
alpha-equivalence and sorted according to a binding signature. The
theory includes many properties of the standard operators on terms:
substitution, swapping and freshness. It also includes bindings-aware
induction and recursion principles and support for semantic
interpretation. This work has been presented in the ITP 2017 paper “A
Formalized General Theory of Syntax with Bindings”.</description>
    </item>
    <item>
       <title>The Transcendence of Certain Infinite Series</title>
              <link>https://www.isa-afp.org/entries/Transcendence_Series_Hancl_Rucki.html</link>
       <guid>https://www.isa-afp.org/entries/Transcendence_Series_Hancl_Rucki.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki, Wenda Li       </dc:creator>
       <pubDate>27 Mar 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the proofs of two transcendence criteria by J. Hančl
and P. Rucki that assert the transcendence of the sums of certain
infinite series built up by sequences that fulfil certain properties.
Both proofs make use of Roth&#39;s celebrated theorem on diophantine
approximations to algebraic numbers from 1955  which we implement as
an assumption without having formalised its proof.</description>
    </item>
  </channel>
</rss>
