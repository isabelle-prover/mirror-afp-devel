<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>06 Aug 2019 00:00:00 +0000</pubDate>
    <item>
       <title>Communicating Concurrent Kleene Algebra for Distributed Systems Specification</title>
              <link>https://www.isa-afp.org/entries/C2KA_DistributedSystems.html</link>
       <guid>https://www.isa-afp.org/entries/C2KA_DistributedSystems.html</guid>
       <dc:creator> Maxime Buyse, Jason Jaskolka       </dc:creator>
       <pubDate>06 Aug 2019 00:00:00 +0000</pubDate>
       <description>
Communicating Concurrent Kleene Algebra (C²KA) is a mathematical
framework for capturing the communicating and concurrent behaviour of
agents in distributed systems. It extends Hoare et al.&#39;s
Concurrent Kleene Algebra (CKA) with communication actions through the
notions of stimuli and shared environments. C²KA has applications in
studying system-level properties of distributed systems such as
safety, security, and reliability. In this work, we formalize results
about C²KA and its application for distributed systems specification.
We first formalize the stimulus structure and behaviour structure
(CKA). Next, we combine them to formalize C²KA and its properties.
Then, we formalize notions and properties related to the topology of
distributed systems and the potential for communication via stimuli
and via shared environments of agents, all within the algebraic
setting of C²KA.</description>
    </item>
    <item>
       <title>Selected Problems from the International Mathematical Olympiad 2019</title>
              <link>https://www.isa-afp.org/entries/IMO2019.html</link>
       <guid>https://www.isa-afp.org/entries/IMO2019.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>05 Aug 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains formalisations of the answers to three of
the six problem of the International Mathematical Olympiad 2019,
namely Q1, Q4, and Q5.&lt;/p&gt; &lt;p&gt;The reason why these
problems were chosen is that they are particularly amenable to
formalisation: they can be solved with minimal use of libraries. The
remaining three concern geometry and graph theory, which, in the
author&#39;s opinion, are more difficult to formalise resp. require a
more complex library.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Stellar Quorum Systems</title>
              <link>https://www.isa-afp.org/entries/Stellar_Quorums.html</link>
       <guid>https://www.isa-afp.org/entries/Stellar_Quorums.html</guid>
       <dc:creator> Giuliano Losa       </dc:creator>
       <pubDate>01 Aug 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the static properties of personal Byzantine quorum
systems (PBQSs) and Stellar quorum systems, as described in the paper
``Stellar Consensus by Reduction&#39;&#39; (to appear at DISC 2019).</description>
    </item>
    <item>
       <title>A Formal Development of a Polychronous Polytimed Coordination Language</title>
              <link>https://www.isa-afp.org/entries/TESL_Language.html</link>
       <guid>https://www.isa-afp.org/entries/TESL_Language.html</guid>
       <dc:creator> Hai Nguyen Van, Frédéric Boulanger, Burkhart Wolff       </dc:creator>
       <pubDate>30 Jul 2019 00:00:00 +0000</pubDate>
       <description>
The design of complex systems involves different formalisms for
modeling their different parts or aspects. The global model of a
system may therefore consist of a coordination of concurrent
sub-models that use different paradigms.  We develop here a theory for
a language used to specify the timed coordination of such
heterogeneous subsystems by addressing the following issues:
&lt;ul&gt;&lt;li&gt;the
behavior of the sub-systems is observed only at a series of discrete
instants,&lt;/li&gt;&lt;li&gt;events may occur in different sub-systems at unrelated
times, leading to polychronous systems, which do not necessarily have
a common base clock,&lt;/li&gt;&lt;li&gt;coordination between subsystems involves
causality, so the occurrence of an event may enforce the occurrence of
other events, possibly after a certain duration has elapsed or an
event has occurred a given number of times,&lt;/li&gt;&lt;li&gt;the domain of time
(discrete, rational, continuous...) may be different in the
subsystems, leading to polytimed systems,&lt;/li&gt;&lt;li&gt;the time frames of
different sub-systems may be related (for instance, time in a GPS
satellite and in a GPS receiver on Earth are related although they are
not the same).&lt;/li&gt;&lt;/ul&gt;
Firstly, a denotational semantics of the language is
defined. Then, in order to be able to incrementally check the behavior
of systems, an operational semantics is given, with proofs of
progress, soundness and completeness with regard to the denotational
semantics. These proofs are made according to a setup that can scale
up when new operators are added to the language. In order for
specifications to be composed in a clean way, the language should be
invariant by stuttering (i.e., adding observation instants at which
nothing happens). The proof of this invariance is also given.</description>
    </item>
    <item>
       <title>Szpilrajn Extension Theorem</title>
              <link>https://www.isa-afp.org/entries/Szpilrajn.html</link>
       <guid>https://www.isa-afp.org/entries/Szpilrajn.html</guid>
       <dc:creator> Peter Zeller       </dc:creator>
       <pubDate>27 Jul 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the Szpilrajn extension theorem, also known as
order-extension principal: Every strict partial order can be extended
to a strict linear order.</description>
    </item>
    <item>
       <title>A Sequent Calculus for First-Order Logic</title>
              <link>https://www.isa-afp.org/entries/FOL_Seq_Calc1.html</link>
       <guid>https://www.isa-afp.org/entries/FOL_Seq_Calc1.html</guid>
       <dc:creator> Andreas Halkjær From       </dc:creator>
       <pubDate>18 Jul 2019 00:00:00 +0000</pubDate>
       <description>
This work formalizes soundness and completeness of a one-sided sequent
calculus for first-order logic. The completeness is shown via a
translation from a complete semantic tableau calculus, the proof of
which is based on the First-Order Logic According to Fitting theory.
The calculi and proof techniques are taken from Ben-Ari&#39;s
Mathematical Logic for Computer Science.</description>
    </item>
    <item>
       <title>A Verified Code Generator from Isabelle/HOL to CakeML</title>
              <link>https://www.isa-afp.org/entries/CakeML_Codegen.html</link>
       <guid>https://www.isa-afp.org/entries/CakeML_Codegen.html</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>08 Jul 2019 00:00:00 +0000</pubDate>
       <description>
This entry contains the formalization that accompanies my PhD thesis
(see https://lars.hupel.info/research/codegen/). I develop a verified
compilation toolchain from executable specifications in Isabelle/HOL
to CakeML abstract syntax trees. This improves over the
state-of-the-art in Isabelle by providing a trustworthy procedure for
code generation.</description>
    </item>
    <item>
       <title>Formalization of a Monitoring Algorithm for Metric First-Order Temporal Logic</title>
              <link>https://www.isa-afp.org/entries/MFOTL_Monitor.html</link>
       <guid>https://www.isa-afp.org/entries/MFOTL_Monitor.html</guid>
       <dc:creator> Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>04 Jul 2019 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
temporal logic (MFOTL), an expressive extension of linear temporal
logic with real-time constraints and first-order quantification. The
verified monitor implements a simplified variant of the algorithm used
in the efficient MonPoly monitoring tool. The formalization is
presented in a forthcoming &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/rv19-verimon/verimon.pdf&#34;&gt;RV
2019 paper&lt;/a&gt;, which also compares the output of the verified
monitor to that of other monitoring tools on randomly generated
inputs. This case study revealed several errors in the optimized but
unverified tools.</description>
    </item>
    <item>
       <title>Complete Non-Orders and Fixed Points</title>
              <link>https://www.isa-afp.org/entries/Complete_Non_Orders.html</link>
       <guid>https://www.isa-afp.org/entries/Complete_Non_Orders.html</guid>
       <dc:creator> Akihisa Yamada, Jérémy Dubut       </dc:creator>
       <pubDate>27 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We develop an Isabelle/HOL library of order-theoretic concepts, such
as various completeness conditions and fixed-point theorems. We keep
our formalization as general as possible: we reprove several
well-known results about complete orders, often without any properties
of ordering, thus complete non-orders. In particular, we generalize
the Knaster–Tarski theorem so that we ensure the existence of a
quasi-fixed point of monotone maps over complete non-orders, and show
that the set of quasi-fixed points is complete under a mild
condition—attractivity—which is implied by either antisymmetry or
transitivity. This result generalizes and strengthens a result by
Stauti and Maaden. Finally, we recover Kleene’s fixed-point theorem
for omega-complete non-orders, again using attractivity to prove that
Kleene’s fixed points are least quasi-fixed points.</description>
    </item>
    <item>
       <title>Priority Search Trees</title>
              <link>https://www.isa-afp.org/entries/Priority_Search_Trees.html</link>
       <guid>https://www.isa-afp.org/entries/Priority_Search_Trees.html</guid>
       <dc:creator> Peter Lammich, Tobias Nipkow       </dc:creator>
       <pubDate>25 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We present a new, purely functional, simple and efficient data
structure combining a search tree and a priority queue, which we call
a &lt;em&gt;priority search tree&lt;/em&gt;. The salient feature of priority search
trees is that they offer a decrease-key operation, something that is
missing from other simple, purely functional priority queue
implementations. Priority search trees can be implemented on top of
any search tree. This entry does the implementation for red-black
trees.  This entry formalizes the first part of our ITP-2019 proof
pearl &lt;em&gt;Purely Functional, Simple and Efficient Priority
Search Trees and Applications to Prim and Dijkstra&lt;/em&gt;.</description>
    </item>
    <item>
       <title>Purely Functional, Simple, and Efficient Implementation of Prim and Dijkstra</title>
              <link>https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</link>
       <guid>https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</guid>
       <dc:creator> Peter Lammich, Tobias Nipkow       </dc:creator>
       <pubDate>25 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We verify purely functional, simple and efficient implementations of
Prim&#39;s and Dijkstra&#39;s algorithms. This constitutes the first
verification of an executable and even efficient version of
Prim&#39;s algorithm. This entry formalizes the second part of our
ITP-2019 proof pearl &lt;em&gt;Purely Functional, Simple and Efficient
Priority Search Trees and Applications to Prim and Dijkstra&lt;/em&gt;.</description>
    </item>
    <item>
       <title>Linear Inequalities</title>
              <link>https://www.isa-afp.org/entries/Linear_Inequalities.html</link>
       <guid>https://www.isa-afp.org/entries/Linear_Inequalities.html</guid>
       <dc:creator> Ralph Bottesch, Alban Reynaud, René Thiemann       </dc:creator>
       <pubDate>21 Jun 2019 00:00:00 +0000</pubDate>
       <description>
We formalize results about linear inqualities, mainly from
Schrijver&#39;s book. The main results are the proof of the
fundamental theorem on linear inequalities, Farkas&#39; lemma,
Carathéodory&#39;s theorem, the Farkas-Minkowsky-Weyl theorem, the
decomposition theorem of polyhedra, and Meyer&#39;s result that the
integer hull of a polyhedron is a polyhedron itself. Several theorems
include bounds on the appearing numbers, and in particular we provide
an a-priori bound on mixed-integer solutions of linear inequalities.</description>
    </item>
    <item>
       <title>Hilbert's Nullstellensatz</title>
              <link>https://www.isa-afp.org/entries/Nullstellensatz.html</link>
       <guid>https://www.isa-afp.org/entries/Nullstellensatz.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>16 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes Hilbert&#39;s Nullstellensatz, an important
theorem in algebraic geometry that can be viewed as the generalization
of the Fundamental Theorem of Algebra to multivariate polynomials: If
a set of (multivariate) polynomials over an algebraically closed field
has no common zero, then the ideal it generates is the entire
polynomial ring. The formalization proves several equivalent versions
of this celebrated theorem: the weak Nullstellensatz, the strong
Nullstellensatz (connecting algebraic varieties and radical ideals),
and the field-theoretic Nullstellensatz. The formalization follows
Chapter 4.1. of &lt;a
href=&#34;https://link.springer.com/book/10.1007/978-0-387-35651-8&#34;&gt;Ideals,
Varieties, and Algorithms&lt;/a&gt; by Cox, Little and O&#39;Shea.</description>
    </item>
    <item>
       <title>Gröbner Bases, Macaulay Matrices and Dubé's Degree Bounds</title>
              <link>https://www.isa-afp.org/entries/Groebner_Macaulay.html</link>
       <guid>https://www.isa-afp.org/entries/Groebner_Macaulay.html</guid>
       <dc:creator> Alexander Maletzky       </dc:creator>
       <pubDate>15 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This entry formalizes the connection between Gröbner bases and
Macaulay matrices (sometimes also referred to as `generalized
Sylvester matrices&#39;). In particular, it contains a method for
computing Gröbner bases, which proceeds by first constructing some
Macaulay matrix of the initial set of polynomials, then row-reducing
this matrix, and finally converting the result back into a set of
polynomials. The output is shown to be a Gröbner basis if the Macaulay
matrix constructed in the first step is sufficiently large. In order
to obtain concrete upper bounds on the size of the matrix (and hence
turn the method into an effectively executable algorithm), Dubé&#39;s
degree bounds on Gröbner bases are utilized; consequently, they are
also part of the formalization.</description>
    </item>
    <item>
       <title>Binary Heaps for IMP2</title>
              <link>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</link>
       <guid>https://www.isa-afp.org/entries/IMP2_Binary_Heap.html</guid>
       <dc:creator> Simon Griebel       </dc:creator>
       <pubDate>13 Jun 2019 00:00:00 +0000</pubDate>
       <description>
In this submission array-based binary minimum heaps are formalized.
The correctness of the following heap operations is proved: insert,
get-min, delete-min and make-heap. These are then used to verify an
in-place heapsort. The formalization is based on IMP2, an imperative
program verification framework implemented in Isabelle/HOL. The
verified heap functions are iterative versions of the partly recursive
functions found in &#34;Algorithms and Data Structures – The Basic
Toolbox&#34; by K. Mehlhorn and P. Sanders and &#34;Introduction to
Algorithms&#34; by T. H. Cormen, C. E. Leiserson, R. L. Rivest and C.
Stein.</description>
    </item>
    <item>
       <title>Differential Game Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Game_Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Differential_Game_Logic.html</guid>
       <dc:creator> André Platzer       </dc:creator>
       <pubDate>03 Jun 2019 00:00:00 +0000</pubDate>
       <description>
This formalization provides differential game logic (dGL), a logic for
proving properties of hybrid game. In addition to the syntax and
semantics, it formalizes a uniform substitution calculus for dGL.
Church&#39;s uniform substitutions substitute a term or formula for a
function or predicate symbol everywhere. The uniform substitutions for
dGL also substitute hybrid games for a game symbol everywhere. We
prove soundness of one-pass uniform substitutions and the axioms of
differential game logic with respect to their denotational semantics.
One-pass uniform substitutions are faster by postponing
soundness-critical admissibility checks with a linear pass homomorphic
application and regain soundness by a variable condition at the
replacements.  The formalization is based on prior non-mechanized
soundness proofs for dGL.</description>
    </item>
    <item>
       <title>Multidimensional Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/KD_Tree.html</link>
       <guid>https://www.isa-afp.org/entries/KD_Tree.html</guid>
       <dc:creator> Martin Rau       </dc:creator>
       <pubDate>30 May 2019 00:00:00 +0000</pubDate>
       <description>
This entry provides a formalization of multidimensional binary trees,
also known as k-d trees. It includes a balanced build algorithm as
well as the nearest neighbor algorithm and the range search algorithm.
It is based on the papers &lt;a
href=&#34;https://dl.acm.org/citation.cfm?doid=361002.361007&#34;&gt;Multidimensional
binary search trees used for associative searching&lt;/a&gt; and &lt;a
href=&#34;https://dl.acm.org/citation.cfm?doid=355744.355745&#34;&gt;
An Algorithm for Finding Best Matches in Logarithmic Expected
Time&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Formalization of Generic Authenticated Data Structures</title>
              <link>https://www.isa-afp.org/entries/LambdaAuth.html</link>
       <guid>https://www.isa-afp.org/entries/LambdaAuth.html</guid>
       <dc:creator> Matthias Brun, Dmitriy Traytel       </dc:creator>
       <pubDate>14 May 2019 00:00:00 +0000</pubDate>
       <description>
Authenticated data structures are a technique for outsourcing data
storage and maintenance to an untrusted server. The server is required
to produce an efficiently checkable and cryptographically secure proof
that it carried out precisely the requested computation. &lt;a
href=&#34;https://doi.org/10.1145/2535838.2535851&#34;&gt;Miller et
al.&lt;/a&gt; introduced &amp;lambda;&amp;bull; (pronounced
&lt;i&gt;lambda auth&lt;/i&gt;)&amp;mdash;a functional programming
language with a built-in primitive authentication construct, which
supports a wide range of user-specified authenticated data structures
while guaranteeing certain correctness and security properties for all
well-typed programs. We formalize &amp;lambda;&amp;bull; and prove its
correctness and security properties. With Isabelle&#39;s help, we
uncover and repair several mistakes in the informal proofs and lemma
statements. Our findings are summarized in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/lambdaauth/lambdaauth.pdf&#34;&gt;paper
draft&lt;/a&gt;.</description>
    </item>
    <item>
       <title>Multi-Party Computation</title>
              <link>https://www.isa-afp.org/entries/Multi_Party_Computation.html</link>
       <guid>https://www.isa-afp.org/entries/Multi_Party_Computation.html</guid>
       <dc:creator> David Aspinall, David Butler       </dc:creator>
       <pubDate>09 May 2019 00:00:00 +0000</pubDate>
       <description>
We use CryptHOL to consider Multi-Party Computation (MPC) protocols.
MPC was first considered by Yao in 1983 and recent advances in
efficiency and an increased demand mean it is now deployed in the real
world. Security is considered using the real/ideal world paradigm. We
first define security in the semi-honest security setting where
parties are assumed not to deviate from the protocol transcript. In
this setting we prove multiple Oblivious Transfer (OT) protocols
secure and then show security for the gates of the GMW protocol. We
then define malicious security, this is a stronger notion of security
where parties are assumed to be fully corrupted by an adversary. In
this setting we again consider OT, as it is a fundamental building
block of almost all MPC protocols.</description>
    </item>
    <item>
       <title>HOL-CSP Version 2.0</title>
              <link>https://www.isa-afp.org/entries/HOL-CSP.html</link>
       <guid>https://www.isa-afp.org/entries/HOL-CSP.html</guid>
       <dc:creator> Safouan Taha, Lina Ye, Burkhart Wolff       </dc:creator>
       <pubDate>26 Apr 2019 00:00:00 +0000</pubDate>
       <description>
This is a complete formalization of the work of Hoare and Roscoe on
the denotational semantics of the Failure/Divergence Model of CSP. It
follows essentially the presentation of CSP in Roscoe’s Book ”Theory
and Practice of Concurrency” [8] and the semantic details in a joint
Paper of Roscoe and Brooks ”An improved failures model for
communicating processes&#34;.  The present work is based on a prior
formalization attempt, called HOL-CSP 1.0, done in 1997 by H. Tej and
B. Wolff with the Isabelle proof technology available at that time.
This work revealed minor, but omnipresent foundational errors in key
concepts like the process invariant. The present version HOL-CSP
profits from substantially improved libraries (notably HOLCF),
improved automated proof techniques, and structured proof techniques
in Isar and is substantially shorter but more complete.</description>
    </item>
    <item>
       <title>A Compositional and Unified Translation of LTL into ω-Automata</title>
              <link>https://www.isa-afp.org/entries/LTL_Master_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/LTL_Master_Theorem.html</guid>
       <dc:creator> Benedikt Seidl, Salomon Sickert       </dc:creator>
       <pubDate>16 Apr 2019 00:00:00 +0000</pubDate>
       <description>
We present a formalisation of the unified translation approach of
linear temporal logic (LTL) into ω-automata from [1]. This approach
decomposes LTL formulas into ``simple&#39;&#39; languages and allows
a clear separation of concerns: first, we formalise the purely logical
result yielding this decomposition; second, we instantiate this
generic theory to obtain a construction for deterministic
(state-based) Rabin automata (DRA). We extract from this particular
instantiation an executable tool translating LTL to DRAs. To the best
of our knowledge this is the first verified translation from LTL to
DRAs that is proven to be double exponential in the worst case which
asymptotically matches the known lower bound.
&lt;p&gt;
[1] Javier Esparza, Jan Kretínský, Salomon Sickert. One Theorem to Rule Them All:
A Unified Translation of LTL into ω-Automata. LICS 2018</description>
    </item>
    <item>
       <title>A General Theory of Syntax with Bindings</title>
              <link>https://www.isa-afp.org/entries/Binding_Syntax_Theory.html</link>
       <guid>https://www.isa-afp.org/entries/Binding_Syntax_Theory.html</guid>
       <dc:creator> Lorenzo Gheri, Andrei Popescu       </dc:creator>
       <pubDate>06 Apr 2019 00:00:00 +0000</pubDate>
       <description>
We formalize a theory of syntax with bindings that has been developed
and refined over the last decade to support several large
formalization efforts. Terms are defined for an arbitrary number of
constructors of varying numbers of inputs, quotiented to
alpha-equivalence and sorted according to a binding signature. The
theory includes many properties of the standard operators on terms:
substitution, swapping and freshness. It also includes bindings-aware
induction and recursion principles and support for semantic
interpretation. This work has been presented in the ITP 2017 paper “A
Formalized General Theory of Syntax with Bindings”.</description>
    </item>
    <item>
       <title>The Transcendence of Certain Infinite Series</title>
              <link>https://www.isa-afp.org/entries/Transcendence_Series_Hancl_Rucki.html</link>
       <guid>https://www.isa-afp.org/entries/Transcendence_Series_Hancl_Rucki.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki, Wenda Li       </dc:creator>
       <pubDate>27 Mar 2019 00:00:00 +0000</pubDate>
       <description>
We formalize the proofs of two transcendence criteria by J. Hančl
and P. Rucki that assert the transcendence of the sums of certain
infinite series built up by sequences that fulfil certain properties.
Both proofs make use of Roth&#39;s celebrated theorem on diophantine
approximations to algebraic numbers from 1955  which we implement as
an assumption without having formalised its proof.</description>
    </item>
    <item>
       <title>Quantum Hoare Logic</title>
              <link>https://www.isa-afp.org/entries/QHLProver.html</link>
       <guid>https://www.isa-afp.org/entries/QHLProver.html</guid>
       <dc:creator> Junyi Liu, Bohua Zhan, Shuling Wang, Shenggang Ying, Tao Liu, Yangjia Li, Mingsheng Ying, Naijun Zhan       </dc:creator>
       <pubDate>24 Mar 2019 00:00:00 +0000</pubDate>
       <description>
We formalize quantum Hoare logic as given in [1]. In particular, we
specify the syntax and denotational semantics of a simple model of
quantum programs. Then, we write down the rules of quantum Hoare logic
for partial correctness, and show the soundness and completeness of
the resulting proof system. As an application, we verify the
correctness of Grover’s algorithm.</description>
    </item>
    <item>
       <title>Safe OCL</title>
              <link>https://www.isa-afp.org/entries/Safe_OCL.html</link>
       <guid>https://www.isa-afp.org/entries/Safe_OCL.html</guid>
       <dc:creator> Denis Nikiforov       </dc:creator>
       <pubDate>09 Mar 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The theory is a formalization of the
&lt;a href=&#34;https://www.omg.org/spec/OCL/&#34;&gt;OCL&lt;/a&gt; type system, its abstract
syntax and expression typing rules. The theory does not define a concrete
syntax and a semantics. In contrast to
&lt;a href=&#34;https://www.isa-afp.org/entries/Featherweight_OCL.html&#34;&gt;Featherweight OCL&lt;/a&gt;,
it is based on a deep embedding approach. The type system is defined from scratch,
it is not based on the Isabelle HOL type system.&lt;/p&gt;
&lt;p&gt;The Safe OCL distincts nullable and non-nullable types. Also the theory gives a
formal definition of &lt;a href=&#34;http://ceur-ws.org/Vol-1512/paper07.pdf&#34;&gt;safe
navigation operations&lt;/a&gt;. The Safe OCL typing rules are much stricter than rules
given in the OCL specification. It allows one to catch more errors on a type
checking phase.&lt;/p&gt;
&lt;p&gt;The type theory presented is four-layered: classes, basic types, generic types,
errorable types. We introduce the following new types: non-nullable types (T[1]),
nullable types (T[?]), OclSuper. OclSuper is a supertype of all other types (basic
types, collections, tuples). This type allows us to define a total supremum function,
so types form an upper semilattice. It allows us to define rich expression typing
rules in an elegant manner.&lt;/p&gt;
&lt;p&gt;The Preliminaries Chapter of the theory defines a number of helper lemmas for
transitive closures and tuples. It defines also a generic object model independent
from OCL. It allows one to use the theory as a reference for formalization of analogous languages.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Elementary Facts About the Distribution of Primes</title>
              <link>https://www.isa-afp.org/entries/Prime_Distribution_Elementary.html</link>
       <guid>https://www.isa-afp.org/entries/Prime_Distribution_Elementary.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>21 Feb 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry is a formalisation of Chapter 4 (and parts of
Chapter 3) of Apostol&#39;s &lt;a
href=&#34;https://www.springer.com/de/book/9780387901633&#34;&gt;&lt;em&gt;Introduction
to Analytic Number Theory&lt;/em&gt;&lt;/a&gt;. The main topics that
are addressed are properties of the distribution of prime numbers that
can be shown in an elementary way (i.&amp;thinsp;e. without the Prime
Number Theorem), the various equivalent forms of the PNT (which imply
each other in elementary ways), and consequences that follow from the
PNT in elementary ways. The latter include, most notably, asymptotic
bounds for the number of distinct prime factors of
&lt;em&gt;n&lt;/em&gt;, the divisor function
&lt;em&gt;d(n)&lt;/em&gt;, Euler&#39;s totient function
&lt;em&gt;&amp;phi;(n)&lt;/em&gt;, and
lcm(1,&amp;hellip;,&lt;em&gt;n&lt;/em&gt;).&lt;/p&gt;</description>
    </item>
    <item>
       <title>Kruskal's Algorithm for Minimum Spanning Forest</title>
              <link>https://www.isa-afp.org/entries/Kruskal.html</link>
       <guid>https://www.isa-afp.org/entries/Kruskal.html</guid>
       <dc:creator> Maximilian P.L. Haslbeck, Peter Lammich, Julian Biendarra       </dc:creator>
       <pubDate>14 Feb 2019 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization defines a greedy algorithm for finding
a minimum weight basis on a weighted matroid and proves its
correctness. This algorithm is an abstract version of Kruskal&#39;s
algorithm.  We interpret the abstract algorithm for the cycle matroid
(i.e. forests in a graph) and refine it to imperative executable code
using an efficient union-find data structure.  Our formalization can
be instantiated for different graph representations. We provide
instantiations for undirected graphs and symmetric directed graphs.</description>
    </item>
    <item>
       <title>Probabilistic Primality Testing</title>
              <link>https://www.isa-afp.org/entries/Probabilistic_Prime_Tests.html</link>
       <guid>https://www.isa-afp.org/entries/Probabilistic_Prime_Tests.html</guid>
       <dc:creator> Daniel Stüwe, Manuel Eberl       </dc:creator>
       <pubDate>11 Feb 2019 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The most efficient known primality tests are
&lt;em&gt;probabilistic&lt;/em&gt; in the sense that they use
randomness and may, with some probability, mistakenly classify a
composite number as prime &amp;ndash; but never a prime number as
composite. Examples of this are the Miller&amp;ndash;Rabin test, the
Solovay&amp;ndash;Strassen test, and (in most cases) Fermat&#39;s
test.&lt;/p&gt; &lt;p&gt;This entry defines these three tests and
proves their correctness. It also develops some of the
number-theoretic foundations, such as Carmichael numbers and the
Jacobi symbol with an efficient executable algorithm to compute
it.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Universal Turing Machine</title>
              <link>https://www.isa-afp.org/entries/Universal_Turing_Machine.html</link>
       <guid>https://www.isa-afp.org/entries/Universal_Turing_Machine.html</guid>
       <dc:creator> Jian Xu, Xingyuan Zhang, Christian Urban, Sebastiaan J. C. Joosten       </dc:creator>
       <pubDate>08 Feb 2019 00:00:00 +0000</pubDate>
       <description>
We formalise results from computability theory: recursive functions,
undecidability of the halting problem, and the existence of a
universal Turing machine. This formalisation is the AFP entry
corresponding to the paper Mechanising Turing Machines and Computability Theory
in Isabelle/HOL, ITP 2013.</description>
    </item>
    <item>
       <title>Isabelle/UTP: Mechanised Theory Engineering for Unifying Theories of Programming</title>
              <link>https://www.isa-afp.org/entries/UTP.html</link>
       <guid>https://www.isa-afp.org/entries/UTP.html</guid>
       <dc:creator> Simon Foster, Frank Zeyda, Yakoub Nemouchi, Pedro Ribeiro, Burkhart Wolff       </dc:creator>
       <pubDate>01 Feb 2019 00:00:00 +0000</pubDate>
       <description>
Isabelle/UTP is a mechanised theory engineering toolkit based on Hoare
and He’s Unifying Theories of Programming (UTP). UTP enables the
creation of denotational, algebraic, and operational semantics for
different programming languages using an alphabetised relational
calculus. We provide a semantic embedding of the alphabetised
relational calculus in Isabelle/HOL, including new type definitions,
relational constructors, automated proof tactics, and accompanying
algebraic laws. Isabelle/UTP can be used to both capture laws of
programming for different languages, and put these fundamental
theorems to work in the creation of associated verification tools,
using calculi like Hoare logics. This document describes the
relational core of the UTP in Isabelle/HOL.</description>
    </item>
  </channel>
</rss>
