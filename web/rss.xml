<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>23 May 2020 00:00:00 +0000</pubDate>
    <item>
       <title>A verified algorithm for computing the Smith normal form of a matrix</title>
              <link>https://www.isa-afp.org/entries/Smith_Normal_Form.html</link>
       <guid>https://www.isa-afp.org/entries/Smith_Normal_Form.html</guid>
       <dc:creator> Jose Divas√≥n       </dc:creator>
       <pubDate>23 May 2020 00:00:00 +0000</pubDate>
       <description>
This work presents a formal proof in Isabelle/HOL of an algorithm to
transform a matrix into its Smith normal form, a canonical matrix
form, in a general setting: the algorithm is parameterized by
operations to prove its existence over elementary divisor rings, while
execution is guaranteed over Euclidean domains. We also provide a
formal proof on some results about the generality of this algorithm as
well as the uniqueness of the Smith normal form.  Since Isabelle/HOL
does not feature dependent types, the development is carried out
switching conveniently between two different existing libraries: the
Hermite normal form (based on HOL Analysis) and the Jordan normal form
AFP entries. This permits to reuse results from both developments and
it is done by means of the lifting and transfer package together with
the use of local type definitions.</description>
    </item>
    <item>
       <title>The Nash-Williams Partition Theorem</title>
              <link>https://www.isa-afp.org/entries/Nash_Williams.html</link>
       <guid>https://www.isa-afp.org/entries/Nash_Williams.html</guid>
       <dc:creator> Lawrence C. Paulson       </dc:creator>
       <pubDate>16 May 2020 00:00:00 +0000</pubDate>
       <description>
In 1965, Nash-Williams discovered a generalisation of the infinite
form of Ramsey&#39;s theorem. Where the latter concerns infinite sets
of n-element sets for some fixed n, the Nash-Williams theorem concerns
infinite sets of finite sets (or lists) subject to a ‚Äúno initial
segment‚Äù condition. The present formalisation follows a
monograph on Ramsey Spaces by Todorƒçeviƒá.</description>
    </item>
    <item>
       <title>A Formalization of Knuth‚ÄìBendix Orders</title>
              <link>https://www.isa-afp.org/entries/Knuth_Bendix_Order.html</link>
       <guid>https://www.isa-afp.org/entries/Knuth_Bendix_Order.html</guid>
       <dc:creator> Christian Sternagel, Ren√© Thiemann       </dc:creator>
       <pubDate>13 May 2020 00:00:00 +0000</pubDate>
       <description>
We define a generalized version of Knuth&amp;ndash;Bendix orders,
including subterm coefficient functions. For these orders we formalize
several properties such as strong normalization, the subterm property,
closure properties under substitutions and contexts, as well as ground
totality.</description>
    </item>
    <item>
       <title>Irrationality Criteria for Series by Erd≈ës and Straus</title>
              <link>https://www.isa-afp.org/entries/Irrational_Series_Erdos_Straus.html</link>
       <guid>https://www.isa-afp.org/entries/Irrational_Series_Erdos_Straus.html</guid>
       <dc:creator> Angeliki Koutsoukou-Argyraki, Wenda Li       </dc:creator>
       <pubDate>12 May 2020 00:00:00 +0000</pubDate>
       <description>
We formalise certain irrationality criteria for infinite series of the form:
\[\sum_{n=1}^\infty \frac{b_n}{\prod_{i=1}^n a_i} \]
where $\{b_n\}$ is a sequence of integers and $\{a_n\}$ a sequence of positive integers
with $a_n &gt;1$ for all large n. The results are due to P. Erd≈ës and E. G. Straus
&lt;a href=&#34;https://projecteuclid.org/euclid.pjm/1102911140&#34;&gt;[1]&lt;/a&gt;.
In particular, we formalise Theorem 2.1, Corollary 2.10 and Theorem 3.1.
The latter is an application of Theorem 2.1 involving the prime numbers.</description>
    </item>
    <item>
       <title>Recursion Theorem in ZF</title>
              <link>https://www.isa-afp.org/entries/Recursion-Addition.html</link>
       <guid>https://www.isa-afp.org/entries/Recursion-Addition.html</guid>
       <dc:creator> Georgy Dunaev       </dc:creator>
       <pubDate>11 May 2020 00:00:00 +0000</pubDate>
       <description>
This document contains a proof of the recursion theorem. This is a
mechanization of the proof of the recursion theorem from the text &lt;i&gt;Introduction to
Set Theory&lt;/i&gt;, by Karel Hrbacek and Thomas Jech. This
implementation may be used as the basis for a model of Peano arithmetic in
ZF. While recursion and the natural numbers are already available in Isabelle/ZF, this clean development
is much easier to follow.</description>
    </item>
    <item>
       <title>An Efficient Normalisation Procedure for Linear Temporal Logic: Isabelle/HOL Formalisation</title>
              <link>https://www.isa-afp.org/entries/LTL_Normal_Form.html</link>
       <guid>https://www.isa-afp.org/entries/LTL_Normal_Form.html</guid>
       <dc:creator> Salomon Sickert       </dc:creator>
       <pubDate>08 May 2020 00:00:00 +0000</pubDate>
       <description>
In the mid 80s, Lichtenstein, Pnueli, and Zuck proved a classical
theorem stating that every formula of Past LTL (the extension of LTL
with past operators) is equivalent to a formula of the form
$\bigwedge_{i=1}^n \mathbf{G}\mathbf{F} \varphi_i \vee
\mathbf{F}\mathbf{G} \psi_i$,  where $\varphi_i$ and $\psi_i$ contain
only past operators. Some years later, Chang, Manna, and Pnueli built
on this result to derive a similar normal form for LTL. Both
normalisation procedures have a non-elementary worst-case blow-up, and
follow an involved path from formulas to counter-free automata to
star-free regular expressions and back to formulas. We improve on both
points. We present an executable formalisation of a direct and purely
syntactic normalisation procedure for LTL yielding a normal form,
comparable to the one by Chang, Manna, and Pnueli, that has only a
single exponential blow-up.</description>
    </item>
    <item>
       <title>Formalization of Forcing in Isabelle/ZF</title>
              <link>https://www.isa-afp.org/entries/Forcing.html</link>
       <guid>https://www.isa-afp.org/entries/Forcing.html</guid>
       <dc:creator> Emmanuel Gunther, Miguel Pagano, Pedro S√°nchez Terraf       </dc:creator>
       <pubDate>06 May 2020 00:00:00 +0000</pubDate>
       <description>
We formalize the theory of forcing in the set theory framework of
Isabelle/ZF. Under the assumption of the existence of a countable
transitive model of ZFC, we construct a proper generic extension and
show that the latter also satisfies ZFC.</description>
    </item>
    <item>
       <title>Banach-Steinhaus Theorem</title>
              <link>https://www.isa-afp.org/entries/Banach_Steinhaus.html</link>
       <guid>https://www.isa-afp.org/entries/Banach_Steinhaus.html</guid>
       <dc:creator> Dominique Unruh, Jose Manuel Rodriguez Caballero       </dc:creator>
       <pubDate>02 May 2020 00:00:00 +0000</pubDate>
       <description>
We formalize in Isabelle/HOL a result
due to S. Banach and H. Steinhaus known as
the Banach-Steinhaus theorem or Uniform boundedness principle: a
pointwise-bounded family of continuous linear operators from a Banach
space to a normed space is uniformly bounded. Our approach is an
adaptation to Isabelle/HOL of a proof due to A. Sokal.</description>
    </item>
    <item>
       <title>Attack Trees in Isabelle for GDPR compliance of IoT healthcare systems</title>
              <link>https://www.isa-afp.org/entries/Attack_Trees.html</link>
       <guid>https://www.isa-afp.org/entries/Attack_Trees.html</guid>
       <dc:creator> Florian Kammueller       </dc:creator>
       <pubDate>27 Apr 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a proof theory for Attack Trees. Attack
Trees are a well established and useful model for the construction of
attacks on systems since they allow a stepwise exploration of high
level attacks in application scenarios. Using the expressiveness of
Higher Order Logic in Isabelle, we develop a generic
theory of Attack Trees with a state-based semantics based on Kripke
structures and CTL. The resulting framework
allows mechanically supported logic analysis of the meta-theory of the
proof calculus of Attack Trees and at the same time the developed
proof theory enables application to case studies. A central
correctness and completeness result proved in Isabelle establishes a
connection between the notion of Attack Tree validity and CTL. The
application is illustrated on the example of a healthcare IoT system
and GDPR compliance verification.</description>
    </item>
    <item>
       <title>Power Sum Polynomials</title>
              <link>https://www.isa-afp.org/entries/Power_Sum_Polynomials.html</link>
       <guid>https://www.isa-afp.org/entries/Power_Sum_Polynomials.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>24 Apr 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides a formalisation of the symmetric
multivariate polynomials known as &lt;em&gt;power sum
polynomials&lt;/em&gt;. These are of the form
p&lt;sub&gt;n&lt;/sub&gt;(&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,
&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;) =
&lt;em&gt;X&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;n&lt;/sup&gt;
+ &amp;hellip; +
X&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;n&lt;/sup&gt;.
A formal proof of the Girard‚ÄìNewton Theorem is also given. This
theorem relates the power sum polynomials to the elementary symmetric
polynomials s&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; in the form
of a recurrence relation
(-1)&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;
&lt;em&gt;k&lt;/em&gt; s&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;
=
&amp;sum;&lt;sub&gt;i&amp;isinv;[0,&lt;em&gt;k&lt;/em&gt;)&lt;/sub&gt;
(-1)&lt;sup&gt;i&lt;/sup&gt; s&lt;sub&gt;i&lt;/sub&gt;
p&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;-&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&amp;thinsp;.&lt;/p&gt;
&lt;p&gt;As an application, this is then used to solve a generalised
form of a puzzle given as an exercise in Dummit and Foote&#39;s
&lt;em&gt;Abstract Algebra&lt;/em&gt;: For &lt;em&gt;k&lt;/em&gt;
complex unknowns &lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;,
&amp;hellip;,
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;,
define p&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt; :=
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sup&gt;
+ &amp;hellip; +
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;&lt;sup&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sup&gt;.
Then for each vector &lt;em&gt;a&lt;/em&gt; &amp;isinv;
&amp;#x2102;&lt;sup&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sup&gt;, show that
there is exactly one solution to the system p&lt;sub&gt;1&lt;/sub&gt;
= a&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;,
p&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; =
a&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt; up to permutation of
the
&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;
and determine the value of
p&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; for
i&amp;gt;k.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Lambert W Function on the Reals</title>
              <link>https://www.isa-afp.org/entries/Lambert_W.html</link>
       <guid>https://www.isa-afp.org/entries/Lambert_W.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>24 Apr 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Lambert &lt;em&gt;W&lt;/em&gt; function is a multi-valued
function defined as the inverse function of &lt;em&gt;x&lt;/em&gt;
&amp;#x21A6; &lt;em&gt;x&lt;/em&gt;
e&lt;sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sup&gt;. Besides numerous
applications in combinatorics, physics, and engineering, it also
frequently occurs when solving equations containing both
e&lt;sup&gt;&lt;em&gt;x&lt;/em&gt;&lt;/sup&gt; and
&lt;em&gt;x&lt;/em&gt;, or both &lt;em&gt;x&lt;/em&gt; and log
&lt;em&gt;x&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;This article provides a
definition of the two real-valued branches
&lt;em&gt;W&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;)
and
&lt;em&gt;W&lt;/em&gt;&lt;sub&gt;-1&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;)
and proves various properties such as basic identities and
inequalities, monotonicity, differentiability, asymptotic expansions,
and the MacLaurin series of
&lt;em&gt;W&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;(&lt;em&gt;x&lt;/em&gt;)
at &lt;em&gt;x&lt;/em&gt; = 0.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Gaussian Integers</title>
              <link>https://www.isa-afp.org/entries/Gaussian_Integers.html</link>
       <guid>https://www.isa-afp.org/entries/Gaussian_Integers.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>24 Apr 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Gaussian integers are the subring &amp;#8484;[i] of the
complex numbers, i. e. the ring of all complex numbers with integral
real and imaginary part. This article provides a definition of this
ring as well as proofs of various basic properties, such as that they
form a Euclidean ring and a full classification of their primes. An
executable (albeit not very efficient) factorisation algorithm is also
provided.&lt;/p&gt; &lt;p&gt;Lastly, this Gaussian integer
formalisation is used in two short applications:&lt;/p&gt; &lt;ol&gt;
&lt;li&gt; The characterisation of all positive integers that can be
written as sums of two squares&lt;/li&gt; &lt;li&gt; Euclid&#39;s
formula for primitive Pythagorean triples&lt;/li&gt; &lt;/ol&gt;
&lt;p&gt;While elementary proofs for both of these are already
available in the AFP, the theory of Gaussian integers provides more
concise proofs and a more high-level view.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Matrices for ODEs</title>
              <link>https://www.isa-afp.org/entries/Matrices_for_ODEs.html</link>
       <guid>https://www.isa-afp.org/entries/Matrices_for_ODEs.html</guid>
       <dc:creator> Jonathan Julian Huerta y Munive       </dc:creator>
       <pubDate>19 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Our theories formalise various matrix properties that serve to
establish existence, uniqueness and characterisation of the solution
to affine systems of ordinary differential equations (ODEs). In
particular, we formalise the operator and maximum norm of matrices.
Then we use them to prove that square matrices form a Banach space,
and in this setting, we show an instance of Picard-Lindel√∂f‚Äôs
theorem for affine systems of ODEs. Finally, we use this formalisation
to verify three simple hybrid programs.</description>
    </item>
    <item>
       <title>Authenticated Data Structures As Functors</title>
              <link>https://www.isa-afp.org/entries/ADS_Functor.html</link>
       <guid>https://www.isa-afp.org/entries/ADS_Functor.html</guid>
       <dc:creator> Andreas Lochbihler, Ognjen Mariƒá       </dc:creator>
       <pubDate>16 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Authenticated data structures allow several systems to convince each
other that they are referring to the same data structure, even if each
of them knows only a part of the data structure. Using inclusion
proofs, knowledgeable systems can selectively share their knowledge
with other systems and the latter can verify the authenticity of what
is being shared.  In this article, we show how to modularly define
authenticated data structures, their inclusion proofs, and operations
thereon as datatypes in Isabelle/HOL, using a shallow embedding.
Modularity allows us to construct complicated trees from reusable
building blocks, which we call Merkle functors. Merkle functors
include sums, products, and function spaces and are closed under
composition and least fixpoints.  As a practical application, we model
the hierarchical transactions of &lt;a
href=&#34;https://www.canton.io&#34;&gt;Canton&lt;/a&gt;, a
practical interoperability protocol for distributed ledgers, as
authenticated data structures. This is a first step towards
formalizing the Canton protocol and verifying its integrity and
security guarantees.</description>
    </item>
    <item>
       <title>Formalization of an Algorithm for Greedily Computing Associative Aggregations on Sliding Windows</title>
              <link>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</link>
       <guid>https://www.isa-afp.org/entries/Sliding_Window_Algorithm.html</guid>
       <dc:creator> Lukas Heimes, Dmitriy Traytel, Joshua Schneider       </dc:creator>
       <pubDate>10 Apr 2020 00:00:00 +0000</pubDate>
       <description>
Basin et al.&#39;s &lt;a
href=&#34;https://doi.org/10.1016/j.ipl.2014.09.009&#34;&gt;sliding
window algorithm (SWA)&lt;/a&gt; is an algorithm for combining the
elements of subsequences of a sequence with an associative operator.
It is greedy and minimizes the number of operator applications. We
formalize the algorithm and verify its functional correctness. We
extend the algorithm with additional operations and provide an
alternative interface to the slide operation that does not require the
entire input sequence.</description>
    </item>
    <item>
       <title>A Comprehensive Framework for Saturation Theorem Proving</title>
              <link>https://www.isa-afp.org/entries/Saturation_Framework.html</link>
       <guid>https://www.isa-afp.org/entries/Saturation_Framework.html</guid>
       <dc:creator> Sophie Tourret       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This Isabelle/HOL formalization is the companion of the technical
report ‚ÄúA comprehensive framework for saturation theorem proving‚Äù,
itself companion of the eponym IJCAR 2020 paper, written by Uwe
Waldmann, Sophie Tourret, Simon Robillard and Jasmin Blanchette. It
verifies a framework for formal refutational completeness proofs of
abstract provers that implement saturation calculi, such as ordered
resolution or superposition, and allows to model entire prover
architectures in such a way that the static refutational completeness
of a calculus immediately implies the dynamic  refutational
completeness of a prover implementing the calculus using a variant of
the given clause loop.  The technical report ‚ÄúA comprehensive
framework for saturation theorem proving‚Äù is available &lt;a
href=&#34;http://matryoshka.gforge.inria.fr/pubs/satur_report.pdf&#34;&gt;on
the Matryoshka website&lt;/a&gt;. The names of the Isabelle lemmas and
theorems corresponding to the results in the report are indicated in
the margin of the report.</description>
    </item>
    <item>
       <title>Formalization of an Optimized Monitoring Algorithm for Metric First-Order Dynamic Logic with Aggregations</title>
              <link>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</link>
       <guid>https://www.isa-afp.org/entries/MFODL_Monitor_Optimized.html</guid>
       <dc:creator> Thibault Dardinier, Lukas Heimes, Martin Raszyk, Joshua Schneider, Dmitriy Traytel       </dc:creator>
       <pubDate>09 Apr 2020 00:00:00 +0000</pubDate>
       <description>
A monitor is a runtime verification tool that solves the following
problem: Given a stream of time-stamped events and a policy formulated
in a specification language, decide whether the policy is satisfied at
every point in the stream. We verify the correctness of an executable
monitor for specifications given as formulas in metric first-order
dynamic logic (MFODL), which combines the features of metric
first-order temporal logic (MFOTL) and metric dynamic logic. Thus,
MFODL supports real-time constraints, first-order parameters, and
regular expressions. Additionally, the monitor supports aggregation
operations such as count and sum. This formalization, which is
described in a &lt;a
href=&#34;http://people.inf.ethz.ch/trayteld/papers/ijcar20-verimonplus/verimonplus.pdf&#34;&gt;
forthcoming paper at IJCAR 2020&lt;/a&gt;, significantly extends &lt;a
href=&#34;https://www.isa-afp.org/entries/MFOTL_Monitor.html&#34;&gt;previous
work on a verified monitor&lt;/a&gt; for MFOTL. Apart from the
addition of regular expressions and aggregations, we implemented &lt;a
href=&#34;https://www.isa-afp.org/entries/Generic_Join.html&#34;&gt;multi-way
joins&lt;/a&gt; and a specialized sliding window algorithm to further
optimize the monitor.</description>
    </item>
    <item>
       <title>Stateful Protocol Composition and Typing</title>
              <link>https://www.isa-afp.org/entries/Stateful_Protocol_Composition_and_Typing.html</link>
       <guid>https://www.isa-afp.org/entries/Stateful_Protocol_Composition_and_Typing.html</guid>
       <dc:creator> Andreas V. Hess, Sebastian M√∂dersheim, Achim D. Brucker       </dc:creator>
       <pubDate>08 Apr 2020 00:00:00 +0000</pubDate>
       <description>
We provide in this AFP entry several relative soundness results for
security protocols. In particular, we prove typing and
compositionality results for stateful protocols (i.e., protocols with
mutable state that may span several sessions), and that focuses on
reachability properties. Such results are useful to simplify protocol
verification by reducing it to a simpler problem: Typing results give
conditions under which it is safe to verify a protocol in a typed
model where only &#34;well-typed&#34; attacks can occur whereas
compositionality results allow us to verify a composed protocol by
only verifying the component protocols in isolation. The conditions on
the protocols under which the results hold are furthermore syntactic
in nature allowing for full automation. The foundation presented here
is used in another entry to provide fully automated and formalized
security proofs of stateful protocols.</description>
    </item>
    <item>
       <title>Automated Stateful Protocol Verification</title>
              <link>https://www.isa-afp.org/entries/Automated_Stateful_Protocol_Verification.html</link>
       <guid>https://www.isa-afp.org/entries/Automated_Stateful_Protocol_Verification.html</guid>
       <dc:creator> Andreas V. Hess, Sebastian M√∂dersheim, Achim D. Brucker, Anders Schlichtkrull       </dc:creator>
       <pubDate>08 Apr 2020 00:00:00 +0000</pubDate>
       <description>
In protocol verification we observe a wide spectrum from fully
automated methods to interactive theorem proving with proof assistants
like Isabelle/HOL. In this AFP entry, we present a fully-automated
approach for verifying stateful security protocols, i.e., protocols
with mutable state that may span several sessions. The approach
supports reachability goals like secrecy and authentication. We also
include a simple user-friendly transaction-based protocol
specification language that is embedded into Isabelle.</description>
    </item>
    <item>
       <title>Lucas's Theorem</title>
              <link>https://www.isa-afp.org/entries/Lucas_Theorem.html</link>
       <guid>https://www.isa-afp.org/entries/Lucas_Theorem.html</guid>
       <dc:creator> Chelsea Edmonds       </dc:creator>
       <pubDate>07 Apr 2020 00:00:00 +0000</pubDate>
       <description>
This work presents a formalisation of a generating function proof for
Lucas&#39;s theorem. We first outline extensions to the existing
Formal Power Series (FPS) library, including an equivalence relation
for coefficients modulo &lt;em&gt;n&lt;/em&gt;, an alternate binomial theorem statement,
and a formalised proof of the Freshman&#39;s dream (mod &lt;em&gt;p&lt;/em&gt;) lemma.
The second part of the work presents the formal proof of Lucas&#39;s
Theorem. Working backwards, the formalisation first proves a well
known corollary of the theorem which is easier to formalise, and then
applies induction to prove the original theorem statement. The proof
of the corollary aims to provide a good example of a formalised
generating function equivalence proof using the FPS library. The final
theorem statement is intended to be integrated into the formalised
proof of Hilbert&#39;s 10th Problem.</description>
    </item>
    <item>
       <title>Strong Eventual Consistency of the Collaborative Editing Framework WOOT</title>
              <link>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</link>
       <guid>https://www.isa-afp.org/entries/WOOT_Strong_Eventual_Consistency.html</guid>
       <dc:creator> Emin Karayel, Edgar Gonz√†lez       </dc:creator>
       <pubDate>25 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Commutative Replicated Data Types (CRDTs) are a promising new class of
data structures for large-scale shared mutable content in applications
that only require eventual consistency. The WithOut Operational
Transforms (WOOT) framework is a CRDT for collaborative text editing
introduced by Oster et al. (CSCW 2006) for which the eventual
consistency property was verified only for a bounded model to date. We
contribute a formal proof for WOOTs strong eventual consistency.</description>
    </item>
    <item>
       <title>Furstenberg's topology and his proof of the infinitude of primes</title>
              <link>https://www.isa-afp.org/entries/Furstenberg_Topology.html</link>
       <guid>https://www.isa-afp.org/entries/Furstenberg_Topology.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>22 Mar 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article gives a formal version of Furstenberg&#39;s
topological proof of the infinitude of primes. He defines a topology
on the integers based on arithmetic progressions (or, equivalently,
residue classes). Using some fairly obvious properties of this
topology, the infinitude of primes is then easily obtained.&lt;/p&gt;
&lt;p&gt;Apart from this, this topology is also fairly ‚Äònice‚Äô in
general: it is second countable, metrizable, and perfect. All of these
(well-known) facts are formally proven, including an explicit metric
for the topology given by Zulfeqarr.&lt;/p&gt;</description>
    </item>
    <item>
       <title>An Under-Approximate Relational Logic</title>
              <link>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</link>
       <guid>https://www.isa-afp.org/entries/Relational-Incorrectness-Logic.html</guid>
       <dc:creator> Toby Murray       </dc:creator>
       <pubDate>12 Mar 2020 00:00:00 +0000</pubDate>
       <description>
Recently, authors have proposed under-approximate logics for reasoning
about programs. So far, all such logics have been confined to
reasoning about individual program behaviours. Yet there exist many
over-approximate relational logics for reasoning about pairs of
programs and relating their behaviours. We present the first
under-approximate relational logic, for the simple imperative language
IMP. We prove our logic is both sound and complete. Additionally, we
show how reasoning in this logic can be decomposed into non-relational
reasoning in an under-approximate Hoare logic, mirroring Beringer‚Äôs
result for over-approximate relational logics. We illustrate the
application of our logic on some small examples in which we provably
demonstrate the presence of insecurity.</description>
    </item>
    <item>
       <title>Hello World</title>
              <link>https://www.isa-afp.org/entries/Hello_World.html</link>
       <guid>https://www.isa-afp.org/entries/Hello_World.html</guid>
       <dc:creator> Cornelius Diekmann, Lars Hupel       </dc:creator>
       <pubDate>07 Mar 2020 00:00:00 +0000</pubDate>
       <description>
In this article, we present a formalization of the well-known
&#34;Hello, World!&#34; code, including a formal framework for
reasoning about IO. Our model is inspired by the handling of IO in
Haskell. We start by formalizing the üåç and embrace the IO monad
afterwards. Then we present a sample main :: IO (), followed by its
proof of correctness.</description>
    </item>
    <item>
       <title>Implementing the Goodstein Function in &lambda;-Calculus</title>
              <link>https://www.isa-afp.org/entries/Goodstein_Lambda.html</link>
       <guid>https://www.isa-afp.org/entries/Goodstein_Lambda.html</guid>
       <dc:creator> Bertram Felgenhauer       </dc:creator>
       <pubDate>21 Feb 2020 00:00:00 +0000</pubDate>
       <description>
In this formalization, we develop an implementation of the Goodstein
function G in plain &amp;lambda;-calculus, linked to a concise, self-contained
specification. The implementation works on a Church-encoded
representation of countable ordinals. The initial conversion to
hereditary base 2 is not covered, but the material is sufficient to
compute the particular value G(16), and easily extends to other fixed
arguments.</description>
    </item>
    <item>
       <title>A Generic Framework for Verified Compilers</title>
              <link>https://www.isa-afp.org/entries/VeriComp.html</link>
       <guid>https://www.isa-afp.org/entries/VeriComp.html</guid>
       <dc:creator> Martin Desharnais       </dc:creator>
       <pubDate>10 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This is a generic framework for formalizing compiler transformations.
It leverages Isabelle/HOL‚Äôs locales to abstract over concrete
languages and transformations. It states common definitions for
language semantics, program behaviours, forward and backward
simulations, and compilers. We provide generic operations, such as
simulation and compiler composition, and prove general (partial)
correctness theorems, resulting in reusable proof components.</description>
    </item>
    <item>
       <title>Arithmetic progressions and relative primes</title>
              <link>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Arith_Prog_Rel_Primes.html</guid>
       <dc:creator> Jos√© Manuel Rodr√≠guez Caballero       </dc:creator>
       <pubDate>01 Feb 2020 00:00:00 +0000</pubDate>
       <description>
This article provides a formalization of the solution obtained by the
author of the Problem ‚ÄúARITHMETIC PROGRESSIONS‚Äù from the
&lt;a href=&#34;https://www.ocf.berkeley.edu/~wwu/riddles/putnam.shtml&#34;&gt;
Putnam exam problems of 2002&lt;/a&gt;. The statement of the problem is
as follows: For which integers &lt;em&gt;n&lt;/em&gt; &gt; 1 does the set of positive
integers less than and relatively prime to &lt;em&gt;n&lt;/em&gt; constitute an
arithmetic progression?</description>
    </item>
    <item>
       <title>A Hierarchy of Algebras for Boolean Subsets</title>
              <link>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</link>
       <guid>https://www.isa-afp.org/entries/Subset_Boolean_Algebras.html</guid>
       <dc:creator> Walter Guttmann, Bernhard M√∂ller       </dc:creator>
       <pubDate>31 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present a collection of axiom systems for the construction of
Boolean subalgebras of larger overall algebras. The subalgebras are
defined as the range of a complement-like operation on a semilattice.
This technique has been used, for example, with the antidomain
operation, dynamic negation and Stone algebras. We present a common
ground for these constructions based on a new equational
axiomatisation of Boolean algebras.</description>
    </item>
    <item>
       <title>Mersenne primes and the Lucas‚ÄìLehmer test</title>
              <link>https://www.isa-afp.org/entries/Mersenne_Primes.html</link>
       <guid>https://www.isa-afp.org/entries/Mersenne_Primes.html</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>17 Jan 2020 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article provides formal proofs of basic properties of
Mersenne numbers, i. e. numbers of the form
2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; - 1, and especially of
Mersenne primes.&lt;/p&gt; &lt;p&gt;In particular, an efficient,
verified, and executable version of the Lucas&amp;ndash;Lehmer test is
developed. This test decides primality for Mersenne numbers in time
polynomial in &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Verified Approximation Algorithms</title>
              <link>https://www.isa-afp.org/entries/Approximation_Algorithms.html</link>
       <guid>https://www.isa-afp.org/entries/Approximation_Algorithms.html</guid>
       <dc:creator> Robin E√ümann, Tobias Nipkow, Simon Robillard       </dc:creator>
       <pubDate>16 Jan 2020 00:00:00 +0000</pubDate>
       <description>
We present the first formal verification of approximation algorithms
for NP-complete optimization problems: vertex cover, independent set,
load balancing, and bin packing. The proofs correct incompletenesses
in existing proofs and improve the approximation ratio in one case.</description>
    </item>
  </channel>
</rss>
