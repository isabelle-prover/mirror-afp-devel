<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://www.isa-afp.org/rss.xml" rel="self" type="application/rss+xml" />
    <title>Archive of Formal Proofs</title>
    <link>https://www.isa-afp.org</link>
    <description>
      The Archive of Formal Proofs is a collection of proof libraries, examples,
      and larger scientific developments, mechanically checked
      in the theorem prover Isabelle.
    </description>
    <pubDate>06 Jun 2017 00:00:00 +0000</pubDate>
    <item>
       <title>Buffon's Needle Problem</title>
              <link>https://www.isa-afp.org/entries/Buffons_Needle.shtml</link>
       <guid>https://www.isa-afp.org/entries/Buffons_Needle.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>06 Jun 2017 00:00:00 +0000</pubDate>
       <description>
In the 18th century, Georges-Louis Leclerc, Comte de Buffon posed and
later solved the following problem, which is often called the first
problem ever solved in geometric probability: Given a floor divided
into vertical strips of the same width, what is the probability that a
needle thrown onto the floor randomly will cross two strips?  This
entry formally defines the problem in the case where the needle&#39;s
position is chosen uniformly at random in a single strip around the
origin (which is equivalent to larger arrangements due to symmetry).
It then provides proofs of the simple solution in the case where the
needle&#39;s length is no greater than the width of the strips and
the more complicated solution in the opposite case.</description>
    </item>
    <item>
       <title>Formalizing Push-Relabel Algorithms</title>
              <link>https://www.isa-afp.org/entries/Prpu_Maxflow.shtml</link>
       <guid>https://www.isa-afp.org/entries/Prpu_Maxflow.shtml</guid>
       <dc:creator> Peter Lammich, S. Reza Sefidgar       </dc:creator>
       <pubDate>01 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of push-relabel algorithms for computing
the maximum flow in a network. We start with Goldberg&#39;s et
al.~generic push-relabel algorithm, for which we show correctness and
the time complexity bound of O(V^2E). We then derive the
relabel-to-front and FIFO implementation. Using stepwise refinement
techniques, we derive an efficient verified implementation.  Our
formal proof of the abstract algorithms closely follows a standard
textbook proof. It is accessible even without being an expert in
Isabelle/HOL, the interactive theorem prover used for the
formalization.</description>
    </item>
    <item>
       <title>Flow Networks and the Min-Cut-Max-Flow Theorem</title>
              <link>https://www.isa-afp.org/entries/Flow_Networks.shtml</link>
       <guid>https://www.isa-afp.org/entries/Flow_Networks.shtml</guid>
       <dc:creator> Peter Lammich, S. Reza Sefidgar       </dc:creator>
       <pubDate>01 Jun 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of flow networks and the Min-Cut-Max-Flow
theorem. Our formal proof closely follows a standard textbook proof,
and is accessible even without being an expert in Isabelle/HOL, the
interactive theorem prover used for the formalization.</description>
    </item>
    <item>
       <title>Optics</title>
              <link>https://www.isa-afp.org/entries/Optics.shtml</link>
       <guid>https://www.isa-afp.org/entries/Optics.shtml</guid>
       <dc:creator> Simon Foster, Frank Zeyda       </dc:creator>
       <pubDate>25 May 2017 00:00:00 +0000</pubDate>
       <description>
Lenses provide an abstract interface for manipulating data types
through spatially-separated views. They are defined abstractly in
terms of two functions, &lt;em&gt;get&lt;/em&gt;, the return a value
from the source type, and &lt;em&gt;put&lt;/em&gt; that updates the
value. We mechanise the underlying theory of lenses, in terms of an
algebraic hierarchy of lenses, including well-behaved and very
well-behaved lenses, each lens class being characterised by a set of
lens laws. We also mechanise a lens algebra in Isabelle that enables
their composition and comparison, so as to allow construction of
complex lenses. This is accompanied by a large library of algebraic
laws. Moreover we also show how the lens classes can be applied by
instantiating them with a number of Isabelle data types.</description>
    </item>
    <item>
       <title>Developing Security Protocols by Refinement</title>
              <link>https://www.isa-afp.org/entries/Security_Protocol_Refinement.shtml</link>
       <guid>https://www.isa-afp.org/entries/Security_Protocol_Refinement.shtml</guid>
       <dc:creator> Christoph Sprenger, Ivano Somaini       </dc:creator>
       <pubDate>24 May 2017 00:00:00 +0000</pubDate>
       <description>
We propose a development method for security protocols based on
stepwise refinement. Our refinement strategy transforms abstract
security goals into protocols that are secure when operating over an
insecure channel controlled by a Dolev-Yao-style intruder. As
intermediate levels of abstraction, we employ messageless guard
protocols and channel protocols communicating over channels with
security properties. These abstractions provide insights on why
protocols are secure and foster the development of families of
protocols sharing common structure and properties. We have implemented
our method in Isabelle/HOL and used it to develop different entity
authentication and key establishment protocols, including realistic
features such as key confirmation, replay caches, and encrypted
tickets. Our development highlights that guard protocols and channel
protocols provide fundamental abstractions for bridging the gap
between security properties and standard protocol descriptions based
on cryptographic messages. It also shows that our refinement approach
scales to protocols of nontrivial size and complexity.</description>
    </item>
    <item>
       <title>Dictionary Construction</title>
              <link>https://www.isa-afp.org/entries/Dict_Construction.shtml</link>
       <guid>https://www.isa-afp.org/entries/Dict_Construction.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>24 May 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator natively supports type classes. For
targets that do not have language support for classes and instances,
it performs the well-known dictionary translation, as described by
Haftmann and Nipkow. This translation happens outside the logic, i.e.,
there is no guarantee that it is correct, besides the pen-and-paper
proof. This work implements a certified dictionary translation that
produces new class-free constants and derives equality theorems.</description>
    </item>
    <item>
       <title>The Floyd-Warshall Algorithm for Shortest Paths</title>
              <link>https://www.isa-afp.org/entries/Floyd_Warshall.shtml</link>
       <guid>https://www.isa-afp.org/entries/Floyd_Warshall.shtml</guid>
       <dc:creator> Simon Wimmer, Peter Lammich       </dc:creator>
       <pubDate>08 May 2017 00:00:00 +0000</pubDate>
       <description>
The Floyd-Warshall algorithm [Flo62, Roy59, War62] is a classic
dynamic programming algorithm to compute the length of all shortest
paths between any two vertices in a graph (i.e. to solve the all-pairs
shortest path problem, or APSP for short). Given a representation of
the graph as a matrix of weights M, it computes another matrix M&#39;
which represents a graph with the same path lengths and contains the
length of the shortest path between any two vertices i and j. This is
only possible if the graph does not contain any negative cycles.
However, in this case the Floyd-Warshall algorithm will detect the
situation by calculating a negative diagonal entry. This entry
includes a formalization of the algorithm and of these key properties.
The algorithm is refined to an efficient imperative version using the
Imperative Refinement Framework.</description>
    </item>
    <item>
       <title>Probabilistic while loop</title>
              <link>https://www.isa-afp.org/entries/Probabilistic_While.shtml</link>
       <guid>https://www.isa-afp.org/entries/Probabilistic_While.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
This AFP entry defines a probabilistic while operator based on
sub-probability mass functions and formalises zero-one laws and variant
rules for probabilistic loop termination. As applications, we
implement probabilistic algorithms for the Bernoulli, geometric and
arbitrary uniform distributions that only use fair coin flips, and
prove them correct and terminating with probability 1.</description>
    </item>
    <item>
       <title>Effect polymorphism in higher-order logic</title>
              <link>https://www.isa-afp.org/entries/Monomorphic_Monad.shtml</link>
       <guid>https://www.isa-afp.org/entries/Monomorphic_Monad.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The notion of a monad cannot be expressed within higher-order logic
(HOL) due to type system restrictions. We show that if a monad is used
with values of only one type, this notion can be formalised in HOL.
Based on this idea, we develop a library of effect specifications and
implementations of monads and monad transformers. Hence, we can
abstract over the concrete monad in HOL definitions and thus use the
same definition for different (combinations of) effects. We illustrate
the usefulness of effect polymorphism with a monadic interpreter for a
simple language.</description>
    </item>
    <item>
       <title>Monad normalisation</title>
              <link>https://www.isa-afp.org/entries/Monad_Normalisation.shtml</link>
       <guid>https://www.isa-afp.org/entries/Monad_Normalisation.shtml</guid>
       <dc:creator> Joshua Schneider, Manuel Eberl, Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
The usual monad laws can directly be used as rewrite rules for Isabelle’s
simplifier to normalise monadic HOL terms and decide equivalences.
In a commutative monad, however, the commutativity law is a
higher-order permutative rewrite rule that makes the simplifier loop.
This AFP entry implements a simproc that normalises monadic
expressions in commutative monads using ordered rewriting. The
simproc can also permute computations across control operators like if
and case.</description>
    </item>
    <item>
       <title>Game-based cryptography in HOL</title>
              <link>https://www.isa-afp.org/entries/Game_Based_Crypto.shtml</link>
       <guid>https://www.isa-afp.org/entries/Game_Based_Crypto.shtml</guid>
       <dc:creator> Andreas Lochbihler, S. Reza Sefidgar, Bhargav Bhatt       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;In this AFP entry, we show how to specify game-based cryptographic
security notions and formally prove secure several cryptographic
constructions from the literature using the CryptHOL framework. Among
others, we formalise the notions of a random oracle, a pseudo-random
function, an unpredictable function, and of encryption schemes that are
indistinguishable under chosen plaintext and/or ciphertext attacks. We
prove the random-permutation/random-function switching lemma, security
of the Elgamal and hashed Elgamal public-key encryption scheme and
correctness and security of several constructions with pseudo-random
functions.
&lt;/p&gt;&lt;p&gt;Our proofs follow the game-hopping style advocated by
Shoup and Bellare and Rogaway, from which most of the examples have
been taken. We generalise some of their results such that they can be
reused in other proofs. Thanks to CryptHOL&#39;s integration with
Isabelle&#39;s parametricity infrastructure, many simple hops are easily
justified using the theory of representation independence.&lt;/p&gt;</description>
    </item>
    <item>
       <title>CryptHOL</title>
              <link>https://www.isa-afp.org/entries/CryptHOL.shtml</link>
       <guid>https://www.isa-afp.org/entries/CryptHOL.shtml</guid>
       <dc:creator> Andreas Lochbihler       </dc:creator>
       <pubDate>05 May 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;CryptHOL provides a framework for formalising cryptographic arguments
in Isabelle/HOL. It shallowly embeds a probabilistic functional
programming language in higher order logic. The language features
monadic sequencing, recursion, random sampling, failures and failure
handling, and black-box access to oracles. Oracles are probabilistic
functions which maintain hidden state between different invocations.
All operators are defined in the new semantic domain of
generative probabilistic values, a codatatype. We derive proof rules for
the operators and establish a connection with the theory of relational
parametricity. Thus, the resuting proofs are trustworthy and
comprehensible, and the framework is extensible and widely applicable.
&lt;/p&gt;&lt;p&gt;
The framework is used in the accompanying AFP entry &#34;Game-based
Cryptography in HOL&#34;. There, we show-case our framework by formalizing
different game-based proofs from the literature. This formalisation
continues the work described in the author&#39;s ESOP 2016 paper.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Monoidal Categories</title>
              <link>https://www.isa-afp.org/entries/MonoidalCategory.shtml</link>
       <guid>https://www.isa-afp.org/entries/MonoidalCategory.shtml</guid>
       <dc:creator> Eugene W. Stark       </dc:creator>
       <pubDate>04 May 2017 00:00:00 +0000</pubDate>
       <description>
Building on the formalization of basic category theory set out in the
author&#39;s previous AFP article, the present article formalizes
some basic aspects of the theory of monoidal categories. Among the
notions defined here are monoidal category, monoidal functor, and
equivalence of monoidal categories. The main theorems formalized are
MacLane&#39;s coherence theorem and the constructions of the free
monoidal category and free strict monoidal category generated by a
given category.  The coherence theorem is proved syntactically, using
a structurally recursive approach to reduction of terms that might
have some novel aspects. We also give proofs of some results given by
Etingof et al, which may prove useful in a formal setting. In
particular, we show that the left and right unitors need not be taken
as given data in the definition of monoidal category, nor does the
definition of monoidal functor need to take as given a specific
isomorphism expressing the preservation of the unit object. Our
definitions of monoidal category and monoidal functor are stated so as
to take advantage of the economy afforded by these facts.</description>
    </item>
    <item>
       <title>Types, Tableaus and Gödel’s God in Isabelle/HOL</title>
              <link>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.shtml</link>
       <guid>https://www.isa-afp.org/entries/Types_Tableaus_and_Goedels_God.shtml</guid>
       <dc:creator> David Fuenmayor, Christoph Benzmüller       </dc:creator>
       <pubDate>01 May 2017 00:00:00 +0000</pubDate>
       <description>
A computer-formalisation of the essential parts of Fitting&#39;s
textbook &#34;Types, Tableaus and Gödel&#39;s God&#34; in
Isabelle/HOL is presented. In particular, Fitting&#39;s (and
Anderson&#39;s) variant of the ontological argument is verified and
confirmed. This variant avoids the modal collapse, which has been
criticised as an undesirable side-effect of Kurt Gödel&#39;s (and
Dana Scott&#39;s) versions of the ontological argument.
Fitting&#39;s work is employing an intensional higher-order modal
logic, which we shallowly embed here in classical higher-order logic.
We then utilize the embedded logic for the formalisation of
Fitting&#39;s argument. (See also the earlier AFP entry ``Gödel&#39;s God in Isabelle/HOL&#39;&#39;.)</description>
    </item>
    <item>
       <title>Local Lexing</title>
              <link>https://www.isa-afp.org/entries/LocalLexing.shtml</link>
       <guid>https://www.isa-afp.org/entries/LocalLexing.shtml</guid>
       <dc:creator> Steven Obua       </dc:creator>
       <pubDate>28 Apr 2017 00:00:00 +0000</pubDate>
       <description>
This formalisation accompanies the paper &lt;a
href=&#34;https://arxiv.org/abs/1702.03277&#34;&gt;Local
Lexing&lt;/a&gt; which introduces a novel parsing concept of the same
name. The paper also gives a high-level algorithm for local lexing as
an extension of Earley&#39;s algorithm. This formalisation proves the
algorithm to be correct with respect to its local lexing semantics. As
a special case, this formalisation thus also contains a proof of the
correctness of Earley&#39;s algorithm. The paper contains a short
outline of how this formalisation is organised.</description>
    </item>
    <item>
       <title>Constructor Functions</title>
              <link>https://www.isa-afp.org/entries/Constructor_Funs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Constructor_Funs.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>19 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, constructor applications have to be fully
saturated. That means that for constructor calls occuring as arguments
to higher-order functions, synthetic lambdas have to be inserted. This
entry provides tooling to avoid this construction altogether by
introducing constructor functions.</description>
    </item>
    <item>
       <title>Lazifying case constants</title>
              <link>https://www.isa-afp.org/entries/Lazy_Case.shtml</link>
       <guid>https://www.isa-afp.org/entries/Lazy_Case.shtml</guid>
       <dc:creator> Lars Hupel       </dc:creator>
       <pubDate>18 Apr 2017 00:00:00 +0000</pubDate>
       <description>
Isabelle&#39;s code generator performs various adaptations for target
languages. Among others, case statements are printed as match
expressions. Internally, this is a sophisticated procedure, because in
HOL, case statements are represented as nested calls to the case
combinators as generated by the datatype package. Furthermore, the
procedure relies on laziness of match expressions in the target
language, i.e., that branches guarded by patterns that fail to match
are not evaluated. Similarly, &lt;tt&gt;if-then-else&lt;/tt&gt; is
printed to the corresponding construct in the target language. This
entry provides tooling to replace these special cases in the code
generator by ignoring these target language features, instead printing
case expressions and &lt;tt&gt;if-then-else&lt;/tt&gt; as functions.</description>
    </item>
    <item>
       <title>Subresultants</title>
              <link>https://www.isa-afp.org/entries/Subresultants.shtml</link>
       <guid>https://www.isa-afp.org/entries/Subresultants.shtml</guid>
       <dc:creator> Sebastiaan Joosten, René Thiemann, Akihisa Yamada       </dc:creator>
       <pubDate>06 Apr 2017 00:00:00 +0000</pubDate>
       <description>
We formalize the theory of subresultants and the subresultant
polynomial remainder sequence as described by Brown and Traub. As a
result, we obtain efficient certified algorithms for computing the
resultant and the greatest common divisor of polynomials.</description>
    </item>
    <item>
       <title>Expected Shape of Random Binary Search Trees</title>
              <link>https://www.isa-afp.org/entries/Random_BSTs.shtml</link>
       <guid>https://www.isa-afp.org/entries/Random_BSTs.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>04 Apr 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This entry contains proofs for the textbook results about the
distributions of the height and internal path length of random binary
search trees (BSTs), i.&amp;thinsp;e. BSTs that are formed by taking
an empty BST and inserting elements from a fixed set in random
order.&lt;/p&gt;  &lt;p&gt;In particular, we prove a logarithmic upper
bound on the expected height and the &lt;em&gt;Θ(n log n)&lt;/em&gt;
closed-form solution for the expected internal path length in terms of
the harmonic numbers. We also show how the internal path length
relates to the average-case cost of a lookup in a BST.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The number of comparisons in QuickSort</title>
              <link>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</link>
       <guid>https://www.isa-afp.org/entries/Quick_Sort_Cost.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;We give a formal proof of the well-known results about the
number of comparisons performed by two variants of QuickSort: first,
the expected number of comparisons of randomised QuickSort
(i.&amp;thinsp;e.&amp;nbsp;QuickSort with random pivot choice) is
&lt;em&gt;2&amp;thinsp;(n+1)&amp;thinsp;H&lt;sub&gt;n&lt;/sub&gt; -
4&amp;thinsp;n&lt;/em&gt;, which is asymptotically equivalent to
&lt;em&gt;2&amp;thinsp;n ln n&lt;/em&gt;; second, the number of
comparisons performed by the classic non-randomised QuickSort has the
same distribution in the average case as the randomised one.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Lower bound on comparison-based sorting algorithms</title>
              <link>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</link>
       <guid>https://www.isa-afp.org/entries/Comparison_Sort_Lower_Bound.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>15 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This article contains a formal proof of the well-known fact
that number of comparisons that a comparison-based sorting algorithm
needs to perform to sort a list of length &lt;em&gt;n&lt;/em&gt; is at
least &lt;em&gt;log&lt;sub&gt;2&lt;/sub&gt;&amp;nbsp;(n!)&lt;/em&gt;
in the worst case, i.&amp;thinsp;e.&amp;nbsp;&lt;em&gt;Ω(n log
n)&lt;/em&gt;.&lt;/p&gt;  &lt;p&gt;For this purpose, a shallow
embedding for comparison-based sorting algorithms is defined: a
sorting algorithm is a recursive datatype containing either a HOL
function or a query of a comparison oracle with a continuation
containing the remaining computation. This makes it possible to force
the algorithm to use only comparisons and to track the number of
comparisons made.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Euler–MacLaurin Formula</title>
              <link>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</link>
       <guid>https://www.isa-afp.org/entries/Euler_MacLaurin.shtml</guid>
       <dc:creator> Manuel Eberl       </dc:creator>
       <pubDate>10 Mar 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;The Euler-MacLaurin formula relates the value of a
discrete sum to that of the corresponding integral in terms of the
derivatives at the borders of the summation and a remainder term.
Since the remainder term is often very small as the summation bounds
grow, this can be used to compute asymptotic expansions for
sums.&lt;/p&gt;  &lt;p&gt;This entry contains a proof of this formula
for functions from the reals to an arbitrary Banach space. Two
variants of the formula are given: the standard textbook version and a
variant outlined in &lt;em&gt;Concrete Mathematics&lt;/em&gt; that is
more useful for deriving asymptotic estimates.&lt;/p&gt;  &lt;p&gt;As
example applications, we use that formula to derive the full
asymptotic expansion of the harmonic numbers and the sum of inverse
squares.&lt;/p&gt;</description>
    </item>
    <item>
       <title>The Group Law for Elliptic Curves</title>
              <link>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</link>
       <guid>https://www.isa-afp.org/entries/Elliptic_Curves_Group_Law.shtml</guid>
       <dc:creator> Stefan Berghofer       </dc:creator>
       <pubDate>28 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We prove the group law for elliptic curves in Weierstrass form over
fields of characteristic greater than 2. In addition to affine
coordinates, we also formalize projective coordinates, which allow for
more efficient computations. By specializing the abstract
formalization to prime fields, we can apply the curve operations to
parameters used in standard security protocols.</description>
    </item>
    <item>
       <title>Menger's Theorem</title>
              <link>https://www.isa-afp.org/entries/Menger.shtml</link>
       <guid>https://www.isa-afp.org/entries/Menger.shtml</guid>
       <dc:creator> Christoph Dittmann       </dc:creator>
       <pubDate>26 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We present a formalization of Menger&#39;s Theorem for directed and
undirected graphs in Isabelle/HOL.  This well-known result shows that
if two non-adjacent distinct vertices u, v in a directed graph have no
separator smaller than n, then there exist n internally
vertex-disjoint paths from u to v.  The version for undirected graphs
follows immediately because undirected graphs are a special case of
directed graphs.</description>
    </item>
    <item>
       <title>Differential Dynamic Logic</title>
              <link>https://www.isa-afp.org/entries/Differential_Dynamic_Logic.shtml</link>
       <guid>https://www.isa-afp.org/entries/Differential_Dynamic_Logic.shtml</guid>
       <dc:creator> Brandon Bohrer       </dc:creator>
       <pubDate>13 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We formalize differential dynamic logic, a logic for proving
properties of hybrid systems. The proof calculus in this formalization
is based on the uniform substitution principle. We show it is sound
with respect to our denotational semantics, which provides increased
confidence in the correctness of the KeYmaera X theorem prover based
on this calculus. As an application, we include a proof term checker
embedded in Isabelle/HOL with several example proofs.  Published in:
Brandon Bohrer, Vincent Rahli, Ivana Vukotic, Marcus Völp, André
Platzer: Formally verified differential dynamic logic. CPP 2017.</description>
    </item>
    <item>
       <title>Abstract Soundness</title>
              <link>https://www.isa-afp.org/entries/Abstract_Soundness.shtml</link>
       <guid>https://www.isa-afp.org/entries/Abstract_Soundness.shtml</guid>
       <dc:creator> Jasmin Christian Blanchette, Andrei Popescu, Dmitriy Traytel       </dc:creator>
       <pubDate>10 Feb 2017 00:00:00 +0000</pubDate>
       <description>
A formalized coinductive account of the abstract development of
Brotherston, Gorogiannis, and Petersen [APLAS 2012], in a slightly
more general form since we work with arbitrary infinite proofs, which
may be acyclic. This work is described in detail in an article by the
authors, published in 2017 in the &lt;em&gt;Journal of Automated
Reasoning&lt;/em&gt;. The abstract proof can be instantiated for
various formalisms, including first-order logic with inductive
predicates.</description>
    </item>
    <item>
       <title>Stone Relation Algebras</title>
              <link>https://www.isa-afp.org/entries/Stone_Relation_Algebras.shtml</link>
       <guid>https://www.isa-afp.org/entries/Stone_Relation_Algebras.shtml</guid>
       <dc:creator> Walter Guttmann       </dc:creator>
       <pubDate>07 Feb 2017 00:00:00 +0000</pubDate>
       <description>
We develop Stone relation algebras, which generalise relation algebras
by replacing the underlying Boolean algebra structure with a Stone
algebra. We show that finite matrices over extended real numbers form
an instance. As a consequence, relation-algebraic concepts and methods
can be used for reasoning about weighted graphs. We also develop a
fixpoint calculus and apply it to compare different definitions of
reflexive-transitive closures in semirings.</description>
    </item>
    <item>
       <title>Refining Authenticated Key Agreement with Strong Adversaries</title>
              <link>https://www.isa-afp.org/entries/Key_Agreement_Strong_Adversaries.shtml</link>
       <guid>https://www.isa-afp.org/entries/Key_Agreement_Strong_Adversaries.shtml</guid>
       <dc:creator> Joseph Lallemand, Christoph Sprenger       </dc:creator>
       <pubDate>31 Jan 2017 00:00:00 +0000</pubDate>
       <description>
We develop a family of key agreement protocols that are correct by
construction. Our work substantially extends prior work on developing
security protocols by refinement. First, we strengthen the adversary
by allowing him to compromise different resources of protocol
participants, such as their long-term keys or their session keys. This
enables the systematic development of protocols that ensure strong
properties such as perfect forward secrecy. Second, we broaden the
class of protocols supported to include those with non-atomic keys and
equationally defined cryptographic operators. We use these extensions
to develop key agreement protocols including signed Diffie-Hellman and
the core of IKEv1 and SKEME.</description>
    </item>
    <item>
       <title>Bernoulli Numbers</title>
              <link>https://www.isa-afp.org/entries/Bernoulli.shtml</link>
       <guid>https://www.isa-afp.org/entries/Bernoulli.shtml</guid>
       <dc:creator> Lukas Bulwahn, Manuel Eberl       </dc:creator>
       <pubDate>24 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;Bernoulli numbers were first discovered in the closed-form
expansion of the sum 1&lt;sup&gt;m&lt;/sup&gt; +
2&lt;sup&gt;m&lt;/sup&gt; + &amp;hellip; + n&lt;sup&gt;m&lt;/sup&gt;
for a fixed m and appear in many other places. This entry provides
three different definitions for them: a recursive one, an explicit
one, and one through their exponential generating function.&lt;/p&gt;
&lt;p&gt;In addition, we prove some basic facts, e.g. their relation
to sums of powers of integers and that all odd Bernoulli numbers
except the first are zero. We also prove the correctness of the
Akiyama&amp;ndash;Tanigawa algorithm for computing Bernoulli numbers
with reasonable efficiency, and we define the periodic Bernoulli
polynomials (which appear e.g. in the Euler&amp;ndash;MacLaurin
summation formula and the expansion of the log-Gamma function) and
prove their basic properties.&lt;/p&gt;</description>
    </item>
    <item>
       <title>Minimal Static Single Assignment Form</title>
              <link>https://www.isa-afp.org/entries/Minimal_SSA.shtml</link>
       <guid>https://www.isa-afp.org/entries/Minimal_SSA.shtml</guid>
       <dc:creator> Max Wagner, Denis Lohner       </dc:creator>
       <pubDate>17 Jan 2017 00:00:00 +0000</pubDate>
       <description>
&lt;p&gt;This formalization is an extension to &lt;a
href=&#34;https://www.isa-afp.org/entries/Formal_SSA.shtml&#34;&gt;&#34;Verified
Construction of Static Single Assignment Form&#34;&lt;/a&gt;. In
their work, the authors have shown that &lt;a
href=&#34;http://dx.doi.org/10.1007/978-3-642-37051-9_6&#34;&gt;Braun
et al.&#39;s static single assignment (SSA) construction
algorithm&lt;/a&gt; produces minimal SSA form for input programs with
a reducible control flow graph (CFG). However Braun et al. also
proposed an extension to their algorithm that they claim produces
minimal SSA form even for irreducible CFGs.&lt;br&gt; In this
formalization we support that claim by giving a mechanized proof.
&lt;/p&gt;
&lt;p&gt;As the extension of Braun et al.&#39;s algorithm
aims for removing so-called redundant strongly connected components of
phi functions, we show that this suffices to guarantee minimality
according to &lt;a href=&#34;http://dx.doi.org/10.1145/115372.115320&#34;&gt;Cytron et
al.&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
