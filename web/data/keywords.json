[{"keyword": "-automata states"},
{"keyword": "-dimensional cube"},
{"keyword": "-factor approximation"},
{"keyword": "-free higher-order terms"},
{"keyword": "0-1-2-principle"},
{"keyword": "1 delta cdots delta"},
{"keyword": "1 infty"},
{"keyword": "1 infty frac"},
{"keyword": "1 infty left"},
{"keyword": "1 infty sigma_ alpha"},
{"keyword": "1 involving"},
{"keyword": "1 javier esparza"},
{"keyword": "1 n-1 frac b_"},
{"keyword": "1 polygonal numbers"},
{"keyword": "1007 978-3-030-90138-7_2"},
{"keyword": "1093 logcom exad013"},
{"keyword": "10th problem"},
{"keyword": "128bit words"},
{"keyword": "13 binary relations"},
{"keyword": "16th international symposium"},
{"keyword": "18th century"},
{"keyword": "19th century number theory"},
{"keyword": "19th international symposium"},
{"keyword": "2 rsa laboratories"},
{"keyword": "2 scalar product"},
{"keyword": "2-kleene algebras"},
{"keyword": "2022 lecture notes"},
{"keyword": "22nd formal methods"},
{"keyword": "253--269 cpp-2016 peter lammich"},
{"keyword": "2nd international workshop"},
{"keyword": "3-term arithmetic progressions"},
{"keyword": "32-bit signed word"},
{"keyword": "32bit machine words"},
{"keyword": "34th ifip international conference"},
{"keyword": "3rd edition"},
{"keyword": "45th theorem"},
{"keyword": "55th theorem"},
{"keyword": "5th postulate"},
{"keyword": "64-bit bases"},
{"keyword": "8th event"},
{"keyword": "9th international joint conference"},
{"keyword": "a-priori bound"},
{"keyword": "a-priori detect"},
{"keyword": "a_1 ldots a_n"},
{"keyword": "a_n leq tfrac 1"},
{"keyword": "ab leq int_0"},
{"keyword": "abc"},
{"keyword": "abductive reasoning"},
{"keyword": "abelian group"},
{"keyword": "abortable linearizable module automaton"},
{"keyword": "abrupt termination"},
{"keyword": "absolute positiveness"},
{"keyword": "abstract academic models"},
{"keyword": "abstract algebra"},
{"keyword": "abstract algebraic structure satisfying"},
{"keyword": "abstract algorithm working"},
{"keyword": "abstract algorithms closely"},
{"keyword": "abstract automata types"},
{"keyword": "abstract bnfccs similar"},
{"keyword": "abstract cfg"},
{"keyword": "abstract characterization"},
{"keyword": "abstract compiler working"},
{"keyword": "abstract completeness theories"},
{"keyword": "abstract convergence theorem"},
{"keyword": "abstract cryptography"},
{"keyword": "abstract data structures"},
{"keyword": "abstract data type"},
{"keyword": "abstract datatypes"},
{"keyword": "abstract execution model"},
{"keyword": "abstract file represented"},
{"keyword": "abstract first-order prover"},
{"keyword": "abstract formalization"},
{"keyword": "abstract functions modelled directly"},
{"keyword": "abstract hilbert-style"},
{"keyword": "abstract interface"},
{"keyword": "abstract interpreter operate"},
{"keyword": "abstract ledger supporting"},
{"keyword": "abstract level"},
{"keyword": "abstract objects"},
{"keyword": "abstract objects theory"},
{"keyword": "abstract perspective enables"},
{"keyword": "abstract program"},
{"keyword": "abstract proof"},
{"keyword": "abstract property"},
{"keyword": "abstract reasoning"},
{"keyword": "abstract reference specification"},
{"keyword": "abstract representation"},
{"keyword": "abstract results"},
{"keyword": "abstract rewrite system"},
{"keyword": "abstract rewriting"},
{"keyword": "abstract separation algebra"},
{"keyword": "abstract separation logic"},
{"keyword": "abstract simplicial complexes"},
{"keyword": "abstract soundness"},
{"keyword": "abstract space"},
{"keyword": "abstract specification"},
{"keyword": "abstract structures"},
{"keyword": "abstract syntax"},
{"keyword": "abstract syntax tree generated"},
{"keyword": "abstract theory"},
{"keyword": "abstract time domain"},
{"keyword": "abstract transition system context"},
{"keyword": "abstract type"},
{"keyword": "abstract version"},
{"keyword": "academic partners"},
{"keyword": "academic press"},
{"keyword": "acceptance rejection decisions"},
{"keyword": "accepted languages coincide"},
{"keyword": "access windows"},
{"keyword": "accessed independently"},
{"keyword": "accesses memory locations"},
{"keyword": "accessibility decisions affecting"},
{"keyword": "accommodates partial functions"},
{"keyword": "accommodating arbitrary nominal datatypes"},
{"keyword": "accompanying algebraic laws"},
{"keyword": "accompanying formalisation"},
{"keyword": "accompanying induction invariant rules"},
{"keyword": "accompanying paper"},
{"keyword": "accompanying paper 2"},
{"keyword": "achieve bottom-"},
{"keyword": "achieve compositionality"},
{"keyword": "achieve consensus"},
{"keyword": "achieve high expressiveness"},
{"keyword": "achieving linear time"},
{"keyword": "active domain"},
{"keyword": "active research topic"},
{"keyword": "actual executions"},
{"keyword": "actual sets"},
{"keyword": "actuarial mathematics"},
{"keyword": "ad-hoc approaches"},
{"keyword": "adam betts"},
{"keyword": "adam smith"},
{"keyword": "adapt ctl"},
{"keyword": "adapted deterministic"},
{"keyword": "adapted versions"},
{"keyword": "adapting larry paulson"},
{"keyword": "adaptive state counting"},
{"keyword": "adaptive state counting algorithm"},
{"keyword": "adaptive test cases"},
{"keyword": "added formalisations"},
{"keyword": "adding definitions"},
{"keyword": "adding knuth"},
{"keyword": "adding observation instants"},
{"keyword": "addition theorem"},
{"keyword": "additional assumptions needed"},
{"keyword": "additional control flow analysis"},
{"keyword": "additional convenience"},
{"keyword": "additional domain elements"},
{"keyword": "additional effort"},
{"keyword": "additional extensions"},
{"keyword": "additional indeterminate"},
{"keyword": "additional iteration laws"},
{"keyword": "additional non-deterministic choice command"},
{"keyword": "additional notions"},
{"keyword": "additional operations"},
{"keyword": "additional operations subject"},
{"keyword": "additional password"},
{"keyword": "additional properties related"},
{"keyword": "additional relations"},
{"keyword": "additional results"},
{"keyword": "additional theorems"},
{"keyword": "additional theory"},
{"keyword": "additional tracking"},
{"keyword": "additive combinatorics"},
{"keyword": "additive combinatorics due"},
{"keyword": "additive secret sharing scheme"},
{"keyword": "additive subgroup"},
{"keyword": "additively idempotent semirings"},
{"keyword": "adequacy proof"},
{"keyword": "adjoint functors"},
{"keyword": "adjoint functors preserve limits"},
{"keyword": "adjunctions"},
{"keyword": "advanced algorithms"},
{"keyword": "advanced binding constructs"},
{"keyword": "advanced replacement"},
{"keyword": "advanced results"},
{"keyword": "advanced set-theoretic concepts"},
{"keyword": "affect execution time"},
{"keyword": "affine arithmetic"},
{"keyword": "affine scheme"},
{"keyword": "affine systems"},
{"keyword": "aforementioned consensus problem"},
{"keyword": "aforementioned mathematical structures"},
{"keyword": "aforesaid task"},
{"keyword": "afp"},
{"keyword": "afp article amortized complexity"},
{"keyword": "afp article monadification"},
{"keyword": "afp entries"},
{"keyword": "afp entries goedel_hfset_semantic"},
{"keyword": "afp entry"},
{"keyword": "afp entry abstract completeness"},
{"keyword": "afp entry accessible"},
{"keyword": "afp entry amortized complexity"},
{"keyword": "afp entry bnf operations"},
{"keyword": "afp entry category theory"},
{"keyword": "afp entry complex geometry"},
{"keyword": "afp entry core dom"},
{"keyword": "afp entry discrete summation"},
{"keyword": "afp entry dom_components"},
{"keyword": "afp entry dynamic architectures"},
{"keyword": "afp entry eval_fo"},
{"keyword": "afp entry focusstreamscasestudies-afp"},
{"keyword": "afp entry implements"},
{"keyword": "afp entry metatheory"},
{"keyword": "afp entry ordered_resultion_prover"},
{"keyword": "afp entry robinson_arithmetic"},
{"keyword": "afp entry saturation_framework"},
{"keyword": "afp entry simple_firewall"},
{"keyword": "afp package"},
{"keyword": "afp representation"},
{"keyword": "agm operators"},
{"keyword": "ahmed bouajjani"},
{"keyword": "aircraft cabin data network"},
{"keyword": "akra-bazzi method based"},
{"keyword": "akra-bazzi theorem"},
{"keyword": "alain aspect"},
{"keyword": "albeit translated"},
{"keyword": "alberto griggio"},
{"keyword": "alexander birch jensen"},
{"keyword": "alexander wenner"},
{"keyword": "algebra universalis"},
{"keyword": "algebraic"},
{"keyword": "algebraic approach"},
{"keyword": "algebraic closure"},
{"keyword": "algebraic confluence proofs"},
{"keyword": "algebraic formalization end"},
{"keyword": "algebraic framework"},
{"keyword": "algebraic geometry"},
{"keyword": "algebraic geometry culminating"},
{"keyword": "algebraic hierarchy"},
{"keyword": "algebraic laws"},
{"keyword": "algebraic number executable"},
{"keyword": "algebraic number implementation"},
{"keyword": "algebraic numbers"},
{"keyword": "algebraic numbers beta_1"},
{"keyword": "algebraic point"},
{"keyword": "algebraic proof"},
{"keyword": "algebraic semantics"},
{"keyword": "algebraic setting"},
{"keyword": "algebraic structure"},
{"keyword": "algebraic structures based"},
{"keyword": "algebraically closed"},
{"keyword": "algebraically closed field"},
{"keyword": "algebraically independent"},
{"keyword": "algebras based"},
{"keyword": "algorithm"},
{"keyword": "algorithm aims"},
{"keyword": "algorithm decodes correctly"},
{"keyword": "algorithm enumerates rooted"},
{"keyword": "algorithm enumerating"},
{"keyword": "algorithm factors polynomials"},
{"keyword": "algorithm generates posix"},
{"keyword": "algorithm meets schneider"},
{"keyword": "algorithm multiple times independently"},
{"keyword": "algorithm proceeds"},
{"keyword": "algorithm tolerates"},
{"keyword": "algorithm top-"},
{"keyword": "algorithmic specification"},
{"keyword": "algorithms ---"},
{"keyword": "algorithms computing"},
{"keyword": "all-pairs shortest path problem"},
{"keyword": "all-pairs shortest paths problem"},
{"keyword": "allocation function allocates goods"},
{"keyword": "allowed accesses"},
{"keyword": "allowed nominals"},
{"keyword": "allowing assertions"},
{"keyword": "allowing formal reasoning"},
{"keyword": "alpern"},
{"keyword": "alpha"},
{"keyword": "alpha-beta pruning"},
{"keyword": "alpha-equivalence classes"},
{"keyword": "alpha_1 ldots beta_n"},
{"keyword": "alphabet letters"},
{"keyword": "alphabetised relational calculus"},
{"keyword": "alternate binomial theorem statement"},
{"keyword": "alternating structure"},
{"keyword": "alternative definition"},
{"keyword": "alternative interface"},
{"keyword": "alternative interpretation"},
{"keyword": "alternative proof"},
{"keyword": "alternative version"},
{"keyword": "alternatives"},
{"keyword": "alwen tiu"},
{"keyword": "amicable numbers"},
{"keyword": "amir hossein parvardi"},
{"keyword": "amortized complexity"},
{"keyword": "amortized logarithmic complexity"},
{"keyword": "amortized time complexity"},
{"keyword": "ample set condition"},
{"keyword": "analogous languages"},
{"keyword": "analogous problem arises"},
{"keyword": "analyse system structure oriented"},
{"keyword": "analysing replication algorithms"},
{"keyword": "analytic combinatorics"},
{"keyword": "analytic completeness proof covers"},
{"keyword": "analytic continuation"},
{"keyword": "analytic dirichlet series"},
{"keyword": "analytic function"},
{"keyword": "analytic number theory"},
{"keyword": "analytic number theory rdquo"},
{"keyword": "analytic proof"},
{"keyword": "analytical arguments"},
{"keyword": "analyze similar algorithms"},
{"keyword": "analyze sufficient conditions"},
{"keyword": "analyzed firewall mdash"},
{"keyword": "ancient greek philosopher eudoxus"},
{"keyword": "anders schlichtkrull"},
{"keyword": "andr platzer"},
{"keyword": "andrei popescu"},
{"keyword": "andrei popescu propose"},
{"keyword": "angelic nondeterministic choices"},
{"keyword": "angles requires solving"},
{"keyword": "annotated commands"},
{"keyword": "anonymous social choice function"},
{"keyword": "appearing numbers"},
{"keyword": "application"},
{"keyword": "application areas"},
{"keyword": "application consumes potential"},
{"keyword": "application programming interface"},
{"keyword": "application scenarios"},
{"keyword": "applications ranging"},
{"keyword": "applications refer"},
{"keyword": "applicative expressions"},
{"keyword": "applicative functor"},
{"keyword": "applicative functors augment computations"},
{"keyword": "applied call-by-"},
{"keyword": "applied non-classical logics 2005"},
{"keyword": "applied relativization"},
{"keyword": "applies induction"},
{"keyword": "apply andy pitts"},
{"keyword": "apply data refinement"},
{"keyword": "apply expander graphs"},
{"keyword": "applying sturm"},
{"keyword": "approach"},
{"keyword": "approach decomposes ltl formulas"},
{"keyword": "approach demonstrates"},
{"keyword": "approach enables easy links"},
{"keyword": "approach preservers"},
{"keyword": "approach produced"},
{"keyword": "approach supports reachability goals"},
{"keyword": "approval ballots"},
{"keyword": "approve multiple parties"},
{"keyword": "approximate model counting"},
{"keyword": "approximate solution"},
{"keyword": "approximating real roots"},
{"keyword": "approximation algorithm"},
{"keyword": "approximation error"},
{"keyword": "approximation polynomial based"},
{"keyword": "approximation quality solely depends"},
{"keyword": "approximation ratio"},
{"keyword": "approximative version"},
{"keyword": "arbitrarily large girth"},
{"keyword": "arbitrary banach space"},
{"keyword": "arbitrary banach spaces equipped"},
{"keyword": "arbitrary classes"},
{"keyword": "arbitrary data"},
{"keyword": "arbitrary dimension"},
{"keyword": "arbitrary equation systems"},
{"keyword": "arbitrary events"},
{"keyword": "arbitrary fields"},
{"keyword": "arbitrary higher-order contexts"},
{"keyword": "arbitrary infinite proofs"},
{"keyword": "arbitrary intervals"},
{"keyword": "arbitrary length"},
{"keyword": "arbitrary linear order"},
{"keyword": "arbitrary linearly-ordered integrity domains"},
{"keyword": "arbitrary monoidal category"},
{"keyword": "arbitrary natural sets"},
{"keyword": "arbitrary network topologies"},
{"keyword": "arbitrary nominal sets"},
{"keyword": "arbitrary number"},
{"keyword": "arbitrary rc query"},
{"keyword": "arbitrary ring"},
{"keyword": "arbitrary security lattices"},
{"keyword": "arbitrary sets"},
{"keyword": "arbitrary size"},
{"keyword": "arbitrary transition systems"},
{"keyword": "arbitrary tychonov space"},
{"keyword": "arbitrary uniform distributions"},
{"keyword": "arbitrary univariate polynomials"},
{"keyword": "arbitrary user"},
{"keyword": "arbitrary user-"},
{"keyword": "architectural design patterns"},
{"keyword": "architectural operators"},
{"keyword": "arctic interpretations"},
{"keyword": "arctic semirings satisfy"},
{"keyword": "argument"},
{"keyword": "argument functions"},
{"keyword": "arithmetic logical operations"},
{"keyword": "arithmetic progression"},
{"keyword": "arithmetic type class hierarchy"},
{"keyword": "arithmetize register machines"},
{"keyword": "array operations seamlessly integrate"},
{"keyword": "array shuffling protocol"},
{"keyword": "arrow composition --"},
{"keyword": "arrow-debreu model"},
{"keyword": "art formal verification methods"},
{"keyword": "article"},
{"keyword": "article added additional material"},
{"keyword": "article added material"},
{"keyword": "article attempts"},
{"keyword": "article barbin-le rest"},
{"keyword": "article builds"},
{"keyword": "article collects formalisations"},
{"keyword": "article knight"},
{"keyword": "article set-theoretical foundations"},
{"keyword": "article titled"},
{"keyword": "articles ai-communications aic764"},
{"keyword": "artificial general intelligence"},
{"keyword": "artificial intelligence"},
{"keyword": "ascending priority"},
{"keyword": "aspect obtained experimentally"},
{"keyword": "assembly-to-machine step"},
{"keyword": "assertion failure"},
{"keyword": "assertion semantics unifies semantic"},
{"keyword": "assertoric syllogistic"},
{"keyword": "assigned multiple seats"},
{"keyword": "association lists"},
{"keyword": "associative lists"},
{"keyword": "assorted fixed-point theorems"},
{"keyword": "assuming access"},
{"keyword": "assuming soundness"},
{"keyword": "astronomically huge"},
{"keyword": "asymptotic approximation"},
{"keyword": "asymptotic bounds"},
{"keyword": "asymptotic complexity"},
{"keyword": "asymptotic expansions"},
{"keyword": "asymptotic relation"},
{"keyword": "asymptotically equivalent"},
{"keyword": "asymptotically matches"},
{"keyword": "asymptotically optimal space usage"},
{"keyword": "asynchronously communicating nodes"},
{"keyword": "atkinson lemma"},
{"keyword": "atomic elements"},
{"keyword": "atomic formulas"},
{"keyword": "atomic operations race"},
{"keyword": "atomic predicates"},
{"keyword": "attack tree validity"},
{"keyword": "atva2021 jss 21"},
{"keyword": "augustin louis cauchy"},
{"keyword": "austrian science fund"},
{"keyword": "authenticated data structures"},
{"keyword": "authentication mechanisms employed call"},
{"keyword": "author merz 1998"},
{"keyword": "author x27"},
{"keyword": "authorized path"},
{"keyword": "authors upcoming dissertation"},
{"keyword": "autocorres"},
{"keyword": "autocorres tool"},
{"keyword": "automata classes"},
{"keyword": "automata library"},
{"keyword": "automate canonical tasks"},
{"keyword": "automate transports"},
{"keyword": "automated circuit verification"},
{"keyword": "automated proof tactics"},
{"keyword": "automated proof techniques"},
{"keyword": "automated reasoning"},
{"keyword": "automated reasoning 52"},
{"keyword": "automated reasoning 66"},
{"keyword": "automated reasoning framework"},
{"keyword": "automated reasoning sch18"},
{"keyword": "automated reasoning tools"},
{"keyword": "automated tactic support"},
{"keyword": "automated theorem prover"},
{"keyword": "automated theorem proving"},
{"keyword": "automated-theorem-proving assistant"},
{"keyword": "automatic data refinement"},
{"keyword": "automatic differentiation"},
{"keyword": "automatic instantiation"},
{"keyword": "automatic methods"},
{"keyword": "automatic refinement framework"},
{"keyword": "automatic search"},
{"keyword": "automatic tactics"},
{"keyword": "automatic theorem prover"},
{"keyword": "automatically calculated"},
{"keyword": "automatically derive"},
{"keyword": "automatically derive restrictions"},
{"keyword": "automatically deriving instances"},
{"keyword": "automatically executed programs"},
{"keyword": "automatically extracted scala code"},
{"keyword": "automatically generate proofs"},
{"keyword": "automatically refines algorithms"},
{"keyword": "automatically transferable"},
{"keyword": "automation mechanisms"},
{"keyword": "automatize canonical tasks"},
{"keyword": "automotive-gateway system"},
{"keyword": "autonomous systems"},
{"keyword": "autonomous vehicle"},
{"keyword": "autonomous vehicle liable"},
{"keyword": "autonomous vehicle manufacturers"},
{"keyword": "autoref tool"},
{"keyword": "auxiliary labels"},
{"keyword": "auxiliary triangle inequality"},
{"keyword": "auxiliary type"},
{"keyword": "average case"},
{"keyword": "average degree"},
{"keyword": "average number"},
{"keyword": "average-case cost"},
{"keyword": "average-case quality"},
{"keyword": "averaging theorem"},
{"keyword": "avl trees"},
{"keyword": "avoid carrying"},
{"keyword": "avoid cascading linking"},
{"keyword": "avoid circular reasoning"},
{"keyword": "avoid correctness issues"},
{"keyword": "avoid unnecessary evaluations"},
{"keyword": "avoiding quantification"},
{"keyword": "avoids difficulties"},
{"keyword": "awn models comprise"},
{"keyword": "awomir ko x0142"},
{"keyword": "axiom"},
{"keyword": "axiom class"},
{"keyword": "axiom system"},
{"keyword": "axiomatic characterization"},
{"keyword": "axiomatic constructor classes"},
{"keyword": "axiomatic definition"},
{"keyword": "axiomatic framework"},
{"keyword": "axiomatic network model"},
{"keyword": "axiomatic system"},
{"keyword": "axiomatic theory"},
{"keyword": "axiomatic type classes"},
{"keyword": "axiomatize term-for-variable substitution"},
{"keyword": "axioms constructed"},
{"keyword": "axioms proposed"},
{"keyword": "axioms set proposed"},
{"keyword": "axioms set suggested"},
{"keyword": "axioms systems"},
{"keyword": "b_n"},
{"keyword": "ba12 mordechai ben-ari"},
{"keyword": "babylonian method"},
{"keyword": "background theory"},
{"keyword": "background theory forall"},
{"keyword": "backward compatibility"},
{"keyword": "backward compatible"},
{"keyword": "backward simulations"},
{"keyword": "bad sequences"},
{"keyword": "balanced incomplete block designs"},
{"keyword": "balanced nature"},
{"keyword": "balog szemeredi gowers theorem"},
{"keyword": "banach space"},
{"keyword": "banach spaces volume"},
{"keyword": "base set"},
{"keyword": "base vectors"},
{"keyword": "basic algebra leading"},
{"keyword": "basic algebraic properties"},
{"keyword": "basic axioms"},
{"keyword": "basic blocks"},
{"keyword": "basic category theory set"},
{"keyword": "basic classical properties"},
{"keyword": "basic concepts"},
{"keyword": "basic concepts cartesian products"},
{"keyword": "basic definitions"},
{"keyword": "basic elements"},
{"keyword": "basic facts"},
{"keyword": "basic features"},
{"keyword": "basic file operations"},
{"keyword": "basic formal framework"},
{"keyword": "basic forward analysis operations"},
{"keyword": "basic framework"},
{"keyword": "basic geometric facts"},
{"keyword": "basic geometric properties"},
{"keyword": "basic graph algorithms"},
{"keyword": "basic graph theory definitions"},
{"keyword": "basic hypergraph hierarchy"},
{"keyword": "basic identities"},
{"keyword": "basic laws"},
{"keyword": "basic linear algebra"},
{"keyword": "basic material"},
{"keyword": "basic modal logics"},
{"keyword": "basic model"},
{"keyword": "basic notions"},
{"keyword": "basic number-theoretic functions related"},
{"keyword": "basic part"},
{"keyword": "basic path manipulation rules"},
{"keyword": "basic properties"},
{"keyword": "basic properties ndash"},
{"keyword": "basic randomised social choice"},
{"keyword": "basic result"},
{"keyword": "basic setting"},
{"keyword": "basic superposition calculus"},
{"keyword": "basic theory"},
{"keyword": "basic toolbox"},
{"keyword": "basic topological facts"},
{"keyword": "basic ugraph definition"},
{"keyword": "basis executable code"},
{"keyword": "basis reduction"},
{"keyword": "basis reduction algorithm"},
{"keyword": "bayes theorem"},
{"keyword": "bayesian regression presented"},
{"keyword": "beautiful result"},
{"keyword": "behavior trace assertions"},
{"keyword": "behavior traces"},
{"keyword": "behavioral aspects"},
{"keyword": "behaviorally correct learning"},
{"keyword": "behaviour structure"},
{"keyword": "behaviours"},
{"keyword": "belief change"},
{"keyword": "bell numbers"},
{"keyword": "bell state"},
{"keyword": "ben-ari ba12"},
{"keyword": "benchmark problems"},
{"keyword": "benchmark scripts"},
{"keyword": "bendix orders"},
{"keyword": "berlekamp-zassenhaus algorithm"},
{"keyword": "bernays-tarski axiom system"},
{"keyword": "bernoulli number"},
{"keyword": "beta"},
{"keyword": "beta_0 beta"},
{"keyword": "beta_1"},
{"keyword": "beta_n"},
{"keyword": "beth hintikka style"},
{"keyword": "beth hintikka-style completeness proofs"},
{"keyword": "beukers"},
{"keyword": "bf rts"},
{"keyword": "bf rts dagger"},
{"keyword": "bhavik mehta"},
{"keyword": "bicolano operational semantics"},
{"keyword": "big step semantics"},
{"keyword": "biggest part"},
{"keyword": "bigvee phi"},
{"keyword": "bilinear dominance"},
{"keyword": "binary case"},
{"keyword": "binary code"},
{"keyword": "binary decision diagram"},
{"keyword": "binary decision trees"},
{"keyword": "binary masking"},
{"keyword": "binary multirelations associate elements"},
{"keyword": "binary multirelations form"},
{"keyword": "binary numeral system"},
{"keyword": "binary operators"},
{"keyword": "binary orthogonality"},
{"keyword": "binary relations"},
{"keyword": "binary search tree operations"},
{"keyword": "binary search trees"},
{"keyword": "binary temporal operators"},
{"keyword": "binary tree"},
{"keyword": "binary trees fredman"},
{"keyword": "binding sequences"},
{"keyword": "binding signature"},
{"keyword": "binding structure"},
{"keyword": "bindings-aware induction"},
{"keyword": "binomial heaps"},
{"keyword": "bipartite graph"},
{"keyword": "bird tree"},
{"keyword": "birkhoff theorem"},
{"keyword": "birkhoff-kakutani theorem"},
{"keyword": "bisection square root"},
{"keyword": "bisimilarity coincides"},
{"keyword": "bisimulation equivalence"},
{"keyword": "bisimulation variants"},
{"keyword": "bit ibn qurra"},
{"keyword": "bit manipulations"},
{"keyword": "bit operations"},
{"keyword": "bit simpler"},
{"keyword": "bius transformations"},
{"keyword": "bkr algorithm"},
{"keyword": "black-box traces"},
{"keyword": "blackboard pattern"},
{"keyword": "blockchain pattern"},
{"keyword": "blue colouring"},
{"keyword": "bner bases"},
{"keyword": "bnf case"},
{"keyword": "bnf support"},
{"keyword": "bnf-based datatype package"},
{"keyword": "bnfcc structure"},
{"keyword": "bnfcc theory"},
{"keyword": "bnfccs preserve quotients"},
{"keyword": "bochner integration"},
{"keyword": "bohua zhan"},
{"keyword": "book"},
{"keyword": "book additive number theory"},
{"keyword": "book concrete semantics"},
{"keyword": "book consistency"},
{"keyword": "book dense sphere packings"},
{"keyword": "book first-order logic"},
{"keyword": "book functional data structures"},
{"keyword": "book graph theory"},
{"keyword": "book linear algebra"},
{"keyword": "book markov decision processes"},
{"keyword": "book proof theory"},
{"keyword": "book quantum computation"},
{"keyword": "boolean algebra"},
{"keyword": "boolean algebra type"},
{"keyword": "boolean algebras extended"},
{"keyword": "boolean algebras generalise"},
{"keyword": "boolean connectives"},
{"keyword": "boolean expressions"},
{"keyword": "boolean functions"},
{"keyword": "boolean lists"},
{"keyword": "boolean matrices"},
{"keyword": "boolos curious inference"},
{"keyword": "boolos gave"},
{"keyword": "bor vka"},
{"keyword": "borel algebra"},
{"keyword": "borel-measurable random variables"},
{"keyword": "borrow terminology"},
{"keyword": "bound dependent"},
{"keyword": "bound depends"},
{"keyword": "bound occurrences"},
{"keyword": "bound variables"},
{"keyword": "bounded basic pseudo-hoops"},
{"keyword": "bounded linear functions"},
{"keyword": "bounded model checking"},
{"keyword": "bounded natural functors"},
{"keyword": "bounded number"},
{"keyword": "bounded operators"},
{"keyword": "bounded totally ordered hoops"},
{"keyword": "bounded wajsberg pseudo-hoops"},
{"keyword": "bounded- deducibility security"},
{"keyword": "bounded-deducibility security"},
{"keyword": "bounded-length strings"},
{"keyword": "bounds due"},
{"keyword": "bracket polynomial"},
{"keyword": "branches guarded"},
{"keyword": "braun trees"},
{"keyword": "breeders"},
{"keyword": "brian huffman"},
{"keyword": "bridge definition"},
{"keyword": "british imperial system"},
{"keyword": "broadcast communication"},
{"keyword": "brookes failure-divergence semantics"},
{"keyword": "bst"},
{"keyword": "budan fourier theorem"},
{"keyword": "building"},
{"keyword": "building correct programs working"},
{"keyword": "building high-performance multiprocessor software"},
{"keyword": "butterfly scheme"},
{"keyword": "byte code"},
{"keyword": "byte-level little-endian memory model"},
{"keyword": "bytecode logic"},
{"keyword": "byzantine clock synchronization"},
{"keyword": "byzantine fault-tolerant clock synchronization"},
{"keyword": "c11 syntax deeply integrated"},
{"keyword": "cade 28 paper"},
{"keyword": "cade-27 paper"},
{"keyword": "cakeml abstract syntax trees"},
{"keyword": "cakeml project"},
{"keyword": "calculate sign variations"},
{"keyword": "calculating cauchy indices"},
{"keyword": "calculating operators"},
{"keyword": "calculus exhaustively"},
{"keyword": "calculus immediately implies"},
{"keyword": "calculus ls_ pasl"},
{"keyword": "call arity"},
{"keyword": "call arity analysis"},
{"keyword": "call merkle functors"},
{"keyword": "call path authorization"},
{"keyword": "call return"},
{"keyword": "call risk-free loans"},
{"keyword": "call root-balanced trees"},
{"keyword": "call- return behavior"},
{"keyword": "call-by-"},
{"keyword": "called check monad"},
{"keyword": "called complete sets"},
{"keyword": "called concurrent transition systems"},
{"keyword": "called eudoxus reals"},
{"keyword": "called galois fields"},
{"keyword": "called hol-csp 1"},
{"keyword": "called interval arithmetic"},
{"keyword": "called learnable"},
{"keyword": "called llist_topology"},
{"keyword": "called multi-level syllogistic"},
{"keyword": "called object constraint language"},
{"keyword": "called residuation"},
{"keyword": "called se_step"},
{"keyword": "called separating implication"},
{"keyword": "called substitutive sets"},
{"keyword": "cambridge lecture notes topics"},
{"keyword": "cambridge university press"},
{"keyword": "cambridge university press 2001"},
{"keyword": "cancellative separation algebra"},
{"keyword": "canonical dbm"},
{"keyword": "canonical form"},
{"keyword": "canonical isomorphism"},
{"keyword": "canonical matrix analogue"},
{"keyword": "canonical matrix form"},
{"keyword": "canonical set-theoretic constructions internalized"},
{"keyword": "canonical unification instances"},
{"keyword": "canton protocol"},
{"keyword": "cantor normal form"},
{"keyword": "cantor pairing function"},
{"keyword": "cap mathbb"},
{"keyword": "capture laws"},
{"keyword": "carath odory"},
{"keyword": "cardinal library"},
{"keyword": "cardinality"},
{"keyword": "cardinality facts relevant"},
{"keyword": "cardinality formula assuming"},
{"keyword": "cardinality formulae"},
{"keyword": "cardinality operation counts"},
{"keyword": "cardinality proofs"},
{"keyword": "careful presentation"},
{"keyword": "carefully crafted"},
{"keyword": "carmichael numbers"},
{"keyword": "caro-wei bound"},
{"keyword": "carrier set"},
{"keyword": "cartesian categories"},
{"keyword": "cartesian category"},
{"keyword": "cartesian closed"},
{"keyword": "cartesian closed categories"},
{"keyword": "cartesian monoidal categories"},
{"keyword": "cartesian monoidal category"},
{"keyword": "cartesian powers"},
{"keyword": "cartesian product"},
{"keyword": "case"},
{"keyword": "case combinators"},
{"keyword": "case distinction"},
{"keyword": "case statements"},
{"keyword": "case studies"},
{"keyword": "case study"},
{"keyword": "case study revealed"},
{"keyword": "catalan numbers"},
{"keyword": "catalan numbers c_n"},
{"keyword": "categorical predicate transformers implement"},
{"keyword": "categories based"},
{"keyword": "categories enriched"},
{"keyword": "category"},
{"keyword": "category bf rts"},
{"keyword": "category enriched"},
{"keyword": "category equipped"},
{"keyword": "category theory"},
{"keyword": "category theory written"},
{"keyword": "category-theoretic properties"},
{"keyword": "cattle problem"},
{"keyword": "cauchy completion"},
{"keyword": "cauchy davenport theorem"},
{"keyword": "cauchy index"},
{"keyword": "cauchy sequence"},
{"keyword": "cava automata library"},
{"keyword": "cava model checker"},
{"keyword": "cayley-hamilton afp entries"},
{"keyword": "cayley-hamilton theorem based"},
{"keyword": "cc studies system classes"},
{"keyword": "celebrated probabilistic argument"},
{"keyword": "celebrated theorem"},
{"keyword": "central meta theorem"},
{"keyword": "central requirements"},
{"keyword": "central result"},
{"keyword": "central security property"},
{"keyword": "certificate checker"},
{"keyword": "certificate language"},
{"keyword": "certified complex root isolation"},
{"keyword": "certified declarative first-order prover"},
{"keyword": "certified dictionary translation"},
{"keyword": "certified factorization algorithm"},
{"keyword": "certified programs"},
{"keyword": "certify size-change termination proofs"},
{"keyword": "certify termination proofs"},
{"keyword": "certifying primes"},
{"keyword": "ceta system"},
{"keyword": "ch research verifythis"},
{"keyword": "chagu rand"},
{"keyword": "chamber complexes"},
{"keyword": "chandy--lamport algorithm"},
{"keyword": "change history"},
{"keyword": "channel protocols"},
{"keyword": "channel protocols communicating"},
{"keyword": "chapman formula"},
{"keyword": "chapter alpha-beta pruning"},
{"keyword": "chapters 7-9"},
{"keyword": "characteristic polynomials"},
{"keyword": "characteristic properties"},
{"keyword": "characterization theorem"},
{"keyword": "characterizes metrizable topological groups"},
{"keyword": "charly gries"},
{"keyword": "chebyshev nodes"},
{"keyword": "chebyshev polynomials"},
{"keyword": "check"},
{"keyword": "check high-level security goals"},
{"keyword": "checkers operate"},
{"keyword": "checking c1-information"},
{"keyword": "checking facilities leverage"},
{"keyword": "checks strong security"},
{"keyword": "chelsea edmonds"},
{"keyword": "cheri hardware"},
{"keyword": "chernoff bounds"},
{"keyword": "chi automata"},
{"keyword": "chinese remainder theorem"},
{"keyword": "chip authentication mapping"},
{"keyword": "choices"},
{"keyword": "chomsky normal form"},
{"keyword": "chords intersect"},
{"keyword": "chosen abstractions"},
{"keyword": "chosen memory model"},
{"keyword": "chosen plaintext"},
{"keyword": "chosen plaintext attack"},
{"keyword": "chosen uniformly"},
{"keyword": "christian urban"},
{"keyword": "christoph benzm uuml"},
{"keyword": "chromatic number exist"},
{"keyword": "chsh inequality"},
{"keyword": "church-encoded representation"},
{"keyword": "church-style simply-typed"},
{"keyword": "cidr notation"},
{"keyword": "ciphertext attacks"},
{"keyword": "circular intuition"},
{"keyword": "circus environment supports"},
{"keyword": "circus language"},
{"keyword": "circus processes"},
{"keyword": "cite swan"},
{"keyword": "cl73 chin-liang chang"},
{"keyword": "class hierarchies"},
{"keyword": "class models"},
{"keyword": "class type constructors"},
{"keyword": "class-collection-based rts algorithms run"},
{"keyword": "class-free constants"},
{"keyword": "class-preserving learning"},
{"keyword": "classes simply"},
{"keyword": "classic dynamic programming algorithm"},
{"keyword": "classic non-randomised quicksort"},
{"keyword": "classic notion"},
{"keyword": "classic proof"},
{"keyword": "classic quantifier elimination"},
{"keyword": "classic result"},
{"keyword": "classic textbook theory"},
{"keyword": "classic unsolved problems"},
{"keyword": "classical ai planning"},
{"keyword": "classical algorithms"},
{"keyword": "classical bases"},
{"keyword": "classical church-rosser theorem"},
{"keyword": "classical definition"},
{"keyword": "classical dpll procedure"},
{"keyword": "classical extensional mereology"},
{"keyword": "classical geometric definitions"},
{"keyword": "classical higher-order logic"},
{"keyword": "classical higher-order logic equivalent"},
{"keyword": "classical hoare"},
{"keyword": "classical implicational logic"},
{"keyword": "classical logic"},
{"keyword": "classical method"},
{"keyword": "classical noninterference security"},
{"keyword": "classical propositional logic"},
{"keyword": "classical registers"},
{"keyword": "classical statements"},
{"keyword": "classical theorem"},
{"keyword": "classical theorem stating"},
{"keyword": "classical two-sided matching scenarios"},
{"keyword": "classical yun algorithm"},
{"keyword": "classifies topological spaces"},
{"keyword": "clausal consequences"},
{"keyword": "clausal form"},
{"keyword": "clause loop"},
{"keyword": "clause procedures"},
{"keyword": "clause procedures gc"},
{"keyword": "clause sets"},
{"keyword": "clean development"},
{"keyword": "clean offers conditionals"},
{"keyword": "clear formalisation"},
{"keyword": "client-side javascript programs"},
{"keyword": "client-side web applications"},
{"keyword": "clock synchronization"},
{"keyword": "clock synchronization algorithm"},
{"keyword": "close connection"},
{"keyword": "closed finite games"},
{"keyword": "closed formulas"},
{"keyword": "closed monoidal category"},
{"keyword": "closed set"},
{"keyword": "closed starting"},
{"keyword": "closely follow"},
{"keyword": "closely related"},
{"keyword": "closest vector problem"},
{"keyword": "closure properties"},
{"keyword": "closure property"},
{"keyword": "cnf based sat algorithms"},
{"keyword": "cnf formulae"},
{"keyword": "co-closure operators"},
{"keyword": "co-inductive lists"},
{"keyword": "coalgebraic decision procedure"},
{"keyword": "coalgebraic literature"},
{"keyword": "coarse-grained concurrency"},
{"keyword": "coarse-grained semantics"},
{"keyword": "code"},
{"keyword": "code accessing"},
{"keyword": "code based extractors"},
{"keyword": "code compilation"},
{"keyword": "code equation"},
{"keyword": "code generation"},
{"keyword": "code generation facility"},
{"keyword": "code generation feature"},
{"keyword": "code generation setup"},
{"keyword": "code generation support"},
{"keyword": "code generator"},
{"keyword": "code generator maps"},
{"keyword": "code generator performs"},
{"keyword": "code generator setup"},
{"keyword": "code output level"},
{"keyword": "code rate"},
{"keyword": "codomain nat option"},
{"keyword": "coefficient functions"},
{"keyword": "coefficients modulo"},
{"keyword": "coercion ord_of_nat"},
{"keyword": "cofinitary group"},
{"keyword": "cohen posets"},
{"keyword": "coherence theorem"},
{"keyword": "coinduction infrastructure"},
{"keyword": "coinductive entry"},
{"keyword": "coinductive formalisations"},
{"keyword": "coinductive lists"},
{"keyword": "coinductive natural numbers"},
{"keyword": "coinductive terminated lists"},
{"keyword": "collaborative development"},
{"keyword": "collaborative text editing"},
{"keyword": "collapse theorems"},
{"keyword": "collect information"},
{"keyword": "collecting semantics"},
{"keyword": "collection datastructures"},
{"keyword": "collection framework"},
{"keyword": "collection offer functionality"},
{"keyword": "collection semantics"},
{"keyword": "collections framework"},
{"keyword": "collectively referred"},
{"keyword": "collects stable unknowns"},
{"keyword": "colon-separated notation"},
{"keyword": "column space"},
{"keyword": "combinable iff"},
{"keyword": "combinable wand"},
{"keyword": "combinatorial argument"},
{"keyword": "combinatorial auction"},
{"keyword": "combinatorial design theory"},
{"keyword": "combinatorial design theory library"},
{"keyword": "combinatorial game playing programs"},
{"keyword": "combinatorial map"},
{"keyword": "combinatorial objects"},
{"keyword": "combinatorial optimisation"},
{"keyword": "combinatorial proof"},
{"keyword": "combinatorial proof requires construction"},
{"keyword": "combinatorial structures"},
{"keyword": "combinatorics"},
{"keyword": "combinatory logic"},
{"keyword": "combine classical reasoning"},
{"keyword": "combine multiple methods"},
{"keyword": "combine stepwise refinement"},
{"keyword": "combined factorization algorithm"},
{"keyword": "combined result"},
{"keyword": "command"},
{"keyword": "command mk_ide"},
{"keyword": "command mk_ide enables"},
{"keyword": "commitment schemes"},
{"keyword": "committee members"},
{"keyword": "common automata library"},
{"keyword": "common base clock"},
{"keyword": "common combinatorial objects"},
{"keyword": "common criteria full abstraction"},
{"keyword": "common factors"},
{"keyword": "common form"},
{"keyword": "common format"},
{"keyword": "common ground"},
{"keyword": "common identities"},
{"keyword": "common language features"},
{"keyword": "common set"},
{"keyword": "common special case"},
{"keyword": "common theme"},
{"keyword": "common-sense theory"},
{"keyword": "communicating concurrent kleene algebra"},
{"keyword": "communicating products"},
{"keyword": "communicating sequential processes"},
{"keyword": "communicating sequential processes requires"},
{"keyword": "communication channels"},
{"keyword": "commutative replicated data types"},
{"keyword": "commutative ring"},
{"keyword": "commuting conversion rule"},
{"keyword": "commuting observables"},
{"keyword": "compact hausdorff space"},
{"keyword": "compact intervals"},
{"keyword": "compact supports"},
{"keyword": "compactness theorem"},
{"keyword": "companion articles"},
{"keyword": "companion paper"},
{"keyword": "comparatively small subset"},
{"keyword": "compare complements"},
{"keyword": "compare encodability criteria"},
{"keyword": "compare process calculi"},
{"keyword": "comparing encodability criteria"},
{"keyword": "comparing relations"},
{"keyword": "comparison oracle"},
{"keyword": "comparison-based sorting algorithm"},
{"keyword": "comparisons performed"},
{"keyword": "compatible formalization"},
{"keyword": "compcertssa project"},
{"keyword": "competitive analysis"},
{"keyword": "compilation function"},
{"keyword": "compilation target"},
{"keyword": "compiled code"},
{"keyword": "compiled code execution"},
{"keyword": "compiled tactic code"},
{"keyword": "compiler composition"},
{"keyword": "compiler correctness"},
{"keyword": "compiler correctness proof"},
{"keyword": "compiler correctness proof shorter"},
{"keyword": "compiler optimization"},
{"keyword": "compiler rewrite rules"},
{"keyword": "compiler technology"},
{"keyword": "complement algorithm"},
{"keyword": "complement automaton"},
{"keyword": "complementary error function erfc"},
{"keyword": "complementary semigroups"},
{"keyword": "complementing previous encodings"},
{"keyword": "complete"},
{"keyword": "complete basis"},
{"keyword": "complete formal development"},
{"keyword": "complete formalisation"},
{"keyword": "complete formalization"},
{"keyword": "complete graphs"},
{"keyword": "complete independence bounds"},
{"keyword": "complete ipv4"},
{"keyword": "complete lattices"},
{"keyword": "complete multiple-conclusion calculus"},
{"keyword": "complete multivariate qe algorithm"},
{"keyword": "complete networks"},
{"keyword": "complete parse forest"},
{"keyword": "complete proof method"},
{"keyword": "complete semantic tableau calculus"},
{"keyword": "complete semantics"},
{"keyword": "complete tableau calculus"},
{"keyword": "complete test generation algorithms"},
{"keyword": "completed versions"},
{"keyword": "completely factorize real"},
{"keyword": "completely remove tedious proofs"},
{"keyword": "completely subsumes"},
{"keyword": "completely verified"},
{"keyword": "completely verified model checker"},
{"keyword": "completeness"},
{"keyword": "completeness conditions"},
{"keyword": "completeness proof"},
{"keyword": "completeness proof builds"},
{"keyword": "completeness proofs naturally suggest"},
{"keyword": "completeness result"},
{"keyword": "completeness theorems"},
{"keyword": "completeness threshold"},
{"keyword": "complex"},
{"keyword": "complex algebraic numbers"},
{"keyword": "complex analysis"},
{"keyword": "complex arguments"},
{"keyword": "complex case"},
{"keyword": "complex construction"},
{"keyword": "complex data structure"},
{"keyword": "complex library"},
{"keyword": "complex mathematical reasoning"},
{"keyword": "complex number"},
{"keyword": "complex plane"},
{"keyword": "complex plane extended"},
{"keyword": "complex polynomial"},
{"keyword": "complex polynomial lie inside"},
{"keyword": "complex predicates"},
{"keyword": "complex random system"},
{"keyword": "complex roots"},
{"keyword": "complex systems involves"},
{"keyword": "complex unknowns x1"},
{"keyword": "complex vector spaces"},
{"keyword": "complex vector spaces contained"},
{"keyword": "complexity analysis"},
{"keyword": "complexity classes mathcal"},
{"keyword": "complexity low"},
{"keyword": "complexity proof certificates"},
{"keyword": "complicated derivatives"},
{"keyword": "complicated proofs"},
{"keyword": "complicated solution"},
{"keyword": "complicated translation layer"},
{"keyword": "complx language"},
{"keyword": "component behavior"},
{"keyword": "component-based development approach"},
{"keyword": "composable security statements"},
{"keyword": "composed protocol"},
{"keyword": "composite assertions"},
{"keyword": "composite completion construction"},
{"keyword": "composite objects"},
{"keyword": "composition properties wrt"},
{"keyword": "composition series"},
{"keyword": "compositional algorithm"},
{"keyword": "compositional algorithm exploits acyclicity"},
{"keyword": "compositional analysis"},
{"keyword": "compositional analysis methods"},
{"keyword": "compositional approach"},
{"keyword": "compositional invariant proofs"},
{"keyword": "compositional noninterference"},
{"keyword": "compositional statement"},
{"keyword": "compositional theory"},
{"keyword": "compositionality proofs"},
{"keyword": "compositionality results"},
{"keyword": "compositionally reasoning"},
{"keyword": "comprehension principle"},
{"keyword": "comprehensive framework"},
{"keyword": "computably enumerable sets"},
{"keyword": "computation based"},
{"keyword": "computation models"},
{"keyword": "computation traces"},
{"keyword": "computational complexity theory"},
{"keyword": "computational geometry"},
{"keyword": "computational metaphysics"},
{"keyword": "computational methods"},
{"keyword": "computational modeling"},
{"keyword": "computational models complicates comparisons"},
{"keyword": "compute arbitrary primitive recursive"},
{"keyword": "compute asymptotic expansions"},
{"keyword": "compute continued fraction expansions"},
{"keyword": "compute fair prices"},
{"keyword": "compute roots"},
{"keyword": "compute short vectors"},
{"keyword": "compute solutions"},
{"keyword": "computed result"},
{"keyword": "computer algebra system maple"},
{"keyword": "computer programs"},
{"keyword": "computer science"},
{"keyword": "computer-aided design"},
{"keyword": "computer-assisted interpretive method"},
{"keyword": "computerized implementation"},
{"keyword": "computes density functions"},
{"keyword": "computing bernoulli numbers"},
{"keyword": "computing dominators"},
{"keyword": "computing dominators due"},
{"keyword": "computing enclosures"},
{"keyword": "computing gr bner bases"},
{"keyword": "computing optimal stable matches"},
{"keyword": "computing saturated sets"},
{"keyword": "computing weak similarity"},
{"keyword": "comte de buffon posed"},
{"keyword": "concentration inequalities"},
{"keyword": "concepts apply"},
{"keyword": "concepts due"},
{"keyword": "concern geometry"},
{"keyword": "concerns infinite sets"},
{"keyword": "concise proof"},
{"keyword": "conclude wrong results"},
{"keyword": "concrete algorithms implementations"},
{"keyword": "concrete applicative functor"},
{"keyword": "concrete data structures"},
{"keyword": "concrete file represented"},
{"keyword": "concrete function"},
{"keyword": "concrete functors"},
{"keyword": "concrete input"},
{"keyword": "concrete laplace transforms"},
{"keyword": "concrete logics satisfying"},
{"keyword": "concrete lower bound"},
{"keyword": "concrete manifolds"},
{"keyword": "concrete mathematics"},
{"keyword": "concrete monad"},
{"keyword": "concrete program satisfies"},
{"keyword": "concrete programming language"},
{"keyword": "concrete protocols variants"},
{"keyword": "concrete prototypes"},
{"keyword": "concrete reachable states"},
{"keyword": "concrete representation"},
{"keyword": "concrete result"},
{"keyword": "concrete sigma-protocols"},
{"keyword": "concrete syntax"},
{"keyword": "concrete system"},
{"keyword": "concrete version"},
{"keyword": "concurrency control model"},
{"keyword": "concurrency primitives"},
{"keyword": "concurrency reasoning framework"},
{"keyword": "concurrency theory"},
{"keyword": "concurrent behaviour"},
{"keyword": "concurrent choice"},
{"keyword": "concurrent composition"},
{"keyword": "concurrent constraint pi-calculus"},
{"keyword": "concurrent dynamic logics"},
{"keyword": "concurrent kleene algebra"},
{"keyword": "concurrent operations"},
{"keyword": "concurrent programming"},
{"keyword": "concurrent programs"},
{"keyword": "concurrent programs attempt"},
{"keyword": "concurrent reads"},
{"keyword": "concurrent refinement algebra"},
{"keyword": "concurrent revisions"},
{"keyword": "concurrent revisions model"},
{"keyword": "concurrent sub-models"},
{"keyword": "concurrent systems"},
{"keyword": "concurrent value-dependent noninterference"},
{"keyword": "conditional equality operators"},
{"keyword": "conditional expectation"},
{"keyword": "conditional expressions"},
{"keyword": "conditional normative reasoning"},
{"keyword": "conditional obligation"},
{"keyword": "conditional probabilities"},
{"keyword": "conditional probability"},
{"keyword": "conditional transfer rules"},
{"keyword": "conditions"},
{"keyword": "conduct machine checkable proofs"},
{"keyword": "conducting completely formal proofs"},
{"keyword": "cone text arg"},
{"keyword": "conference certified programs"},
{"keyword": "conference interactive theorem proving"},
{"keyword": "confidential events"},
{"keyword": "confidentiality guarantees"},
{"keyword": "confidentiality properties"},
{"keyword": "confidentiality properties refer"},
{"keyword": "confidentiality verification"},
{"keyword": "configuration trace"},
{"keyword": "conflict-free replicated data types"},
{"keyword": "conflict-free replicated datatype"},
{"keyword": "conformance relations"},
{"keyword": "conformance testing"},
{"keyword": "congruence theorems"},
{"keyword": "conjectured relation"},
{"keyword": "conjunctive normal form"},
{"keyword": "connected open set"},
{"keyword": "connecting algebraic varieties"},
{"keyword": "cons"},
{"keyword": "consensus algorithms"},
{"keyword": "consensus problem"},
{"keyword": "considerably shorter"},
{"keyword": "consideration admits"},
{"keyword": "consistency problem"},
{"keyword": "consistent fol theories extending"},
{"keyword": "consistent learning"},
{"keyword": "consistent set"},
{"keyword": "consistent sign assignments"},
{"keyword": "consistently derivable"},
{"keyword": "constant functions"},
{"keyword": "constant intersect designs"},
{"keyword": "constant predicates stated"},
{"keyword": "constant time"},
{"keyword": "constant time findmin"},
{"keyword": "constant time queue"},
{"keyword": "constant upper bound"},
{"keyword": "constant-time findmin"},
{"keyword": "constraint-system-based program analysis"},
{"keyword": "construct complicated trees"},
{"keyword": "construct proper generic extensions"},
{"keyword": "construct real exponents"},
{"keyword": "constructing correct programs"},
{"keyword": "constructing rational numbers"},
{"keyword": "constructing sturm sequences efficiently"},
{"keyword": "construction theorem"},
{"keyword": "constructions based"},
{"keyword": "constructive cryptography"},
{"keyword": "constructive cryptography proofs"},
{"keyword": "constructive points"},
{"keyword": "constructive proof"},
{"keyword": "constructor applications"},
{"keyword": "constructor calls occuring"},
{"keyword": "contact gerwin"},
{"keyword": "container framework"},
{"keyword": "context relation"},
{"keyword": "context-free grammar"},
{"keyword": "context-free languages"},
{"keyword": "contextual equivalence"},
{"keyword": "contiguous segments"},
{"keyword": "continuation semantics"},
{"keyword": "continued fraction expansion"},
{"keyword": "continued fractions"},
{"keyword": "continuous functions"},
{"keyword": "continuous lattices"},
{"keyword": "continuous linear operators"},
{"keyword": "continuous map"},
{"keyword": "continuum hypothesis"},
{"keyword": "contraction factors"},
{"keyword": "contradicts consensus"},
{"keyword": "contradicts validity"},
{"keyword": "contribution presents"},
{"keyword": "contribution reuses"},
{"keyword": "control dependencies"},
{"keyword": "control flow"},
{"keyword": "control flow graph"},
{"keyword": "control operators"},
{"keyword": "control-flow graphs"},
{"keyword": "control-flow operators"},
{"keyword": "controlled manner"},
{"keyword": "controller constraints"},
{"keyword": "convenient commands"},
{"keyword": "conventional definitions"},
{"keyword": "conventional ltl"},
{"keyword": "conventional single-clocking semantics"},
{"keyword": "convergence function"},
{"keyword": "convergence function applied"},
{"keyword": "convergence rate"},
{"keyword": "conversion functions"},
{"keyword": "conversion version"},
{"keyword": "convert ltl formulas"},
{"keyword": "convert natural number"},
{"keyword": "convert regular expressions"},
{"keyword": "convex hull"},
{"keyword": "convex polyhedron satisfied"},
{"keyword": "convex polytopes"},
{"keyword": "convolution theorem thereon"},
{"keyword": "conway semirings extended"},
{"keyword": "cook-levin theorem states"},
{"keyword": "coordination"},
{"keyword": "coprime polynomials"},
{"keyword": "coprod_"},
{"keyword": "coproduct measure"},
{"keyword": "coproduct measure coprod_"},
{"keyword": "coproduct quasi-borel spaces"},
{"keyword": "coq proof assistant"},
{"keyword": "core dom"},
{"keyword": "core language"},
{"keyword": "core notion"},
{"keyword": "core operations"},
{"keyword": "core part"},
{"keyword": "core theorems"},
{"keyword": "corecursion combinator"},
{"keyword": "coreutils sha256 implementation"},
{"keyword": "correct 2-3 finger trees"},
{"keyword": "correct binomial heaps"},
{"keyword": "correct construction"},
{"keyword": "correct optimized versions"},
{"keyword": "correct verification tools"},
{"keyword": "correctness"},
{"keyword": "correctness claims"},
{"keyword": "correctness policy"},
{"keyword": "correctness proof"},
{"keyword": "correctness properties"},
{"keyword": "correctness property"},
{"keyword": "correctness theorems"},
{"keyword": "correspondence theorem"},
{"keyword": "correspondence-theory-focused metalogical study"},
{"keyword": "cosmed social media platform"},
{"keyword": "cotangent spaces"},
{"keyword": "counit natural transformations"},
{"keyword": "count distinct real roots"},
{"keyword": "count real roots"},
{"keyword": "countable chain condition"},
{"keyword": "countable discrete space"},
{"keyword": "countable families"},
{"keyword": "countable networks"},
{"keyword": "countable ordinals"},
{"keyword": "countable transitive model"},
{"keyword": "countably infinite number"},
{"keyword": "counter-free automata"},
{"keyword": "counting functions"},
{"keyword": "counting partial equivalence relations"},
{"keyword": "counting sort"},
{"keyword": "counting sort making"},
{"keyword": "counts distinct real roots"},
{"keyword": "counts roots"},
{"keyword": "couple small"},
{"keyword": "coupled delay simulations"},
{"keyword": "coupled similarity"},
{"keyword": "coupled simulation"},
{"keyword": "coupled simulation preorder"},
{"keyword": "coupled simulation versus bisimulation"},
{"keyword": "cover monotonic security invariants"},
{"keyword": "cover quantitative"},
{"keyword": "cover records"},
{"keyword": "covering directed"},
{"keyword": "covers algebraic reasoning"},
{"keyword": "cpp-2015 paper"},
{"keyword": "cpp-2015 peter lammich"},
{"keyword": "create executable scala code"},
{"keyword": "creating custom induction"},
{"keyword": "criterion"},
{"keyword": "critical points"},
{"keyword": "crowds protocol"},
{"keyword": "crowning achievements"},
{"keyword": "crucial ingredient"},
{"keyword": "crypthol library"},
{"keyword": "crypthol library crypthol"},
{"keyword": "cryptographic constructions"},
{"keyword": "cryptographic hash-function ripemd-160"},
{"keyword": "cryptographic operators"},
{"keyword": "cryptographic scheme crystals-kyber"},
{"keyword": "cryptographic validation fields"},
{"keyword": "cryptographically secure proof"},
{"keyword": "cryptography proof formalizations"},
{"keyword": "crytographic standards"},
{"keyword": "csp noninterference security"},
{"keyword": "csp noninterference security stated"},
{"keyword": "cubic equations"},
{"keyword": "cubic space"},
{"keyword": "current compression formats"},
{"keyword": "current element"},
{"keyword": "current formalization"},
{"keyword": "current monolithic protocols"},
{"keyword": "current state"},
{"keyword": "current symbolic state"},
{"keyword": "current version"},
{"keyword": "curve operations"},
{"keyword": "curves fips 198-1 nist"},
{"keyword": "custom hintikka sets based"},
{"keyword": "custom induction rules"},
{"keyword": "custom theorem proving environment"},
{"keyword": "custom-written ml code"},
{"keyword": "cut admissibility"},
{"keyword": "cut points"},
{"keyword": "cute puzzles"},
{"keyword": "cutting truncating sets"},
{"keyword": "cycle matroid"},
{"keyword": "cyclic groups"},
{"keyword": "cyk decides"},
{"keyword": "dana scott"},
{"keyword": "daniel schoepe"},
{"keyword": "data complexity"},
{"keyword": "data dependencies"},
{"keyword": "data flow analyser"},
{"keyword": "data plane"},
{"keyword": "data plane protocols"},
{"keyword": "data refinement"},
{"keyword": "data refinement framework"},
{"keyword": "data refinement relations"},
{"keyword": "data refinement techniques"},
{"keyword": "data secrecy"},
{"keyword": "data spaces"},
{"keyword": "data state manipulations"},
{"keyword": "data stream"},
{"keyword": "data structure"},
{"keyword": "data structures depending"},
{"keyword": "data structures required"},
{"keyword": "data transmission"},
{"keyword": "data type"},
{"keyword": "data-carrying events"},
{"keyword": "data-dependent constraints"},
{"keyword": "data-dependent execution time"},
{"keyword": "data-refinement techniques"},
{"keyword": "data-type declarations"},
{"keyword": "database community"},
{"keyword": "dataflow paradigm"},
{"keyword": "datatype package"},
{"keyword": "datatypes generated"},
{"keyword": "datatypes similar"},
{"keyword": "dbm-based forward analysis"},
{"keyword": "dbms find applications"},
{"keyword": "de bruijn index-based syntax"},
{"keyword": "de bruijn indices"},
{"keyword": "de-bruijn terms"},
{"keyword": "debited loans cancel"},
{"keyword": "debugging purposes"},
{"keyword": "decidability result"},
{"keyword": "decides language emptiness"},
{"keyword": "deciding coupled similarity"},
{"keyword": "deciding relative safety"},
{"keyword": "decision"},
{"keyword": "decision problem"},
{"keyword": "decision problem clique"},
{"keyword": "decision problem mathtt sat"},
{"keyword": "decision procedure"},
{"keyword": "decision procedure due"},
{"keyword": "decision procedure toolkit"},
{"keyword": "decision type"},
{"keyword": "declarative database query language"},
{"keyword": "declarative first-order prover"},
{"keyword": "declaring nominal datatypes"},
{"keyword": "declassification bounds"},
{"keyword": "decrease efficiency"},
{"keyword": "decreasing diagrams"},
{"keyword": "decreasing diagrams showing"},
{"keyword": "dedekind cuts"},
{"keyword": "dedekind quantale"},
{"keyword": "dedekind-peano postulates"},
{"keyword": "dedicated encoding"},
{"keyword": "dedicated locale"},
{"keyword": "dedicated vertices"},
{"keyword": "deductive program verification"},
{"keyword": "deductive system"},
{"keyword": "deductive tools"},
{"keyword": "deep embedding approach"},
{"keyword": "deep learning"},
{"keyword": "deeply embedded target programs"},
{"keyword": "deeply integrated"},
{"keyword": "default instantiation"},
{"keyword": "default setup"},
{"keyword": "defensive jinja virtual machine"},
{"keyword": "defensive strategies"},
{"keyword": "defensive strategies exist"},
{"keyword": "definedness condition"},
{"keyword": "defining execution equivalent markings"},
{"keyword": "defining functions"},
{"keyword": "defining functors"},
{"keyword": "defining variants"},
{"keyword": "defining web components"},
{"keyword": "definite descriptions"},
{"keyword": "definite initialisation analysis"},
{"keyword": "definition remarkably simple"},
{"keyword": "definitional embedding"},
{"keyword": "definitive prefix sets"},
{"keyword": "deg"},
{"keyword": "degenerate deterministic case"},
{"keyword": "degree bounds"},
{"keyword": "del"},
{"keyword": "del numbers"},
{"keyword": "deletion condition"},
{"keyword": "deletion preserve weight-balance"},
{"keyword": "deliberately formulated"},
{"keyword": "deliberately restrict"},
{"keyword": "deliverable d31"},
{"keyword": "delta gamma holds"},
{"keyword": "delta phi"},
{"keyword": "delta system lemma sessions"},
{"keyword": "demonic refinement algebra"},
{"keyword": "demonstrator semantic backend"},
{"keyword": "denies access"},
{"keyword": "denotational semantics"},
{"keyword": "dense linear orders"},
{"keyword": "density matrices"},
{"keyword": "density matrix"},
{"keyword": "dependency graph approximations"},
{"keyword": "dependency graphs"},
{"keyword": "dependent choices"},
{"keyword": "dependent security type system"},
{"keyword": "dependent types"},
{"keyword": "depth information"},
{"keyword": "deque implementation"},
{"keyword": "derangements formula describes"},
{"keyword": "derivative formula frac"},
{"keyword": "derive"},
{"keyword": "derive class instances"},
{"keyword": "derive comparators"},
{"keyword": "derive kummer"},
{"keyword": "derive mertens"},
{"keyword": "derive notions"},
{"keyword": "derive powerful induction rules"},
{"keyword": "derive proof rules"},
{"keyword": "derive proofs"},
{"keyword": "derived proof rules"},
{"keyword": "derives equality theorems"},
{"keyword": "derives main theorems"},
{"keyword": "deriving approximative safety properties"},
{"keyword": "deriving asymptotic estimates"},
{"keyword": "descartes rule"},
{"keyword": "descartes test based"},
{"keyword": "descartes test returns 0"},
{"keyword": "describe formalization"},
{"keyword": "design choices underlying"},
{"keyword": "design existence"},
{"keyword": "design isomorphisms"},
{"keyword": "design pattern"},
{"keyword": "designated root vertex"},
{"keyword": "designs"},
{"keyword": "desired interval"},
{"keyword": "desired precision"},
{"keyword": "desired subgraph"},
{"keyword": "destination ip space"},
{"keyword": "detailed apply scripts"},
{"keyword": "detailed calculations"},
{"keyword": "detailed description"},
{"keyword": "detailed presentation"},
{"keyword": "detailed proof steps"},
{"keyword": "detailed systematic study"},
{"keyword": "detect implicit equalities ndash"},
{"keyword": "detect unsatisfiability"},
{"keyword": "detected equations"},
{"keyword": "detecting rectangle intersection"},
{"keyword": "detects unsatisfiability"},
{"keyword": "determinant bound"},
{"keyword": "deterministic list update algorithms"},
{"keyword": "deterministic minsky machine"},
{"keyword": "deterministic monad"},
{"keyword": "deterministic multi-tape turing machines"},
{"keyword": "deterministic processes"},
{"keyword": "deterministic state machine"},
{"keyword": "determinization procedure"},
{"keyword": "deutsch-schorr-waite graph marking algorithm"},
{"keyword": "developing aspects"},
{"keyword": "developing methods"},
{"keyword": "developing security protocols"},
{"keyword": "development accompanies"},
{"keyword": "development concludes"},
{"keyword": "development employs"},
{"keyword": "development establishes"},
{"keyword": "development forms"},
{"keyword": "development longer"},
{"keyword": "development relies"},
{"keyword": "devise notions"},
{"keyword": "devising correct speculative algorithms"},
{"keyword": "dfs algorithm"},
{"keyword": "dfs-based algorithms"},
{"keyword": "diagonal functors"},
{"keyword": "diagonal-free timed automata"},
{"keyword": "diagrammatic modeling language"},
{"keyword": "diagrammatic proof system"},
{"keyword": "diatonic sequence"},
{"keyword": "dictionary translation"},
{"keyword": "diffeomorphism group"},
{"keyword": "difference bound matrices"},
{"keyword": "difference sets"},
{"keyword": "difference vector"},
{"keyword": "differentiability"},
{"keyword": "differential dynamic logic"},
{"keyword": "differential dynamics logic"},
{"keyword": "differential game logic"},
{"keyword": "differential testing"},
{"keyword": "differential_dynamic_logic article"},
{"keyword": "differs slightly"},
{"keyword": "difficult"},
{"keyword": "difficulty arises"},
{"keyword": "diffie-hellman password-based authentication protocol"},
{"keyword": "digit expansions"},
{"keyword": "digit expansions builds"},
{"keyword": "digit shifts"},
{"keyword": "dijkstra"},
{"keyword": "dining philosopher problem"},
{"keyword": "diophantine approximations"},
{"keyword": "diophantine equation solver"},
{"keyword": "diophantine sets"},
{"keyword": "direct adaptation"},
{"keyword": "direct adequacy proof"},
{"keyword": "direct application"},
{"keyword": "direct arguments"},
{"keyword": "direct consequence"},
{"keyword": "direct corollaries"},
{"keyword": "direct execution"},
{"keyword": "direct formalisation"},
{"keyword": "direct mathematical model"},
{"keyword": "direct product"},
{"keyword": "direct recursion"},
{"keyword": "direct semantics"},
{"keyword": "direct subsumption"},
{"keyword": "direct subsumption relation"},
{"keyword": "directed graph"},
{"keyword": "directed graph library"},
{"keyword": "directed security policies"},
{"keyword": "directed set"},
{"keyword": "directly derive executable"},
{"keyword": "directly executable program"},
{"keyword": "directly follow"},
{"keyword": "directly implementable"},
{"keyword": "directly implies"},
{"keyword": "directly inspired"},
{"keyword": "directly relating agents"},
{"keyword": "dirichlet"},
{"keyword": "dirichlet characters"},
{"keyword": "dirichlet l-functions"},
{"keyword": "dirichlet products"},
{"keyword": "dirichlet series"},
{"keyword": "dirk pfl ger"},
{"keyword": "disconnected graph"},
{"keyword": "discounted infinite horizon mdps"},
{"keyword": "discrete"},
{"keyword": "discrete category"},
{"keyword": "discrete financial models"},
{"keyword": "discrete fourier transform"},
{"keyword": "discrete instants"},
{"keyword": "discrete probabilistic subdistributions"},
{"keyword": "discrete probability distributions"},
{"keyword": "discrete stochastic dynamic programming"},
{"keyword": "discrete summation"},
{"keyword": "discrete-time markov chains"},
{"keyword": "discretised implementation approximates"},
{"keyword": "discuss generalizations"},
{"keyword": "discussion logs"},
{"keyword": "disintegration theorem"},
{"keyword": "disjoint sums"},
{"keyword": "display algebraic numbers"},
{"keyword": "disprove program properties"},
{"keyword": "disproving program"},
{"keyword": "disregard unrealizable behavior"},
{"keyword": "distinct algebraic numbers alpha_i"},
{"keyword": "distinct layers"},
{"keyword": "distinct network nodes"},
{"keyword": "distinct operators"},
{"keyword": "distinct prime factors"},
{"keyword": "distinctive feature"},
{"keyword": "distinguishing feature"},
{"keyword": "distribute sequential composition"},
{"keyword": "distributed computing"},
{"keyword": "distributed consensus"},
{"keyword": "distributed environment"},
{"keyword": "distributed ledgers"},
{"keyword": "distributed system"},
{"keyword": "distributed systems specification"},
{"keyword": "distributing interest"},
{"keyword": "divergence kleene algebras"},
{"keyword": "divergence reflection"},
{"keyword": "diverse fields"},
{"keyword": "divide conquer algorithms"},
{"keyword": "divide-and-conquer algorithm"},
{"keyword": "divided differences"},
{"keyword": "division algorithms"},
{"keyword": "division modulo"},
{"keyword": "divisor function"},
{"keyword": "divisor function sigma"},
{"keyword": "divisor sigma function"},
{"keyword": "dk andschl thesis"},
{"keyword": "dmitriy traytel"},
{"keyword": "dnf-based non-elementary algorithm"},
{"keyword": "doctoral thesis"},
{"keyword": "document class"},
{"keyword": "document corresponds"},
{"keyword": "document describes"},
{"keyword": "document development"},
{"keyword": "document object model"},
{"keyword": "document ontology framework"},
{"keyword": "document presents"},
{"keyword": "document root"},
{"keyword": "documentation generation features"},
{"keyword": "documents managed"},
{"keyword": "dof targets use-cases"},
{"keyword": "dogged previous mechanised proofs"},
{"keyword": "dom api"},
{"keyword": "dom respect component boundaries"},
{"keyword": "dom revealed numerous invariants"},
{"keyword": "dom standard"},
{"keyword": "domain elements"},
{"keyword": "domain operation"},
{"keyword": "domain theory"},
{"keyword": "domain-relation map satisfying"},
{"keyword": "domain-specific languages"},
{"keyword": "domain-theoretic fixpoint operator"},
{"keyword": "domain-theoretic semantics"},
{"keyword": "domain-theoretical aspects"},
{"keyword": "dominated terms"},
{"keyword": "dot-decimal notation"},
{"keyword": "dprm theorem"},
{"keyword": "dra targets similar applications"},
{"keyword": "draft paper"},
{"keyword": "drf guarantee"},
{"keyword": "drinks machine"},
{"keyword": "driving application"},
{"keyword": "drup proof output"},
{"keyword": "dual assertion"},
{"keyword": "dual incidence systems"},
{"keyword": "dual problem"},
{"keyword": "dual system relationships"},
{"keyword": "duggan-schwartz theorems"},
{"keyword": "dynamic architectures"},
{"keyword": "dynamic class initialization"},
{"keyword": "dynamic condition response"},
{"keyword": "dynamic context"},
{"keyword": "dynamic declassification triggers"},
{"keyword": "dynamic languages"},
{"keyword": "dynamic logics"},
{"keyword": "dynamic method invocation"},
{"keyword": "dynamic negation"},
{"keyword": "dynamic programming"},
{"keyword": "dynamic pushdown networks"},
{"keyword": "dynamic refutational completeness"},
{"keyword": "dynamic slicing"},
{"keyword": "dynamic tables parameterized"},
{"keyword": "dynamic thread creation"},
{"keyword": "dynamical systems"},
{"keyword": "dynamically typed programming languages"},
{"keyword": "earlier afp entry"},
{"keyword": "earlier joint work"},
{"keyword": "earlier paper"},
{"keyword": "earlier result"},
{"keyword": "earlier version"},
{"keyword": "early failure detection"},
{"keyword": "early result"},
{"keyword": "early stage"},
{"keyword": "earmark propositions"},
{"keyword": "easily adapt existing proofs"},
{"keyword": "easily adapted"},
{"keyword": "easily derive"},
{"keyword": "easily expandable"},
{"keyword": "easily generate elements"},
{"keyword": "easily justified"},
{"keyword": "easily obtained"},
{"keyword": "easily transfer theorems"},
{"keyword": "easily work"},
{"keyword": "easy reuse"},
{"keyword": "echelon form afp entry"},
{"keyword": "economic behavior"},
{"keyword": "edge labels"},
{"keyword": "edge weights"},
{"keyword": "edmonds theorem"},
{"keyword": "edmonds-karp algorithm"},
{"keyword": "educational setting due"},
{"keyword": "edward zalta"},
{"keyword": "edwards elliptic curves"},
{"keyword": "effect polymorphism"},
{"keyword": "effect specifications"},
{"keyword": "effectful computations"},
{"keyword": "effective mutual authentication service"},
{"keyword": "effective procedure"},
{"keyword": "effectively decide ideal membership"},
{"keyword": "effectively executable"},
{"keyword": "effectively executable algorithm"},
{"keyword": "efficient allocation"},
{"keyword": "efficient arrays"},
{"keyword": "efficient binary search"},
{"keyword": "efficient checking"},
{"keyword": "efficient computation"},
{"keyword": "efficient data structure combining"},
{"keyword": "efficient data structures"},
{"keyword": "efficient deterministic parsing"},
{"keyword": "efficient enumeration"},
{"keyword": "efficient executable algorithm"},
{"keyword": "efficient executable code"},
{"keyword": "efficient factorization algorithm"},
{"keyword": "efficient functional programs"},
{"keyword": "efficient imperative implementations"},
{"keyword": "efficient imperative version"},
{"keyword": "efficient implementation"},
{"keyword": "efficient monpoly monitoring tool"},
{"keyword": "efficient priority search trees"},
{"keyword": "efficient proof checking"},
{"keyword": "efficient root isolation"},
{"keyword": "efficient search strategy"},
{"keyword": "efficient structures"},
{"keyword": "efficient union-find data structure"},
{"keyword": "efficient variable-length codes"},
{"keyword": "efficient verified implementation"},
{"keyword": "efficient version"},
{"keyword": "efficiently compute"},
{"keyword": "efficiently computed"},
{"keyword": "efficiently executable"},
{"keyword": "efficiently executable code"},
{"keyword": "efsm level"},
{"keyword": "efsms execute traces"},
{"keyword": "electronic proceedings"},
{"keyword": "elegant encoding"},
{"keyword": "elegant proof"},
{"keyword": "element codes"},
{"keyword": "element set"},
{"keyword": "elementary computational proof"},
{"keyword": "elementary divisor rings"},
{"keyword": "elementary facts"},
{"keyword": "elementary infrastructure"},
{"keyword": "elementary measure theory"},
{"keyword": "elementary methods"},
{"keyword": "elementary number theory"},
{"keyword": "elementary proof"},
{"keyword": "elementary proof exist"},
{"keyword": "elementary properties"},
{"keyword": "elementary results"},
{"keyword": "elementary row operations"},
{"keyword": "elementary symmetric polynomials"},
{"keyword": "elementary symmetric polynomials e1"},
{"keyword": "elementary symmetric polynomials sk"},
{"keyword": "elementary theory"},
{"keyword": "elements belong"},
{"keyword": "eliminates duplicate prime factors"},
{"keyword": "elimination contexts"},
{"keyword": "elliott mendelson"},
{"keyword": "elliptic curve"},
{"keyword": "elliptic curve cryptography"},
{"keyword": "embedded logic"},
{"keyword": "embedding path order"},
{"keyword": "emphasising local spatial properties"},
{"keyword": "empirical evaluation"},
{"keyword": "employ code equations"},
{"keyword": "employ messageless guard protocols"},
{"keyword": "employs formal models"},
{"keyword": "employs herbrand"},
{"keyword": "employs reasoning"},
{"keyword": "emptiness check"},
{"keyword": "empty bst"},
{"keyword": "empty rows"},
{"keyword": "enable easy integration"},
{"keyword": "enabled transitions"},
{"keyword": "enables users"},
{"keyword": "enabling concrete execution"},
{"keyword": "encoding"},
{"keyword": "encoding based"},
{"keyword": "encoding function"},
{"keyword": "encourages code"},
{"keyword": "encryption schemes"},
{"keyword": "enforcing exclusive writes"},
{"keyword": "engineering safety"},
{"keyword": "enhanced confidence"},
{"keyword": "enhanced interleaves predicate turns"},
{"keyword": "enriched categories"},
{"keyword": "enriched category generalizes"},
{"keyword": "enriched category theory"},
{"keyword": "ensuing instruction"},
{"keyword": "entailment- minimal"},
{"keyword": "entire cosmedis network"},
{"keyword": "entire development"},
{"keyword": "entire expansion"},
{"keyword": "entire input sequence"},
{"keyword": "entire polynomial ring"},
{"keyword": "entire prover"},
{"keyword": "entry"},
{"keyword": "entry adapts stream fusion"},
{"keyword": "entry adds quickcheck setup"},
{"keyword": "entry builds"},
{"keyword": "entry collects"},
{"keyword": "entry establishes syntax"},
{"keyword": "entry formally"},
{"keyword": "entry forms part"},
{"keyword": "entry genclock"},
{"keyword": "entry lies"},
{"keyword": "entry presents"},
{"keyword": "entry strong security"},
{"keyword": "entry vcg auctions"},
{"keyword": "entry works"},
{"keyword": "enumeration functions"},
{"keyword": "enumerative combinatorics"},
{"keyword": "epistemic logic"},
{"keyword": "epistemic logic theory"},
{"keyword": "eponym ijcar 2020 paper"},
{"keyword": "eponymous itp 2012 paper"},
{"keyword": "epsilon free top-"},
{"keyword": "equality holds"},
{"keyword": "equational axiomatisation"},
{"keyword": "equational axioms"},
{"keyword": "equational reasoning"},
{"keyword": "equiv 3 pmod 8"},
{"keyword": "equiv frac mathcal"},
{"keyword": "equiv_ text"},
{"keyword": "equivalence checker"},
{"keyword": "equivalence classes"},
{"keyword": "equivalence kernels"},
{"keyword": "equivalence proofs"},
{"keyword": "equivalence relation"},
{"keyword": "equivalent characterisations"},
{"keyword": "equivalent conditions"},
{"keyword": "equivalent design theory concepts"},
{"keyword": "equivalent forms"},
{"keyword": "equivalent statements"},
{"keyword": "equivalent versions"},
{"keyword": "equivalently wajsberg"},
{"keyword": "erd odblac"},
{"keyword": "erf algorithm"},
{"keyword": "erf algorithm detects"},
{"keyword": "erf algorithm proceeds similarly"},
{"keyword": "ergodic theory"},
{"keyword": "error message"},
{"keyword": "error-free termination"},
{"keyword": "esop 2016 paper"},
{"keyword": "essential parts"},
{"keyword": "essentially follow"},
{"keyword": "establish existence"},
{"keyword": "establish sound type-system-"},
{"keyword": "establishing set-based metric spaces"},
{"keyword": "establishing strong eventual consistency"},
{"keyword": "euclidean axiom"},
{"keyword": "euclidean domains"},
{"keyword": "euclidean space indexed"},
{"keyword": "eudoxus reals"},
{"keyword": "euler ndash"},
{"keyword": "euler stated"},
{"keyword": "euler trails"},
{"keyword": "euler-maclaurin formula relates"},
{"keyword": "eulerian polynomials"},
{"keyword": "eulerian trails"},
{"keyword": "euro-mils project http"},
{"keyword": "evaluates equations required"},
{"keyword": "evaluating cauchy indices"},
{"keyword": "evaluation homomorphisms"},
{"keyword": "event lists varying"},
{"keyword": "event shared"},
{"keyword": "events"},
{"keyword": "eventual consistency"},
{"keyword": "eventual consistency property"},
{"keyword": "eventually achieve"},
{"keyword": "exact nature"},
{"keyword": "exceeds aleph_1"},
{"keyword": "exception compilation scheme"},
{"keyword": "exceptionally well-suited"},
{"keyword": "exchanging data"},
{"keyword": "exchanging data sets"},
{"keyword": "excluding cubic axioms"},
{"keyword": "excluding point sequences"},
{"keyword": "executable algorithms"},
{"keyword": "executable algorithms based"},
{"keyword": "executable automata"},
{"keyword": "executable characterisation"},
{"keyword": "executable code"},
{"keyword": "executable data structures"},
{"keyword": "executable decision procedure"},
{"keyword": "executable denotational semantics"},
{"keyword": "executable density compiler"},
{"keyword": "executable earley parser"},
{"keyword": "executable emulator"},
{"keyword": "executable equivalence checker"},
{"keyword": "executable formalisation"},
{"keyword": "executable framework"},
{"keyword": "executable function eval"},
{"keyword": "executable functional implementation"},
{"keyword": "executable functions"},
{"keyword": "executable implementation"},
{"keyword": "executable instantiations"},
{"keyword": "executable ml code"},
{"keyword": "executable monitor"},
{"keyword": "executable program"},
{"keyword": "executable proof checker"},
{"keyword": "executable query translation"},
{"keyword": "executable sequent calculus prover"},
{"keyword": "executable simplifier"},
{"keyword": "executable specification"},
{"keyword": "executable tool translating ltl"},
{"keyword": "executable type inference algorithm"},
{"keyword": "executable variant"},
{"keyword": "executable version"},
{"keyword": "execute programs"},
{"keyword": "execution equivalent markings"},
{"keyword": "execution involving integer matrices"},
{"keyword": "execution platform"},
{"keyword": "execution time"},
{"keyword": "execution time compares"},
{"keyword": "executions produce sequences"},
{"keyword": "exhibit awkward interleaving"},
{"keyword": "exhibit core features"},
{"keyword": "existence lemmas"},
{"keyword": "existing afp-entry"},
{"keyword": "existing approaches"},
{"keyword": "existing arguments"},
{"keyword": "existing cc results"},
{"keyword": "existing concepts"},
{"keyword": "existing formal developments"},
{"keyword": "existing formal power series"},
{"keyword": "existing formalization"},
{"keyword": "existing functionality"},
{"keyword": "existing geometry libraries"},
{"keyword": "existing hoare logic"},
{"keyword": "existing implementation"},
{"keyword": "existing integration theory"},
{"keyword": "existing libraries"},
{"keyword": "existing library"},
{"keyword": "existing multivariate polynomial libraries"},
{"keyword": "existing package algorithms"},
{"keyword": "existing pen-and-paper proof"},
{"keyword": "existing probability libraries"},
{"keyword": "existing proof"},
{"keyword": "existing proof format"},
{"keyword": "existing replication algorithm satisfies"},
{"keyword": "existing secav system"},
{"keyword": "existing solutions"},
{"keyword": "existing theories"},
{"keyword": "existing tools"},
{"keyword": "existing verification techniques"},
{"keyword": "exotic terms"},
{"keyword": "expand stone relation algebras"},
{"keyword": "expanding contracting intervals"},
{"keyword": "expansive formalisations"},
{"keyword": "expected accuracy"},
{"keyword": "expected algebraic properties"},
{"keyword": "expected height"},
{"keyword": "expected internal path length"},
{"keyword": "expected length"},
{"keyword": "expected number"},
{"keyword": "expected properties"},
{"keyword": "expected utility function"},
{"keyword": "expected utility theory"},
{"keyword": "experiment consisting"},
{"keyword": "experiment performs measures"},
{"keyword": "experimental data suggests"},
{"keyword": "experimental general-purpose proof methods"},
{"keyword": "experimental utilities"},
{"keyword": "experimentally tested"},
{"keyword": "explanation-producing monitoring algorithm"},
{"keyword": "explicit bottom element"},
{"keyword": "explicit construction"},
{"keyword": "explicit error term"},
{"keyword": "explicit expression"},
{"keyword": "explicit formula"},
{"keyword": "explicit metric"},
{"keyword": "explicit syntactic form"},
{"keyword": "explicitly represented"},
{"keyword": "exploiting type classes"},
{"keyword": "exponent stubbornly remained"},
{"keyword": "exponential functions"},
{"keyword": "exponential generating function"},
{"keyword": "exponential golomb codes"},
{"keyword": "exponential nnf-based algorithms"},
{"keyword": "exponential reconstruction phase"},
{"keyword": "exponential runtime"},
{"keyword": "exponential series"},
{"keyword": "export code"},
{"keyword": "express arbitrary program hyperproperties"},
{"keyword": "express nuances"},
{"keyword": "express well-"},
{"keyword": "expressing linear-time properties"},
{"keyword": "expressing security properties"},
{"keyword": "expressing smart contracts"},
{"keyword": "expression typing rules"},
{"keyword": "expressions involving"},
{"keyword": "expressive extension"},
{"keyword": "expressive formalism"},
{"keyword": "expressive logic"},
{"keyword": "expressive power"},
{"keyword": "extended"},
{"keyword": "extended complex plane"},
{"keyword": "extended finite state machines"},
{"keyword": "extended interval analysis"},
{"keyword": "extended language"},
{"keyword": "extended natural indicating"},
{"keyword": "extended previous"},
{"keyword": "extended programming language"},
{"keyword": "extended real line"},
{"keyword": "extended real numbers"},
{"keyword": "extended real numbers form"},
{"keyword": "extended regular expressions"},
{"keyword": "extended version"},
{"keyword": "extending previous results applying"},
{"keyword": "extensible design permits"},
{"keyword": "extensible library"},
{"keyword": "extensible minimal imperative fragment"},
{"keyword": "extensible record package"},
{"keyword": "extension formally represents"},
{"keyword": "extension theorem employing terminology"},
{"keyword": "extensions written"},
{"keyword": "extensive paper proof"},
{"keyword": "extensively discussed"},
{"keyword": "extent differs"},
{"keyword": "extent required"},
{"keyword": "external communication clocking"},
{"keyword": "external source"},
{"keyword": "external tools"},
{"keyword": "extra assumptions"},
{"keyword": "extra background theory"},
{"keyword": "extra setup"},
{"keyword": "extra-history change history"},
{"keyword": "extract efficient code"},
{"keyword": "extract ocaml code"},
{"keyword": "extremal graph theory"},
{"keyword": "extremal set theory"},
{"keyword": "extreme simplicity"},
{"keyword": "eye color"},
{"keyword": "fabian immler"},
{"keyword": "facilitate formal verification"},
{"keyword": "facilitate integrating future optimizations"},
{"keyword": "facilitating developments"},
{"keyword": "factor polynomials"},
{"keyword": "factor ring"},
{"keyword": "factor square-free integer polynomials"},
{"keyword": "factored representation"},
{"keyword": "factoring algorithm"},
{"keyword": "factoring polynomials"},
{"keyword": "factoring square-free integer polynomials"},
{"keyword": "factorisation algorithm"},
{"keyword": "factorization algorithms"},
{"keyword": "facts involving algebraic laws"},
{"keyword": "failed proof"},
{"keyword": "failing test case"},
{"keyword": "failure assumptions"},
{"keyword": "failure divergence model"},
{"keyword": "failure-prone environments"},
{"keyword": "failures model"},
{"keyword": "failures-divergences pair"},
{"keyword": "fair coin flips"},
{"keyword": "fair prices"},
{"keyword": "fairly efficient"},
{"keyword": "fairly extensive set"},
{"keyword": "fairly nice"},
{"keyword": "fairly obvious properties"},
{"keyword": "fairly rudimentary"},
{"keyword": "faithful embedding"},
{"keyword": "faithful formalization"},
{"keyword": "fall back"},
{"keyword": "false alarms"},
{"keyword": "falsely claims"},
{"keyword": "familiar first-order logic"},
{"keyword": "familiar real-"},
{"keyword": "famous abc conjecture"},
{"keyword": "famous invisible hand"},
{"keyword": "famous result"},
{"keyword": "far-reaching impossibility theorem"},
{"keyword": "fast iterative algorithm"},
{"keyword": "fast number theoretic transform"},
{"keyword": "fast sat solver"},
{"keyword": "faster pushdown reachability analysis"},
{"keyword": "faug egrave"},
{"keyword": "fault-tolerant midpoint algorithm"},
{"keyword": "faulty process"},
{"keyword": "feasible paths"},
{"keyword": "featherweight ocl"},
{"keyword": "featherweight ocl project"},
{"keyword": "feature dependent types"},
{"keyword": "feature nice mathematical properties"},
{"keyword": "features dynamic thread creation"},
{"keyword": "features exceptions"},
{"keyword": "features monadic types"},
{"keyword": "featuring program-level requirements"},
{"keyword": "fft algorithm"},
{"keyword": "fibonacci number"},
{"keyword": "field accesses"},
{"keyword": "field extensions"},
{"keyword": "field-theoretic nullstellensatz"},
{"keyword": "file read"},
{"keyword": "file write"},
{"keyword": "files"},
{"keyword": "files chap02"},
{"keyword": "filled rows"},
{"keyword": "filtered sets"},
{"keyword": "filtering behavior"},
{"keyword": "filtermapped equality"},
{"keyword": "fin"},
{"keyword": "final implementation"},
{"keyword": "final states"},
{"keyword": "final theorem statement"},
{"keyword": "finality predicate"},
{"keyword": "finally wondering"},
{"keyword": "financial market"},
{"keyword": "financial products"},
{"keyword": "find definitions"},
{"keyword": "find operation"},
{"keyword": "finding proofs"},
{"keyword": "finding small"},
{"keyword": "fine-grained concurrency"},
{"keyword": "finger tree"},
{"keyword": "finite automata"},
{"keyword": "finite boolean algebra"},
{"keyword": "finite carrier set"},
{"keyword": "finite closed semantic tree"},
{"keyword": "finite collection"},
{"keyword": "finite consistent extensions"},
{"keyword": "finite developments theorem"},
{"keyword": "finite dimensional setting"},
{"keyword": "finite dimensional vector space"},
{"keyword": "finite distributive lattice"},
{"keyword": "finite domain consisting"},
{"keyword": "finite field"},
{"keyword": "finite fourier series"},
{"keyword": "finite functions"},
{"keyword": "finite games"},
{"keyword": "finite group"},
{"keyword": "finite infinite lists"},
{"keyword": "finite iteration"},
{"keyword": "finite learning"},
{"keyword": "finite length"},
{"keyword": "finite limits"},
{"keyword": "finite lists"},
{"keyword": "finite maps"},
{"keyword": "finite measure preserving systems"},
{"keyword": "finite measures"},
{"keyword": "finite observations"},
{"keyword": "finite partitioning"},
{"keyword": "finite relations"},
{"keyword": "finite search space"},
{"keyword": "finite set"},
{"keyword": "finite sound extensions"},
{"keyword": "finite state machines"},
{"keyword": "finite state markov chains"},
{"keyword": "finite stuttering"},
{"keyword": "finite support"},
{"keyword": "finite symbolic execution graph"},
{"keyword": "finite traces"},
{"keyword": "finite trees"},
{"keyword": "finite types"},
{"keyword": "finite-dimensional vector spaces"},
{"keyword": "finitely additive probability inequalities"},
{"keyword": "finitely additive probability logic"},
{"keyword": "finitely generated polynomial ideals"},
{"keyword": "finitely supported"},
{"keyword": "finiteness assumptions"},
{"keyword": "fips 180-4 nist"},
{"keyword": "fips 186-4"},
{"keyword": "first-order clauses"},
{"keyword": "first-order functional language"},
{"keyword": "first-order logic"},
{"keyword": "first-order logic completeness theorem"},
{"keyword": "first-order logic metatheory"},
{"keyword": "first-order parameters"},
{"keyword": "first-order prover"},
{"keyword": "first-order quantification"},
{"keyword": "first-order query evaluation"},
{"keyword": "first-order real arithmetic"},
{"keyword": "first-order terms"},
{"keyword": "first-order theory"},
{"keyword": "first-order unification algorithm"},
{"keyword": "fisher yates algorithm"},
{"keyword": "fitting theory"},
{"keyword": "fixed access frequencies"},
{"keyword": "fixed arbitrary length"},
{"keyword": "fixed arguments"},
{"keyword": "fixed bound"},
{"keyword": "fixed choice"},
{"keyword": "fixed database"},
{"keyword": "fixed finite instance"},
{"keyword": "fixed finite set"},
{"keyword": "fixed fraction"},
{"keyword": "fixed lexicographical order"},
{"keyword": "fixed natural number"},
{"keyword": "fixed number"},
{"keyword": "fixed points"},
{"keyword": "fixed prime"},
{"keyword": "fixed probability"},
{"keyword": "fixed service"},
{"keyword": "fixed set"},
{"keyword": "fixed time-unit"},
{"keyword": "fixed upper bound"},
{"keyword": "fixed-point theorem"},
{"keyword": "fixed-width machine words"},
{"keyword": "fixpoint operations lfp"},
{"keyword": "fixpoint theorem"},
{"keyword": "flexible extension"},
{"keyword": "flexible set-based theorems"},
{"keyword": "flexray communication protocol"},
{"keyword": "floating-point arithmetic"},
{"keyword": "floating-point computation"},
{"keyword": "floating-point modulo function"},
{"keyword": "floating-point numbers"},
{"keyword": "floating-point operations"},
{"keyword": "floor divided"},
{"keyword": "floor randomly"},
{"keyword": "florian kammueller"},
{"keyword": "flow saturates"},
{"keyword": "flow-sensitive type system"},
{"keyword": "flowgraph-based program model"},
{"keyword": "flows model"},
{"keyword": "floyd-warshall algorithm"},
{"keyword": "floyd-warshall algorithm flo62"},
{"keyword": "flyspeck project"},
{"keyword": "fmcad2022 paper ssst22"},
{"keyword": "fntt running time"},
{"keyword": "fol theories extending"},
{"keyword": "fold build rule"},
{"keyword": "folder commonset"},
{"keyword": "folder listinf"},
{"keyword": "folklore results related"},
{"keyword": "follow stefan schwoon"},
{"keyword": "foreach combinators"},
{"keyword": "fork"},
{"keyword": "form bigwedge_"},
{"keyword": "form construction algorithm"},
{"keyword": "formal analysis"},
{"keyword": "formal correctness proofs"},
{"keyword": "formal cryptographic protocol verification"},
{"keyword": "formal definitions"},
{"keyword": "formal development"},
{"keyword": "formal differentiation"},
{"keyword": "formal framework"},
{"keyword": "formal guarantees"},
{"keyword": "formal implementation"},
{"keyword": "formal language"},
{"keyword": "formal laurent series"},
{"keyword": "formal linear algebraic techniques"},
{"keyword": "formal memory model"},
{"keyword": "formal methods"},
{"keyword": "formal model"},
{"keyword": "formal power series"},
{"keyword": "formal programming language semantics"},
{"keyword": "formal proof"},
{"keyword": "formal proof assistant"},
{"keyword": "formal proof closely"},
{"keyword": "formal proof technology"},
{"keyword": "formal protocol verification"},
{"keyword": "formal puiseux series"},
{"keyword": "formal reasoning"},
{"keyword": "formal refutational completeness proofs"},
{"keyword": "formal representations"},
{"keyword": "formal semantics"},
{"keyword": "formal semantics builds"},
{"keyword": "formal semantics complies"},
{"keyword": "formal semantics designed"},
{"keyword": "formal summation"},
{"keyword": "formal text lines"},
{"keyword": "formal theory"},
{"keyword": "formal verification"},
{"keyword": "formal version"},
{"keyword": "formal words"},
{"keyword": "formalisation"},
{"keyword": "formalisation accompanies"},
{"keyword": "formalisation continues"},
{"keyword": "formalisation hold"},
{"keyword": "formalisation presents"},
{"keyword": "formalisation underlying"},
{"keyword": "formalising baker"},
{"keyword": "formalising cryptographic arguments"},
{"keyword": "formalising single binder calculi"},
{"keyword": "formalising t-designs"},
{"keyword": "formalization"},
{"keyword": "formalization adds"},
{"keyword": "formalization builds"},
{"keyword": "formalization consists"},
{"keyword": "formalization effort necessitated"},
{"keyword": "formalization involves augmenting"},
{"keyword": "formalization reveals"},
{"keyword": "formalization techniques presented"},
{"keyword": "formalization uncovered"},
{"keyword": "formalizations differ mathematically"},
{"keyword": "formalizing compiler transformations"},
{"keyword": "formalizing game-based proofs"},
{"keyword": "formally connect"},
{"keyword": "formally establish properties"},
{"keyword": "formally reason"},
{"keyword": "formally verified"},
{"keyword": "formally verified abstract account"},
{"keyword": "formally verified checkers"},
{"keyword": "formally verified clrs algorithms"},
{"keyword": "formally verified implementation"},
{"keyword": "formally verified model"},
{"keyword": "formally verified oracle"},
{"keyword": "formally verified quantifier elimination"},
{"keyword": "formally verified security analysis"},
{"keyword": "formally verified solver"},
{"keyword": "formally verify gauss-seidel"},
{"keyword": "formula mdp ta pta"},
{"keyword": "formula represent propositional formulas"},
{"keyword": "formulas"},
{"keyword": "formulas assuming"},
{"keyword": "formulas obtained"},
{"keyword": "formulate classical propositional logic"},
{"keyword": "forthcoming paper"},
{"keyword": "forward algorithm"},
{"keyword": "forward data packets"},
{"keyword": "forward differentiation"},
{"keyword": "forward packets"},
{"keyword": "found cryptic"},
{"keyword": "foundation presented"},
{"keyword": "foundational assumptions"},
{"keyword": "foundational metaphysical theory"},
{"keyword": "foundational shared-variable concurrency method"},
{"keyword": "foundational structures"},
{"keyword": "foundations established"},
{"keyword": "fourier sequences"},
{"keyword": "fourier series"},
{"keyword": "fourteen lemmas"},
{"keyword": "fourth sylow theorems"},
{"keyword": "frac 1 p-1"},
{"keyword": "frac mathcal"},
{"keyword": "fractional assertions"},
{"keyword": "fractional permissions"},
{"keyword": "frame rule"},
{"keyword": "framed links"},
{"keyword": "framed links closely linked"},
{"keyword": "framework features"},
{"keyword": "framework supports semantic annotations"},
{"keyword": "framing conditions"},
{"keyword": "frank gray"},
{"keyword": "fredkin cacm 1960"},
{"keyword": "free"},
{"keyword": "free basis"},
{"keyword": "free boolean algebra"},
{"keyword": "free category"},
{"keyword": "free groups"},
{"keyword": "free logic"},
{"keyword": "free monoid"},
{"keyword": "free monoidal category"},
{"keyword": "free theorems"},
{"keyword": "free variables"},
{"keyword": "frequency moment"},
{"keyword": "friendship theorem"},
{"keyword": "frobenius endomorphism"},
{"keyword": "frobenius homomorphism"},
{"keyword": "frobenius reciprocity"},
{"keyword": "frobenius theorem"},
{"keyword": "frobenius theorem based"},
{"keyword": "fulfilling van der waerden"},
{"keyword": "full asymptotic expansion"},
{"keyword": "full automation"},
{"keyword": "full bridge rule"},
{"keyword": "full characterization"},
{"keyword": "full classical propositional logic"},
{"keyword": "full classification"},
{"keyword": "full details"},
{"keyword": "full extent"},
{"keyword": "full machinery"},
{"keyword": "full model-based inductive accounting"},
{"keyword": "full parametric solution"},
{"keyword": "full permission"},
{"keyword": "full proof"},
{"keyword": "full range"},
{"keyword": "full sequential fragment"},
{"keyword": "fully"},
{"keyword": "fully abstract"},
{"keyword": "fully automated"},
{"keyword": "fully automated methods"},
{"keyword": "fully automated translation"},
{"keyword": "fully automatic tools"},
{"keyword": "fully canceled words"},
{"keyword": "fully connected subgraph"},
{"keyword": "fully corrupted"},
{"keyword": "fully executable functional implementation"},
{"keyword": "fully executable solver"},
{"keyword": "fully formal"},
{"keyword": "fully formally verified"},
{"keyword": "fully json compliant"},
{"keyword": "fully structured"},
{"keyword": "fully verified"},
{"keyword": "fully-automated approach"},
{"keyword": "fully-featured compositional framework"},
{"keyword": "function"},
{"keyword": "function calls"},
{"keyword": "function checking"},
{"keyword": "function definitions"},
{"keyword": "function elts"},
{"keyword": "function eval"},
{"keyword": "function eval checking"},
{"keyword": "function eval solves capturability"},
{"keyword": "function interpolation"},
{"keyword": "function radical"},
{"keyword": "function satisfies"},
{"keyword": "function spaces"},
{"keyword": "function zeta"},
{"keyword": "functional algorithm"},
{"keyword": "functional arrays"},
{"keyword": "functional automata"},
{"keyword": "functional correctness"},
{"keyword": "functional data structures"},
{"keyword": "functional equation"},
{"keyword": "functional implementation"},
{"keyword": "functional implementation based"},
{"keyword": "functional languages"},
{"keyword": "functional logic"},
{"keyword": "functional modeling language hol"},
{"keyword": "functional program"},
{"keyword": "functional programming language"},
{"keyword": "functional recognizer modeling earley"},
{"keyword": "functional representation"},
{"keyword": "functional type theory"},
{"keyword": "functions approximating"},
{"keyword": "functions learnable"},
{"keyword": "functions thetasym"},
{"keyword": "functor category"},
{"keyword": "functor composition"},
{"keyword": "functorial operations"},
{"keyword": "fundamental banach spaces"},
{"keyword": "fundamental binary operations allowing"},
{"keyword": "fundamental building block"},
{"keyword": "fundamental closest pair"},
{"keyword": "fundamental interest"},
{"keyword": "fundamental metaphysical theory"},
{"keyword": "fundamental objects"},
{"keyword": "fundamental problems"},
{"keyword": "fundamental properties"},
{"keyword": "fundamental result"},
{"keyword": "fundamental solution"},
{"keyword": "fundamental subspaces"},
{"keyword": "fundamental theorem"},
{"keyword": "fusc function"},
{"keyword": "fusible list functions"},
{"keyword": "future articles"},
{"keyword": "future combinations"},
{"keyword": "future development"},
{"keyword": "future formalisations requiring"},
{"keyword": "future probabilistic proof systems"},
{"keyword": "future related mechanisation efforts"},
{"keyword": "future separation logic developments"},
{"keyword": "fwf"},
{"keyword": "gained experience"},
{"keyword": "gale stewart theorem"},
{"keyword": "gale-shapley stable matching"},
{"keyword": "galois connections"},
{"keyword": "galois theory"},
{"keyword": "game theoretic issues"},
{"keyword": "game theory"},
{"keyword": "game-based cryptographic security notions"},
{"keyword": "game-based definitions"},
{"keyword": "game-based proofs"},
{"keyword": "game-hopping style advocated"},
{"keyword": "gamma"},
{"keyword": "gamma finally"},
{"keyword": "gamma function"},
{"keyword": "gamma holds"},
{"keyword": "gamma quad text"},
{"keyword": "gau lucas theorem"},
{"keyword": "gauss-jordan algorithm"},
{"keyword": "gauss-jordan algorithm states"},
{"keyword": "gaussian integer formalisation"},
{"keyword": "gaussian integers"},
{"keyword": "gdpr compliance verification"},
{"keyword": "general abstract view"},
{"keyword": "general attacker"},
{"keyword": "general balanced trees"},
{"keyword": "general banach spaces"},
{"keyword": "general case"},
{"keyword": "general cost functions"},
{"keyword": "general definition"},
{"keyword": "general directed graph library"},
{"keyword": "general form"},
{"keyword": "general formal proof techniques"},
{"keyword": "general formulation"},
{"keyword": "general framework"},
{"keyword": "general geometric facts"},
{"keyword": "general halting problem"},
{"keyword": "general infinite processes"},
{"keyword": "general lemma"},
{"keyword": "general library"},
{"keyword": "general linear group"},
{"keyword": "general models"},
{"keyword": "general notion"},
{"keyword": "general possibility theorem"},
{"keyword": "general predication"},
{"keyword": "general probability distributions"},
{"keyword": "general problem"},
{"keyword": "general properties"},
{"keyword": "general purpose data structure"},
{"keyword": "general recursion"},
{"keyword": "general relativity"},
{"keyword": "general result"},
{"keyword": "general scheme"},
{"keyword": "general sets"},
{"keyword": "general setting"},
{"keyword": "general simplex algorithm"},
{"keyword": "general solver"},
{"keyword": "general techniques"},
{"keyword": "general theorem"},
{"keyword": "general theory"},
{"keyword": "general topology"},
{"keyword": "general triangle"},
{"keyword": "general version"},
{"keyword": "general-purpose coinductive data types"},
{"keyword": "generalisation bnfcc"},
{"keyword": "generalise relation algebras"},
{"keyword": "generalised binary modalities"},
{"keyword": "generalised binomial coefficients"},
{"keyword": "generalised form"},
{"keyword": "generalised rewriting"},
{"keyword": "generalising tla action formulas"},
{"keyword": "generalized intervals"},
{"keyword": "generalized multiset ordering"},
{"keyword": "generalized noninterference security"},
{"keyword": "generalized recurrence"},
{"keyword": "generalized recurrence relation"},
{"keyword": "generalized sumcheck protocol"},
{"keyword": "generalized sylvester matrices"},
{"keyword": "generalizes sutherland"},
{"keyword": "generally detectable"},
{"keyword": "generate"},
{"keyword": "generate code"},
{"keyword": "generate duplicates"},
{"keyword": "generate efficient code"},
{"keyword": "generate executable code"},
{"keyword": "generate executable imperative programs"},
{"keyword": "generate human-readable secav proofs"},
{"keyword": "generate reverse-symmetric claims"},
{"keyword": "generate theorem prover code"},
{"keyword": "generated code"},
{"keyword": "generated code implements"},
{"keyword": "generated document"},
{"keyword": "generated inputs"},
{"keyword": "generated test suite"},
{"keyword": "generating function equivalence proof"},
{"keyword": "generating function proof"},
{"keyword": "generating test cases"},
{"keyword": "generative probabilistic"},
{"keyword": "generic abstract interpreter"},
{"keyword": "generic algebraic middle-layer"},
{"keyword": "generic algorithm"},
{"keyword": "generic consistency ---"},
{"keyword": "generic construction"},
{"keyword": "generic dfs algorithm framework"},
{"keyword": "generic diamond lemma reduction"},
{"keyword": "generic fixed-width words"},
{"keyword": "generic fixpoint algorithm"},
{"keyword": "generic framework"},
{"keyword": "generic framework semantics"},
{"keyword": "generic imperative algorithms"},
{"keyword": "generic imperative language embedded"},
{"keyword": "generic instantiation based"},
{"keyword": "generic join algorithm"},
{"keyword": "generic kind"},
{"keyword": "generic mathematical results underlying"},
{"keyword": "generic object model independent"},
{"keyword": "generic operations"},
{"keyword": "generic properties"},
{"keyword": "generic push-relabel algorithm"},
{"keyword": "generic results"},
{"keyword": "generic rules resulting"},
{"keyword": "generic tactics"},
{"keyword": "generic theory"},
{"keyword": "generic type class implementation"},
{"keyword": "generic type classes"},
{"keyword": "generic types"},
{"keyword": "generic unwinding theorem"},
{"keyword": "generic work-list algorithm"},
{"keyword": "generic worklist algorithm"},
{"keyword": "generic-deriving package"},
{"keyword": "geocoq library"},
{"keyword": "geodesic gromov-hyperbolic space"},
{"keyword": "geodesic metric space"},
{"keyword": "geodesic spaces"},
{"keyword": "geodesic triangles"},
{"keyword": "geometric folklore proof rigorous"},
{"keyword": "geometric interpretation"},
{"keyword": "geometric probability"},
{"keyword": "geometric proof"},
{"keyword": "geometric relation"},
{"keyword": "geometric sketches"},
{"keyword": "geometric theorems"},
{"keyword": "georg kreisel"},
{"keyword": "george boolos gave"},
{"keyword": "georges-louis leclerc"},
{"keyword": "georgia notes"},
{"keyword": "geq 1"},
{"keyword": "geq 108m"},
{"keyword": "geq 2 n-1"},
{"keyword": "geq 28m 3"},
{"keyword": "geq 3"},
{"keyword": "geq 324"},
{"keyword": "gewirth"},
{"keyword": "ghc haskell compiler"},
{"keyword": "ghost operations"},
{"keyword": "gibbard-satterthwaite theorem"},
{"keyword": "girard newton theorem"},
{"keyword": "girard-tait style logical relation"},
{"keyword": "girth chromatic entry"},
{"keyword": "girth-chromatic number theorem"},
{"keyword": "glibc strlen function"},
{"keyword": "global context"},
{"keyword": "global context transformations"},
{"keyword": "global model"},
{"keyword": "global security guarantee"},
{"keyword": "global variables"},
{"keyword": "gmw protocol"},
{"keyword": "golden ratio"},
{"keyword": "good class"},
{"keyword": "good closure properties"},
{"keyword": "good lower bound"},
{"keyword": "goto rule"},
{"keyword": "gou zel"},
{"keyword": "gps receiver"},
{"keyword": "gps satellite"},
{"keyword": "gr bner bases"},
{"keyword": "gr bner basis"},
{"keyword": "gradually add structure"},
{"keyword": "graham jameson"},
{"keyword": "gram-schmidt process"},
{"keyword": "grammar based fuzzing"},
{"keyword": "graph coloring theorem"},
{"keyword": "graph colourings"},
{"keyword": "graph isomorphism"},
{"keyword": "graph lemma quantifies"},
{"keyword": "graph node"},
{"keyword": "graph operations"},
{"keyword": "graph properties expressed"},
{"keyword": "graph regularity"},
{"keyword": "graph representation"},
{"keyword": "graph saturation"},
{"keyword": "graph theorem states"},
{"keyword": "graph theoretic results"},
{"keyword": "graph theory"},
{"keyword": "graph- transformation based method"},
{"keyword": "graph-theoretic aspects"},
{"keyword": "grat format"},
{"keyword": "great body"},
{"keyword": "great mathematical interest"},
{"keyword": "greater computational cost"},
{"keyword": "greater detail"},
{"keyword": "greatest common divisor"},
{"keyword": "greatest fixed points"},
{"keyword": "greatest fixpoints"},
{"keyword": "greatly reducing"},
{"keyword": "greedy algorithms"},
{"keyword": "greibach normal form"},
{"keyword": "griffin observed"},
{"keyword": "gromov boundary"},
{"keyword": "gromov hyperbolic"},
{"keyword": "gromov hyperbolic spaces"},
{"keyword": "ground resolution"},
{"keyword": "ground terms induced"},
{"keyword": "ground totality"},
{"keyword": "ground tree transducers"},
{"keyword": "grounding sets"},
{"keyword": "group"},
{"keyword": "group action"},
{"keyword": "group divisible designs"},
{"keyword": "group generated"},
{"keyword": "group representation"},
{"keyword": "group ring"},
{"keyword": "group theory results"},
{"keyword": "group_add class"},
{"keyword": "growth rates"},
{"keyword": "guarantee condition"},
{"keyword": "guarantee information flow noninterference"},
{"keyword": "guarantee minimality"},
{"keyword": "guarantee safety"},
{"keyword": "guard protocols"},
{"keyword": "guarded recursive equations"},
{"keyword": "guided tour"},
{"keyword": "guiding proof search"},
{"keyword": "hadjicostas ndash"},
{"keyword": "hahn decomposition theorem"},
{"keyword": "hales jewett theorem"},
{"keyword": "hales jewett theorem presented"},
{"keyword": "halting problem"},
{"keyword": "hamiltonian path problem"},
{"keyword": "hancl asserting"},
{"keyword": "hand canonical notions"},
{"keyword": "hand waving"},
{"keyword": "hand-written theory files"},
{"keyword": "handle binding"},
{"keyword": "handle changing beliefs"},
{"keyword": "handle equality tests"},
{"keyword": "handle incidence relations"},
{"keyword": "handling inconsistency"},
{"keyword": "handling padding"},
{"keyword": "handling variable binding"},
{"keyword": "handwritten reference implementations"},
{"keyword": "hare cycle-finding algorithm ascribed"},
{"keyword": "harm security"},
{"keyword": "harmonic numbers"},
{"keyword": "hash families"},
{"keyword": "hash functions"},
{"keyword": "haskell"},
{"keyword": "haskell library"},
{"keyword": "haskell tool called fffuu"},
{"keyword": "healthcare iot system"},
{"keyword": "heap location"},
{"keyword": "heap operations"},
{"keyword": "heap property"},
{"keyword": "heap sort"},
{"keyword": "heavily depend"},
{"keyword": "hellip"},
{"keyword": "helper lemmas"},
{"keyword": "henkin style"},
{"keyword": "henkin witnesses"},
{"keyword": "herbrand universe"},
{"keyword": "hereditarily finite"},
{"keyword": "hereditarily finite set theory"},
{"keyword": "hereditarily finite sets"},
{"keyword": "hereditary base 2"},
{"keyword": "hereditary multisets"},
{"keyword": "herglotz"},
{"keyword": "hermite normal form"},
{"keyword": "hermite--lindemann--weierstra transcendence theorem"},
{"keyword": "hermite-lindemann-weierstra theorem"},
{"keyword": "hermitian matrix"},
{"keyword": "heterogeneous subsystems"},
{"keyword": "heuristics automatically pick"},
{"keyword": "hf set theory"},
{"keyword": "hidden markov models"},
{"keyword": "hierarchical automaton"},
{"keyword": "hierarchical logger"},
{"keyword": "hierarchical transactions"},
{"keyword": "high annotation overhead"},
{"keyword": "high edge probability"},
{"keyword": "high efficiency"},
{"keyword": "high level attacks"},
{"keyword": "high school"},
{"keyword": "high-level algorithm"},
{"keyword": "high-level proofs"},
{"keyword": "high-level security goals"},
{"keyword": "high-level specification language jml"},
{"keyword": "high-level style"},
{"keyword": "high-level type systems"},
{"keyword": "high-level view"},
{"keyword": "high-school student"},
{"keyword": "higher categories"},
{"keyword": "higher edge probability"},
{"keyword": "higher entity"},
{"keyword": "higher kleene algebras"},
{"keyword": "higher order logic"},
{"keyword": "higher rewriting"},
{"keyword": "higher-dimensional automata"},
{"keyword": "higher-dimensional rewriting"},
{"keyword": "higher-order frequency moments"},
{"keyword": "higher-order functions"},
{"keyword": "higher-order logic"},
{"keyword": "higher-order pattern e-unification"},
{"keyword": "higher-order pattern unification"},
{"keyword": "higher-order permutative rewrite rule"},
{"keyword": "higher-order probabilistic programming languages"},
{"keyword": "higher-order probabilistic programs"},
{"keyword": "higher-order superposition calculus"},
{"keyword": "higher-order term algebra"},
{"keyword": "higher-order terms"},
{"keyword": "highly informal"},
{"keyword": "highly modular"},
{"keyword": "highly probable assumption"},
{"keyword": "highly recommend"},
{"keyword": "hilbert systems"},
{"keyword": "hilbert-style proof system"},
{"keyword": "hintikka set"},
{"keyword": "historical perspective"},
{"keyword": "hmac standard"},
{"keyword": "hoare logic"},
{"keyword": "hoare logic based"},
{"keyword": "hoare triples"},
{"keyword": "hoc fashion"},
{"keyword": "hoc network"},
{"keyword": "hoc on-demand distance vector"},
{"keyword": "hoelder inequalities"},
{"keyword": "hol"},
{"keyword": "hol code generation facilities"},
{"keyword": "hol code generator"},
{"keyword": "hol dataset"},
{"keyword": "hol definitions"},
{"keyword": "hol experts"},
{"keyword": "hol formalisation"},
{"keyword": "hol formalization"},
{"keyword": "hol formalization builds"},
{"keyword": "hol formalization covers"},
{"keyword": "hol formalization refines"},
{"keyword": "hol function"},
{"keyword": "hol function definition"},
{"keyword": "hol library"},
{"keyword": "hol light"},
{"keyword": "hol light development"},
{"keyword": "hol light formalisation"},
{"keyword": "hol light formalization"},
{"keyword": "hol light version"},
{"keyword": "hol logic system"},
{"keyword": "hol multivariate analysis"},
{"keyword": "hol nominal"},
{"keyword": "hol overhead"},
{"keyword": "hol proof assistant"},
{"keyword": "hol set"},
{"keyword": "hol sources underlying"},
{"keyword": "hol standard library"},
{"keyword": "hol theorem"},
{"keyword": "hol theory listextras"},
{"keyword": "hol type system"},
{"keyword": "hol types"},
{"keyword": "hol users"},
{"keyword": "hol-algebra library"},
{"keyword": "hol-based afp entry"},
{"keyword": "hol-csp"},
{"keyword": "hol-csp improving"},
{"keyword": "hol-multivariate analysis library"},
{"keyword": "hol-multivariate-analysis session"},
{"keyword": "hol4 formalization"},
{"keyword": "holcf extension"},
{"keyword": "holcf package"},
{"keyword": "holds"},
{"keyword": "holomorphic automorphisms"},
{"keyword": "holzf theory"},
{"keyword": "hom embedding"},
{"keyword": "homogeneous linear diophantine equations"},
{"keyword": "homological argument"},
{"keyword": "homomorphic functions"},
{"keyword": "homotopy type theory"},
{"keyword": "hoops"},
{"keyword": "horizontal composition"},
{"keyword": "horn- renamable"},
{"keyword": "hspace 3mm"},
{"keyword": "html documents"},
{"keyword": "human mortality"},
{"keyword": "human readable style"},
{"keyword": "human-readable fast-to-replay proof scripts"},
{"keyword": "hybrid game"},
{"keyword": "hybrid logic"},
{"keyword": "hybrid mixture"},
{"keyword": "hybrid programs"},
{"keyword": "hyper hoare logic"},
{"keyword": "hyperbolic geometry"},
{"keyword": "hyperdual extensions"},
{"keyword": "hyperdual numbers"},
{"keyword": "hypergraph decompositions"},
{"keyword": "hypergraph language"},
{"keyword": "hypergraph theory"},
{"keyword": "hypothesis stating"},
{"keyword": "ideal real simulation paradigm"},
{"keyword": "ideal showcase"},
{"keyword": "ideas borrowed"},
{"keyword": "identical sequence elements"},
{"keyword": "identified inconsistencies"},
{"keyword": "identifies posix"},
{"keyword": "identify bugs"},
{"keyword": "identify undesired information leaks"},
{"keyword": "identifying finite-dimensional operators"},
{"keyword": "ieee-754 floating-point arithmetic"},
{"keyword": "ifip networking 2016"},
{"keyword": "ijcar 2006 paper"},
{"keyword": "ijcar 2014 publication"},
{"keyword": "ijcar 2022 paper rensets"},
{"keyword": "ikkbz produces"},
{"keyword": "imaginary part"},
{"keyword": "immediately offer"},
{"keyword": "immensely helpful"},
{"keyword": "immutable arrays"},
{"keyword": "imp commands"},
{"keyword": "imp language"},
{"keyword": "impact"},
{"keyword": "imperative data structures"},
{"keyword": "imperative executable code"},
{"keyword": "imperative hol"},
{"keyword": "imperative hol heap monad"},
{"keyword": "imperative hol programs"},
{"keyword": "imperative implementation"},
{"keyword": "imperative language constructs"},
{"keyword": "imperative language imp"},
{"keyword": "imperative loop constructs"},
{"keyword": "imperative programming languages"},
{"keyword": "imperative programs"},
{"keyword": "imperative refinement framework"},
{"keyword": "imperative style"},
{"keyword": "imperative target language"},
{"keyword": "implement probabilistic algorithms"},
{"keyword": "implement saturation calculi"},
{"keyword": "implement translation functions"},
{"keyword": "implementation"},
{"keyword": "implementation details"},
{"keyword": "implementation matches"},
{"keyword": "implementation mixes"},
{"keyword": "implementation relates pointer-based computation"},
{"keyword": "implementation runs"},
{"keyword": "implementation supports set membership"},
{"keyword": "implemented multi-"},
{"keyword": "implemented tactics"},
{"keyword": "implemented tail recursively"},
{"keyword": "implicit flows"},
{"keyword": "implicit reasoning steps"},
{"keyword": "implies confluence"},
{"keyword": "import-expert format"},
{"keyword": "important applications"},
{"keyword": "important classes"},
{"keyword": "important concentration inequalities"},
{"keyword": "important concepts"},
{"keyword": "important consequences"},
{"keyword": "important correctness property"},
{"keyword": "important data structure"},
{"keyword": "important functions"},
{"keyword": "important introductory theorems"},
{"keyword": "important meta-theoretic results"},
{"keyword": "important models"},
{"keyword": "important problem"},
{"keyword": "important properties"},
{"keyword": "important result"},
{"keyword": "important role"},
{"keyword": "important specializations"},
{"keyword": "important theorem"},
{"keyword": "impossibility theorem due"},
{"keyword": "improvements compared"},
{"keyword": "imre lakatos"},
{"keyword": "in-place heapsort"},
{"keyword": "incidence matrix representation"},
{"keyword": "incidence set systems"},
{"keyword": "incidence system"},
{"keyword": "incidence system isomorphisms"},
{"keyword": "incidence system properties"},
{"keyword": "inclusion checking"},
{"keyword": "inclusion isotone"},
{"keyword": "incoming edges"},
{"keyword": "incoming edges equals"},
{"keyword": "incomparable results"},
{"keyword": "incompleteness theorem"},
{"keyword": "inconsistent bounds"},
{"keyword": "inconsistent theory"},
{"keyword": "incorporate smoothly"},
{"keyword": "incorrectly initialized contract"},
{"keyword": "incorrectness logic"},
{"keyword": "increased demand"},
{"keyword": "increasing rational sequence r_n"},
{"keyword": "increasingly important"},
{"keyword": "incredible proof machine"},
{"keyword": "incremental verification"},
{"keyword": "incrementally check"},
{"keyword": "ind-cpa security proof"},
{"keyword": "indefinitely large set"},
{"keyword": "indefinitely long sequence"},
{"keyword": "independent authors"},
{"keyword": "independent axioms"},
{"keyword": "independent events"},
{"keyword": "independent families"},
{"keyword": "independent interest"},
{"keyword": "independent modules"},
{"keyword": "independent publication"},
{"keyword": "independent random variables"},
{"keyword": "independent runs"},
{"keyword": "independent set"},
{"keyword": "independent set matching"},
{"keyword": "indexing set"},
{"keyword": "indistinguishable security"},
{"keyword": "individual accepted"},
{"keyword": "individual components"},
{"keyword": "individual computing nodes"},
{"keyword": "individual program behaviours"},
{"keyword": "individual program executions"},
{"keyword": "individual theorems"},
{"keyword": "induced maps"},
{"keyword": "induction"},
{"keyword": "induction hypothesis"},
{"keyword": "induction principle"},
{"keyword": "induction rule"},
{"keyword": "induction schemes"},
{"keyword": "inductive definition"},
{"keyword": "inductive invariant proofs"},
{"keyword": "inductive method"},
{"keyword": "inductive predicates"},
{"keyword": "inductive sets"},
{"keyword": "inductive unwinding theorem"},
{"keyword": "industrial separation kernel"},
{"keyword": "industrial systems"},
{"keyword": "inefficient variant"},
{"keyword": "inequality involving expectations"},
{"keyword": "inequality states"},
{"keyword": "inequational reasoning"},
{"keyword": "inertial observers"},
{"keyword": "inf-preserving predicate transformers"},
{"keyword": "inf-preserving transformers"},
{"keyword": "infer interleaves statements"},
{"keyword": "inference rules"},
{"keyword": "inference step"},
{"keyword": "inference system presented"},
{"keyword": "infinitary nominal data type"},
{"keyword": "infinitary version"},
{"keyword": "infinite"},
{"keyword": "infinite behavior traces"},
{"keyword": "infinite conjunctions"},
{"keyword": "infinite derivation trees"},
{"keyword": "infinite domain"},
{"keyword": "infinite element"},
{"keyword": "infinite execution"},
{"keyword": "infinite form"},
{"keyword": "infinite games"},
{"keyword": "infinite graphs"},
{"keyword": "infinite horizon mdps"},
{"keyword": "infinite iteration"},
{"keyword": "infinite key range"},
{"keyword": "infinite length"},
{"keyword": "infinite measure"},
{"keyword": "infinite message streams represented"},
{"keyword": "infinite paths"},
{"keyword": "infinite polynomial"},
{"keyword": "infinite ramsey theorem"},
{"keyword": "infinite sequence"},
{"keyword": "infinite series"},
{"keyword": "infinite series built"},
{"keyword": "infinite set"},
{"keyword": "infinite subset"},
{"keyword": "infinite traces"},
{"keyword": "infinite trees branching"},
{"keyword": "infinite type"},
{"keyword": "infinite-dimensional vector spaces"},
{"keyword": "infinitely generated"},
{"keyword": "infinitesimal components"},
{"keyword": "influential works"},
{"keyword": "info 96638976x 34"},
{"keyword": "info research codegen"},
{"keyword": "informal description"},
{"keyword": "informal presentation"},
{"keyword": "informal proof"},
{"keyword": "informally speaking"},
{"keyword": "information flow control"},
{"keyword": "information flow correctness"},
{"keyword": "information flow correctness notion"},
{"keyword": "information flow security"},
{"keyword": "information managed"},
{"keyword": "information observed"},
{"keyword": "information processing letters 29"},
{"keyword": "information required"},
{"keyword": "information whatsoever flows"},
{"keyword": "information-flow security aims"},
{"keyword": "information-flow security applicable"},
{"keyword": "infrastructure previously"},
{"keyword": "ingo van duijn"},
{"keyword": "inherently based"},
{"keyword": "initial conversion"},
{"keyword": "initial nonterminal"},
{"keyword": "initial proof"},
{"keyword": "initial segment"},
{"keyword": "initial segment condition"},
{"keyword": "initial specification"},
{"keyword": "initial states"},
{"keyword": "initially queried unknown"},
{"keyword": "injection 2 mathbb"},
{"keyword": "inline caching optimization"},
{"keyword": "inlines function application"},
{"keyword": "input generators"},
{"keyword": "input infinite sequences"},
{"keyword": "input lists"},
{"keyword": "input output pairs"},
{"keyword": "input parameter"},
{"keyword": "input processes"},
{"keyword": "input programs"},
{"keyword": "input simultaneously"},
{"keyword": "insecure channel controlled"},
{"keyword": "insertion sort"},
{"keyword": "insertion sort algorithm"},
{"keyword": "instance---many-sorted fol"},
{"keyword": "instantiation boils"},
{"keyword": "instantiation draws heavily"},
{"keyword": "instantiation reuses"},
{"keyword": "instruction set architecture"},
{"keyword": "int_0 1"},
{"keyword": "int_0 infty b_n"},
{"keyword": "int_a kappa_x"},
{"keyword": "integer coefficients"},
{"keyword": "integer components"},
{"keyword": "integer hull"},
{"keyword": "integer keys"},
{"keyword": "integer lattice 8484"},
{"keyword": "integer parameter"},
{"keyword": "integer polynomial belongs"},
{"keyword": "integer polynomials"},
{"keyword": "integer ring modulo"},
{"keyword": "integer variables"},
{"keyword": "integer-indexed maps"},
{"keyword": "integers"},
{"keyword": "integers based"},
{"keyword": "integers hurwitz"},
{"keyword": "integers modulo"},
{"keyword": "integrable simple functions"},
{"keyword": "integral domains"},
{"keyword": "integral lattice points"},
{"keyword": "integrate interval analysis"},
{"keyword": "integrated memory models"},
{"keyword": "integrated pide document model"},
{"keyword": "integrating interval analysis"},
{"keyword": "integration technique employs lex"},
{"keyword": "intended domain"},
{"keyword": "intensional higher-order modal logic"},
{"keyword": "interactive automated relativization"},
{"keyword": "interactive convergence algorithm"},
{"keyword": "interactive program verification environment"},
{"keyword": "interactive proof"},
{"keyword": "interactive proof assistant"},
{"keyword": "interactive theorem prover"},
{"keyword": "interactive theorem proving"},
{"keyword": "interactive theorem proving sch16"},
{"keyword": "interactive visual theorem prover"},
{"keyword": "interactively find"},
{"keyword": "interdisciplinary project"},
{"keyword": "interest accrued"},
{"keyword": "interest distributed"},
{"keyword": "interest rate"},
{"keyword": "interesting case study"},
{"keyword": "interesting data structure"},
{"keyword": "interesting formalization exercise"},
{"keyword": "interesting format"},
{"keyword": "interesting proofs"},
{"keyword": "interesting property"},
{"keyword": "interesting result"},
{"keyword": "interesting syntactic subclass"},
{"keyword": "interleaves"},
{"keyword": "interleaving parallel composition"},
{"keyword": "intermediate encoding"},
{"keyword": "intermediate relations"},
{"keyword": "intermediate results"},
{"keyword": "intermediate step"},
{"keyword": "internal direct product"},
{"keyword": "internal equivalences"},
{"keyword": "internal execution clocking"},
{"keyword": "internal path length"},
{"keyword": "internal path length relates"},
{"keyword": "internal representation"},
{"keyword": "internal timing channels"},
{"keyword": "internally vertex-disjoint paths"},
{"keyword": "international conference"},
{"keyword": "international mathematical olympiad 2019"},
{"keyword": "international system"},
{"keyword": "interpolation nodes"},
{"keyword": "interpreting intensional type systems"},
{"keyword": "intersecting chords theorem"},
{"keyword": "intersection numbers"},
{"keyword": "intersection type systems"},
{"keyword": "interval analysis"},
{"keyword": "interval arithmetic"},
{"keyword": "interval calculus"},
{"keyword": "interval logics"},
{"keyword": "interval temporal logics"},
{"keyword": "interval traversing results"},
{"keyword": "interval trees"},
{"keyword": "intervals"},
{"keyword": "intransitive interference relations"},
{"keyword": "intransitive noninterference policy"},
{"keyword": "intransitive policy"},
{"keyword": "intransitive purge function"},
{"keyword": "intraprocedural proof"},
{"keyword": "intricate cyclic program"},
{"keyword": "intricate distributed protocol"},
{"keyword": "intricate part"},
{"keyword": "intrinsic properties"},
{"keyword": "introducing constructor functions"},
{"keyword": "introductory sections"},
{"keyword": "intuitionistic logic"},
{"keyword": "intuitive arguments found"},
{"keyword": "intuitive combinatorial proof"},
{"keyword": "intuitive desired security policy"},
{"keyword": "intuitively secure programs"},
{"keyword": "invariance"},
{"keyword": "invariant based programming"},
{"keyword": "invariant based programs"},
{"keyword": "invariant factor decomposition"},
{"keyword": "invariant generation"},
{"keyword": "inventors vickrey"},
{"keyword": "inventory management"},
{"keyword": "inverse function"},
{"keyword": "inverse limit"},
{"keyword": "inverse operations"},
{"keyword": "inverse squares"},
{"keyword": "inverse transform ifntt"},
{"keyword": "inverse transform intt"},
{"keyword": "inversion rules"},
{"keyword": "inversions"},
{"keyword": "investigate mathematical structures"},
{"keyword": "involve polynomial interpretations"},
{"keyword": "involve regular expressions"},
{"keyword": "involved path"},
{"keyword": "involves extensive reasoning"},
{"keyword": "io monad"},
{"keyword": "ip address ranges"},
{"keyword": "ip-route command"},
{"keyword": "iptables match condition"},
{"keyword": "ipurge unwinding theorem"},
{"keyword": "ipv4 address allocation"},
{"keyword": "ipv4 addresses"},
{"keyword": "ipv6 address space"},
{"keyword": "ipv6 addresses"},
{"keyword": "irrational numbers"},
{"keyword": "irrationality criteria"},
{"keyword": "irreducible cfgs"},
{"keyword": "irreducible polynomial"},
{"keyword": "irreducible representation"},
{"keyword": "irregular primes"},
{"keyword": "irvine observe"},
{"keyword": "isafol isafol authors"},
{"keyword": "isafol project isafol"},
{"keyword": "isafor ceta project"},
{"keyword": "isafor ceta-system"},
{"keyword": "isar conversion"},
{"keyword": "isar proof"},
{"keyword": "isomorphism classes"},
{"keyword": "isomorphism preserves order"},
{"keyword": "isomorphism theorem"},
{"keyword": "isomorphisms results"},
{"keyword": "isoscele triangles"},
{"keyword": "isosceles triangle theorem"},
{"keyword": "iteration operators"},
{"keyword": "iterative interpretive process"},
{"keyword": "iterative versions"},
{"keyword": "iteratively solve finite mdps"},
{"keyword": "itp 2011 paper"},
{"keyword": "itp 2015 publication"},
{"keyword": "itp 2017 paper"},
{"keyword": "itp-2015 peter lammich"},
{"keyword": "itp-2016 paper"},
{"keyword": "ivana vukotic"},
{"keyword": "j3202"},
{"keyword": "jacobi symbol"},
{"keyword": "james margetson"},
{"keyword": "jamie wright"},
{"keyword": "jan kret nsk"},
{"keyword": "jan kretinsky proposed"},
{"keyword": "jasmin blanchette"},
{"keyword": "java interactive verification environment"},
{"keyword": "java language architecture"},
{"keyword": "java se 8 specification"},
{"keyword": "javascript object notation"},
{"keyword": "javascript world"},
{"keyword": "javier esparza"},
{"keyword": "jeroen ketema"},
{"keyword": "jinja source"},
{"keyword": "jinja source code semantics"},
{"keyword": "jir iacute"},
{"keyword": "joachim breitner"},
{"keyword": "johann bernoulli"},
{"keyword": "john bruntse larsen"},
{"keyword": "john harrison"},
{"keyword": "john wickerson"},
{"keyword": "join ordering algorithm ikkbz"},
{"keyword": "join trees"},
{"keyword": "join-irreducible elements"},
{"keyword": "jones polynomial"},
{"keyword": "jordan curve theorem"},
{"keyword": "jordan decomposition theorem"},
{"keyword": "jordan normal form"},
{"keyword": "jordan_normal_form afp entry"},
{"keyword": "json encoded data"},
{"keyword": "json grammar"},
{"keyword": "json objects"},
{"keyword": "json-encoded data"},
{"keyword": "julien narboux"},
{"keyword": "k-1 a_k"},
{"keyword": "k-1 d_k sum_"},
{"keyword": "k-universal hash family"},
{"keyword": "kan extensions"},
{"keyword": "karel hrbacek"},
{"keyword": "keeping track"},
{"keyword": "keith conrad"},
{"keyword": "kepler conjecture"},
{"keyword": "key agreement protocols"},
{"keyword": "key aspect"},
{"keyword": "key cards"},
{"keyword": "key component"},
{"keyword": "key composition property"},
{"keyword": "key concepts"},
{"keyword": "key confirmation"},
{"keyword": "key construction"},
{"keyword": "key contribution"},
{"keyword": "key encapsulation mechanism"},
{"keyword": "key establishment protocols"},
{"keyword": "key proofs"},
{"keyword": "key properties"},
{"keyword": "key properties thereof"},
{"keyword": "key range"},
{"keyword": "key resource assertions"},
{"keyword": "key result"},
{"keyword": "key undecidability result present"},
{"keyword": "key value-pairs"},
{"keyword": "keyed-hash message authentication code"},
{"keyword": "kind"},
{"keyword": "kind mapped"},
{"keyword": "kleene algebra"},
{"keyword": "kleene algebra hierarchy"},
{"keyword": "kleene algebras endowed"},
{"keyword": "kleene algebras remain"},
{"keyword": "kleene normal form"},
{"keyword": "kleene relation algebras"},
{"keyword": "kleene star"},
{"keyword": "kleene star arise"},
{"keyword": "kleene star operation"},
{"keyword": "klein nicta"},
{"keyword": "klein-beltrami model"},
{"keyword": "kleisli category"},
{"keyword": "kmp algorithm"},
{"keyword": "knaster tarski theorem"},
{"keyword": "knight"},
{"keyword": "knight visits"},
{"keyword": "knot theory"},
{"keyword": "knowledge"},
{"keyword": "knowledge compilation"},
{"keyword": "knowledge gained"},
{"keyword": "knuth bendix orders"},
{"keyword": "knuth morris pratt exploits"},
{"keyword": "knuth ndash"},
{"keyword": "knuth-morris-pratt algorithm"},
{"keyword": "konrad knopp"},
{"keyword": "kronecker tensor product"},
{"keyword": "kuratowski subgraphs"},
{"keyword": "kyber algorithms"},
{"keyword": "l-shaped tiles"},
{"keyword": "labeled transition system"},
{"keyword": "labeled trees"},
{"keyword": "labelled directed graphs"},
{"keyword": "labelled natural deduction system"},
{"keyword": "labour cost"},
{"keyword": "labour intensive"},
{"keyword": "lagrange interpolation"},
{"keyword": "lam09 peter lammich"},
{"keyword": "lambda -calculus"},
{"keyword": "lambda calculus"},
{"keyword": "lambda-calculus"},
{"keyword": "lambda-free recursive path orders"},
{"keyword": "lambert series"},
{"keyword": "landau expressions"},
{"keyword": "landau symbol"},
{"keyword": "landmark information flow property"},
{"keyword": "landmark theorem due"},
{"keyword": "landmark work collective choice"},
{"keyword": "language"},
{"keyword": "language determinism"},
{"keyword": "language emptiness problem"},
{"keyword": "language features"},
{"keyword": "language features monadic sequencing"},
{"keyword": "language inclusion"},
{"keyword": "language primitives"},
{"keyword": "language processing"},
{"keyword": "language theory"},
{"keyword": "language-based non-interference property"},
{"keyword": "languages generated"},
{"keyword": "laplace transform"},
{"keyword": "large class"},
{"keyword": "large collection"},
{"keyword": "large computations"},
{"keyword": "large financial losses"},
{"keyword": "large formalization efforts"},
{"keyword": "large fragment"},
{"keyword": "large graphs"},
{"keyword": "large library"},
{"keyword": "large number"},
{"keyword": "large numbers states"},
{"keyword": "large part"},
{"keyword": "large real-world firewall"},
{"keyword": "large transitive closures"},
{"keyword": "large tree automata"},
{"keyword": "large-scale shared mutable content"},
{"keyword": "large-scale stream processing systems"},
{"keyword": "largely independent"},
{"keyword": "larger arrangements due"},
{"keyword": "larger cardinality"},
{"keyword": "larger memory"},
{"keyword": "larger rings"},
{"keyword": "largest power"},
{"keyword": "larry paulson"},
{"keyword": "latest version"},
{"keyword": "latin rectangle"},
{"keyword": "latin square"},
{"keyword": "lattice basis reduction"},
{"keyword": "lattice ordered groups"},
{"keyword": "lattice point"},
{"keyword": "lattice supremum providing"},
{"keyword": "lattice theory"},
{"keyword": "lattice vector"},
{"keyword": "lattice-based cryptography"},
{"keyword": "lattice-based post-quantum cryptography"},
{"keyword": "lattice-theoretic concepts"},
{"keyword": "laurent expansion"},
{"keyword": "law"},
{"keyword": "lawrence paulson"},
{"keyword": "lazy list"},
{"keyword": "lazy sequences"},
{"keyword": "lazy-list equality"},
{"keyword": "leading coefficient"},
{"keyword": "leading power-product"},
{"keyword": "learned clauses"},
{"keyword": "lebesgue measure"},
{"keyword": "lebesgue-style integration plays"},
{"keyword": "lecture notes"},
{"keyword": "lee cl73"},
{"keyword": "left part"},
{"keyword": "left-invariant smooth vector fields"},
{"keyword": "leftmost reduction"},
{"keyword": "leftmost reduction theorem"},
{"keyword": "lehmer"},
{"keyword": "lehmer presented criterions"},
{"keyword": "lehmer test"},
{"keyword": "lei97 alexander leitsch"},
{"keyword": "leitsch lei97"},
{"keyword": "lemma"},
{"keyword": "lemma based"},
{"keyword": "lemma statements"},
{"keyword": "lemmas required"},
{"keyword": "lend money"},
{"keyword": "lending funds"},
{"keyword": "length constraints"},
{"keyword": "lens algebra"},
{"keyword": "lens class"},
{"keyword": "lens classes"},
{"keyword": "lens laws"},
{"keyword": "lenstra lenstra lov 225"},
{"keyword": "leq alpha"},
{"keyword": "leq mathtt length"},
{"keyword": "level sequences"},
{"keyword": "level-based interference relation"},
{"keyword": "levi identities"},
{"keyword": "lexicographic algorithm incorporating"},
{"keyword": "lexicographic extensions"},
{"keyword": "liberal paradox"},
{"keyword": "library base"},
{"keyword": "lidl"},
{"keyword": "lie group"},
{"keyword": "lies strictly"},
{"keyword": "life table"},
{"keyword": "lift larger classes"},
{"keyword": "lift universally quantified equations"},
{"keyword": "lift_definition command"},
{"keyword": "lifting"},
{"keyword": "lifting algebraic laws point-wise"},
{"keyword": "lifting function application"},
{"keyword": "lifting invariants"},
{"keyword": "lifting operation"},
{"keyword": "lifting package"},
{"keyword": "lifting step"},
{"keyword": "lifts resolution derivation steps"},
{"keyword": "light-weight type system"},
{"keyword": "lim"},
{"keyword": "limit process"},
{"keyword": "limit process exists"},
{"keyword": "limiting parallels axiom"},
{"keyword": "limits"},
{"keyword": "limits exist"},
{"keyword": "linear"},
{"keyword": "linear algebra"},
{"keyword": "linear algebra libraries"},
{"keyword": "linear algebraic techniques"},
{"keyword": "linear bound argument"},
{"keyword": "linear combination"},
{"keyword": "linear constraints"},
{"keyword": "linear diophantine equations"},
{"keyword": "linear equations"},
{"keyword": "linear independence"},
{"keyword": "linear inequalities"},
{"keyword": "linear input constraints"},
{"keyword": "linear inqualities"},
{"keyword": "linear integer polynomial"},
{"keyword": "linear logics"},
{"keyword": "linear map"},
{"keyword": "linear order"},
{"keyword": "linear ordered fields"},
{"keyword": "linear pass homomorphic application"},
{"keyword": "linear polynomial interpretations"},
{"keyword": "linear programs"},
{"keyword": "linear real arithmetic"},
{"keyword": "linear size"},
{"keyword": "linear temporal logic"},
{"keyword": "linear time"},
{"keyword": "linear transformations"},
{"keyword": "linear upper bound"},
{"keyword": "linear variable-separated rewrite systems"},
{"keyword": "linear-time temporal logic"},
{"keyword": "linear-time temporal properties"},
{"keyword": "linearised looplessly"},
{"keyword": "linearly independent"},
{"keyword": "linearly ordered borel-spaces"},
{"keyword": "linearly ordered commutative semigroups"},
{"keyword": "linearly ordered group"},
{"keyword": "linearly ordered sets"},
{"keyword": "link tangle equivalence"},
{"keyword": "linux firewall iptables"},
{"keyword": "linux netfilter iptables firewall"},
{"keyword": "linux-based firewall"},
{"keyword": "linux-based router"},
{"keyword": "linux-style router"},
{"keyword": "liouville numbers"},
{"keyword": "lipschitz maps"},
{"keyword": "lipschitz-continuous interval isotone functions"},
{"keyword": "list"},
{"keyword": "list interleavings"},
{"keyword": "list lookup operation"},
{"keyword": "list module"},
{"keyword": "list operations"},
{"keyword": "list type"},
{"keyword": "list update algorithms"},
{"keyword": "list update problem"},
{"keyword": "lists representation"},
{"keyword": "litte theorem"},
{"keyword": "llists"},
{"keyword": "lll algorithm"},
{"keyword": "lll basis reduction algorithm"},
{"keyword": "lmw09 peter lammich"},
{"keyword": "local clock"},
{"keyword": "local hidden variable hypothesis"},
{"keyword": "local hidden variables"},
{"keyword": "local lexing"},
{"keyword": "local lexing semantics"},
{"keyword": "local parallel compositions"},
{"keyword": "local type definitions"},
{"keyword": "locale assumptions"},
{"keyword": "locale assumptions correspond"},
{"keyword": "locale eval lowbar"},
{"keyword": "locale fixing"},
{"keyword": "locale mechanism"},
{"keyword": "locale-centric approach"},
{"keyword": "locally compact hausdorff spaces"},
{"keyword": "locally control back-end settings"},
{"keyword": "locally finite"},
{"keyword": "locally nameless representation"},
{"keyword": "locally ringed space"},
{"keyword": "lock synchronisation"},
{"keyword": "lockstep models"},
{"keyword": "log levels"},
{"keyword": "log log"},
{"keyword": "log-gamma function"},
{"keyword": "logarithmic amortized complexity"},
{"keyword": "logarithmic expected time"},
{"keyword": "logarithmic time"},
{"keyword": "logarithmic upper bound"},
{"keyword": "logger configurations"},
{"keyword": "logging-dependent message anonymity"},
{"keyword": "logging-independent message anonymity"},
{"keyword": "logic"},
{"keyword": "logic due"},
{"keyword": "logic programming"},
{"keyword": "logic tla merz 1999"},
{"keyword": "logical approaches"},
{"keyword": "logical calculus"},
{"keyword": "logical connectives"},
{"keyword": "logical foundation"},
{"keyword": "logical reasoning"},
{"keyword": "logical systems"},
{"keyword": "logically equivalent"},
{"keyword": "logically equivalent quantifier-free formula"},
{"keyword": "logically exclusive"},
{"keyword": "logically safe"},
{"keyword": "logics denote regular languages"},
{"keyword": "logics feature recovery operators"},
{"keyword": "longer guaranteed"},
{"keyword": "longer holds"},
{"keyword": "longer periods"},
{"keyword": "longer valid"},
{"keyword": "longest lyndon suffix"},
{"keyword": "longest recognized substrings"},
{"keyword": "loop freedom"},
{"keyword": "lov aacutesz local lemma"},
{"keyword": "low edge probability"},
{"keyword": "low-degree polynomials"},
{"keyword": "lower bound"},
{"keyword": "lower semicontinuous"},
{"keyword": "lower semicontinuous hull"},
{"keyword": "lower-level language based"},
{"keyword": "lp spaces"},
{"keyword": "lsfa 2020 paper"},
{"keyword": "ltl formula"},
{"keyword": "ltl model checker"},
{"keyword": "ltl properties"},
{"keyword": "ltl yielding"},
{"keyword": "ltl3 directly correspond"},
{"keyword": "lu cleverly extended"},
{"keyword": "lucas ndash"},
{"keyword": "lyndon words"},
{"keyword": "lyndon-sch tzenberger theorem"},
{"keyword": "mac lane"},
{"keyword": "macaulay matrices"},
{"keyword": "macaulay matrix"},
{"keyword": "macaulay matrix constructed"},
{"keyword": "machine checked collections framework"},
{"keyword": "machine checked proofs"},
{"keyword": "machine configuration"},
{"keyword": "machine language"},
{"keyword": "machine learning"},
{"keyword": "machine words"},
{"keyword": "machine-assisted proof"},
{"keyword": "machine-checked correctness theorems"},
{"keyword": "machine-checked proofs"},
{"keyword": "machine-checked text annex"},
{"keyword": "machine-checked tree automata library"},
{"keyword": "machine-checked version"},
{"keyword": "machine-verifiable proof certificates"},
{"keyword": "maclaurin formula"},
{"keyword": "maclaurin series"},
{"keyword": "maclaurin summation formula"},
{"keyword": "magic wand"},
{"keyword": "magic wand assertion"},
{"keyword": "magic wand formula"},
{"keyword": "magic wand mathbin"},
{"keyword": "main advantage"},
{"keyword": "main characteristics"},
{"keyword": "main concepts covered"},
{"keyword": "main concern"},
{"keyword": "main contribution"},
{"keyword": "main crypto_standards theory"},
{"keyword": "main difference"},
{"keyword": "main entry point"},
{"keyword": "main goal"},
{"keyword": "main motivation"},
{"keyword": "main novelty"},
{"keyword": "main operation"},
{"keyword": "main order fully coincides"},
{"keyword": "main premise"},
{"keyword": "main result"},
{"keyword": "main results verified"},
{"keyword": "main routing table"},
{"keyword": "main themes"},
{"keyword": "main theorem"},
{"keyword": "main theorem relates"},
{"keyword": "main theorem states"},
{"keyword": "main thrust"},
{"keyword": "main topics"},
{"keyword": "mainstream structures"},
{"keyword": "maintain hidden state"},
{"keyword": "maintaining knowledge"},
{"keyword": "major case study"},
{"keyword": "major goal"},
{"keyword": "manipulating data types"},
{"keyword": "mansky"},
{"keyword": "manual alpha-conversions"},
{"keyword": "manual approach"},
{"keyword": "manual proofs"},
{"keyword": "many-sorted first-order logic"},
{"keyword": "many-sorted problem"},
{"keyword": "map lists"},
{"keyword": "mapping method"},
{"keyword": "mapping regular expressions"},
{"keyword": "mapsto sum_"},
{"keyword": "marginal measure"},
{"keyword": "margulis-gabber-galil graphs"},
{"keyword": "mark 1 machine"},
{"keyword": "marked regular expressions"},
{"keyword": "markov chains"},
{"keyword": "markov decision processes"},
{"keyword": "marriage theorem"},
{"keyword": "martingale convergence theorem"},
{"keyword": "martingale convergence theorem states"},
{"keyword": "mason ndash"},
{"keyword": "master students"},
{"keyword": "master theorem"},
{"keyword": "master theorem based"},
{"keyword": "match expression"},
{"keyword": "matching"},
{"keyword": "material decribed"},
{"keyword": "mathbf meas"},
{"keyword": "mathbf sim gamma phi"},
{"keyword": "mathcal"},
{"keyword": "mathematical areas"},
{"keyword": "mathematical book written"},
{"keyword": "mathematical components"},
{"keyword": "mathematical development"},
{"keyword": "mathematical development presented"},
{"keyword": "mathematical formulation"},
{"keyword": "mathematical framework"},
{"keyword": "mathematical logic"},
{"keyword": "mathematical machinery"},
{"keyword": "mathematical sets"},
{"keyword": "mathematical structures"},
{"keyword": "mathematical text"},
{"keyword": "mathematical texts referring"},
{"keyword": "mathematical theories"},
{"keyword": "mathematical tools"},
{"keyword": "mathematical tripos taught"},
{"keyword": "mathematically precise theory"},
{"keyword": "mathematics stack exchange page"},
{"keyword": "mathsf approxmc"},
{"keyword": "mathsf approxmc returns"},
{"keyword": "mathtt length"},
{"keyword": "mathtt lists"},
{"keyword": "mathtt sat"},
{"keyword": "matrices represented"},
{"keyword": "matrix equation"},
{"keyword": "matrix rank"},
{"keyword": "matrix representation"},
{"keyword": "matrix theory"},
{"keyword": "matryoshka website"},
{"keyword": "matt devos"},
{"keyword": "max-cut problem"},
{"keyword": "max-flow min-cut theorem"},
{"keyword": "maximal consistent saturated sets"},
{"keyword": "maximal consistent set"},
{"keyword": "maximal load factors"},
{"keyword": "maximal normal subgroups"},
{"keyword": "maximally consistent"},
{"keyword": "maximally consistent sets"},
{"keyword": "maximize reuse"},
{"keyword": "maximum cardinality"},
{"keyword": "maximum cardinality matching"},
{"keyword": "maximum determination"},
{"keyword": "maximum element"},
{"keyword": "maximum flow"},
{"keyword": "maximum norm"},
{"keyword": "maximum reachability probabilities"},
{"keyword": "maximum segment sum problem"},
{"keyword": "maximum-flow minimal-cut theorem"},
{"keyword": "mcss based"},
{"keyword": "mdp model checking"},
{"keyword": "meaningless encodings"},
{"keyword": "measurable"},
{"keyword": "measurable set"},
{"keyword": "measurable space"},
{"keyword": "measurable space generated"},
{"keyword": "measurable subset"},
{"keyword": "measure preserving transformations"},
{"keyword": "measure theoretic arguments"},
{"keyword": "measure theory"},
{"keyword": "measuring angles"},
{"keyword": "mechanical derivation"},
{"keyword": "mechanical theorem proving"},
{"keyword": "mechanically supported logic analysis"},
{"keyword": "mechanically verifying algorithms"},
{"keyword": "mechanised proofs"},
{"keyword": "mechanised proofs offermat"},
{"keyword": "mechanising proofs"},
{"keyword": "mechanized proof"},
{"keyword": "mechanized soundness proof"},
{"keyword": "mechanizing gauss"},
{"keyword": "meet schneider"},
{"keyword": "meeting point"},
{"keyword": "meld operations"},
{"keyword": "memory implementations"},
{"keyword": "memory model"},
{"keyword": "memory model theory"},
{"keyword": "memory resolve"},
{"keyword": "memory semantics"},
{"keyword": "mentioned algorithms"},
{"keyword": "mentioned logics"},
{"keyword": "mentioned properties"},
{"keyword": "mere addition paradox"},
{"keyword": "mergesort algorithm"},
{"keyword": "merkle functors"},
{"keyword": "message"},
{"keyword": "message anonymity"},
{"keyword": "message confidentiality"},
{"keyword": "message filters"},
{"keyword": "metaphysical questions"},
{"keyword": "metaphysical theory"},
{"keyword": "metatheoretical observation"},
{"keyword": "metatheoretical properties"},
{"keyword": "method called separata"},
{"keyword": "method calls"},
{"keyword": "method exploits"},
{"keyword": "method normalises applicative expressions"},
{"keyword": "methodology chosen"},
{"keyword": "metric dynamic logic"},
{"keyword": "metric embeddings"},
{"keyword": "metric first-order dynamic logic"},
{"keyword": "metric first-order temporal logic"},
{"keyword": "metric space"},
{"keyword": "metric temporal logic"},
{"keyword": "mfodl supports real-time constraints"},
{"keyword": "mfotl formulas"},
{"keyword": "microsoft research"},
{"keyword": "mid 80s"},
{"keyword": "mild condition attractivity"},
{"keyword": "miller ndash"},
{"keyword": "minimal complete sets"},
{"keyword": "minimal dfas"},
{"keyword": "minimal polynomial"},
{"keyword": "minimal set"},
{"keyword": "minimal space usage"},
{"keyword": "minimal ssa form"},
{"keyword": "minimal unsatisfiable cores"},
{"keyword": "minimisation"},
{"keyword": "minimization algorithm"},
{"keyword": "minimum weight basis"},
{"keyword": "minimum weighted path length"},
{"keyword": "minkowski inequalities"},
{"keyword": "minkowski space-time"},
{"keyword": "minkowski spacetime"},
{"keyword": "minor corrections"},
{"keyword": "minor technical issue"},
{"keyword": "minsky configurations"},
{"keyword": "minsky machines"},
{"keyword": "mirroring beringer"},
{"keyword": "mismatched character"},
{"keyword": "missing gaps"},
{"keyword": "mit press 1995"},
{"keyword": "mitigate rounding errors"},
{"keyword": "mixed-integer solutions"},
{"keyword": "mixed-product property"},
{"keyword": "mobile computing"},
{"keyword": "mobius base logic"},
{"keyword": "modal collapse"},
{"keyword": "modal kleene algebra"},
{"keyword": "modal logic"},
{"keyword": "modal operators"},
{"keyword": "modal powerset quantale"},
{"keyword": "modal quantales"},
{"keyword": "modal relational type theory"},
{"keyword": "model checker spin"},
{"keyword": "model checkers"},
{"keyword": "model checking"},
{"keyword": "model checking pushdown systems"},
{"keyword": "model compatibility"},
{"keyword": "model complex systems"},
{"keyword": "model count"},
{"keyword": "model entire prover architectures"},
{"keyword": "model existence"},
{"keyword": "model existence theorem"},
{"keyword": "model existence theorem approach"},
{"keyword": "model formulas"},
{"keyword": "model partial correctness"},
{"keyword": "model reactive systems"},
{"keyword": "model refinement"},
{"keyword": "model satisfies"},
{"keyword": "model systems"},
{"keyword": "model total correctness"},
{"keyword": "model unweighted graphs"},
{"keyword": "model weighted graphs"},
{"keyword": "model wireless protocols"},
{"keyword": "model-level og proof"},
{"keyword": "modeling application level protocols"},
{"keyword": "modeling firewall policies"},
{"keyword": "modeling languages"},
{"keyword": "modeling real-time systems"},
{"keyword": "modelling security"},
{"keyword": "models partial functions"},
{"keyword": "modern day politics"},
{"keyword": "modern environment"},
{"keyword": "modern multiprocessors depend"},
{"keyword": "modern sat solvers"},
{"keyword": "modern tools"},
{"keyword": "modern version"},
{"keyword": "modern web browser"},
{"keyword": "modified policy iteration"},
{"keyword": "modified version"},
{"keyword": "modify nodes"},
{"keyword": "modular arithmetic plays"},
{"keyword": "modular assembly kit"},
{"keyword": "modular exponentiation"},
{"keyword": "modular hierarchy"},
{"keyword": "module development"},
{"keyword": "modulo operation"},
{"keyword": "moments independence"},
{"keyword": "monad carries"},
{"keyword": "monad transformers"},
{"keyword": "monadic functions"},
{"keyword": "monadic interpreter"},
{"keyword": "monadic language"},
{"keyword": "monadic refinement framework"},
{"keyword": "monadic second-order logic"},
{"keyword": "monadified version"},
{"keyword": "monetary supply grows"},
{"keyword": "monic irreducible polynomials"},
{"keyword": "monic polynomial"},
{"keyword": "monitor supports aggregation operations"},
{"keyword": "monitoring algorithm"},
{"keyword": "monitoring tools"},
{"keyword": "mono de libre"},
{"keyword": "monochromatic line"},
{"keyword": "monoidal categories"},
{"keyword": "monoidal category"},
{"keyword": "monoidal category rel"},
{"keyword": "monoidal functor"},
{"keyword": "monoids generated"},
{"keyword": "monolithic structure"},
{"keyword": "monotone boolean functions"},
{"keyword": "monotone maps"},
{"keyword": "monotone predicate"},
{"keyword": "monotonic boolean transformers"},
{"keyword": "monotonic functions"},
{"keyword": "monotonic predicate transformers"},
{"keyword": "monotonic property transformers"},
{"keyword": "monotonically decreasing sequence"},
{"keyword": "morally questionable"},
{"keyword": "morris-pratt string matching algorithm"},
{"keyword": "morse lemma asserting"},
{"keyword": "morten konggaard schou"},
{"keyword": "moving forward"},
{"keyword": "msc thesis"},
{"keyword": "msc thesis sch15"},
{"keyword": "mso formulas correspond"},
{"keyword": "multi-head monitoring algorithm"},
{"keyword": "multi-head paradigm"},
{"keyword": "multi-node extension"},
{"keyword": "multi-party computation"},
{"keyword": "multi-stage compiler verifications"},
{"keyword": "multidimensional binary trees"},
{"keyword": "multiple algebraic structures"},
{"keyword": "multiple executions"},
{"keyword": "multiple goods"},
{"keyword": "multiple oblivious transfer"},
{"keyword": "multiple positions"},
{"keyword": "multiple relational databases"},
{"keyword": "multiple-angle formulas"},
{"keyword": "multiplication"},
{"keyword": "multiplication protocol"},
{"keyword": "multiplication syntactically"},
{"keyword": "multiplicative constants"},
{"keyword": "multiplicative group"},
{"keyword": "multiplicative inverses"},
{"keyword": "multiplicative monoid"},
{"keyword": "multiplicative subset"},
{"keyword": "multiset-comparison problems"},
{"keyword": "multitape tm runs"},
{"keyword": "multitape tms"},
{"keyword": "multitape turing machines"},
{"keyword": "multithreaded case"},
{"keyword": "multivariate polynomial rings"},
{"keyword": "multivariate polynomials"},
{"keyword": "multivariate quantifier elimination"},
{"keyword": "multivariate taylor models"},
{"keyword": "mutable references"},
{"keyword": "mutating operations performed"},
{"keyword": "mutilated chess board"},
{"keyword": "mutual independence principle"},
{"keyword": "mutual independence principle proof"},
{"keyword": "mutually inverse"},
{"keyword": "mutually recursive functions"},
{"keyword": "mutually recursive procedures"},
{"keyword": "mutually-recursive definition"},
{"keyword": "myhill nerode theorem"},
{"keyword": "myhill-nerode equivalence relation"},
{"keyword": "myhill-nerode theorem"},
{"keyword": "n2m operation"},
{"keyword": "naive algorithm"},
{"keyword": "naive quantifier expansion"},
{"keyword": "naive union operation"},
{"keyword": "nash-williams discovered"},
{"keyword": "nat-bijection theory"},
{"keyword": "nathan chong"},
{"keyword": "native sequential consistency"},
{"keyword": "natural bijections"},
{"keyword": "natural deduction"},
{"keyword": "natural deduction proof calculus"},
{"keyword": "natural deduction system"},
{"keyword": "natural homomorphism"},
{"keyword": "natural language processing"},
{"keyword": "natural logarithm"},
{"keyword": "natural number"},
{"keyword": "natural number greater"},
{"keyword": "natural numbers 0"},
{"keyword": "natural question"},
{"keyword": "natural transformations"},
{"keyword": "natural transformations simply"},
{"keyword": "natural-language explanations"},
{"keyword": "nature allowing"},
{"keyword": "nearest lattice vector"},
{"keyword": "nearest neighbor algorithm"},
{"keyword": "nearest shadow root"},
{"keyword": "necessarily numbers"},
{"keyword": "negated subquery"},
{"keyword": "negative cycles"},
{"keyword": "negative diagonal entry"},
{"keyword": "negative integers"},
{"keyword": "negative real parts"},
{"keyword": "negative resolution"},
{"keyword": "negative solution"},
{"keyword": "neha rungta"},
{"keyword": "neq 0 text"},
{"keyword": "nested binary joins"},
{"keyword": "nested multiset datatype"},
{"keyword": "nested multiset order"},
{"keyword": "nested multisets"},
{"keyword": "network"},
{"keyword": "network model"},
{"keyword": "network protocols"},
{"keyword": "network security mechanisms"},
{"keyword": "networking protocols"},
{"keyword": "neutral absolute space"},
{"keyword": "neutral social decision scheme"},
{"keyword": "newly detected states"},
{"keyword": "newton interpolation"},
{"keyword": "newton puiseux theorem"},
{"keyword": "next-free ltl formula"},
{"keyword": "nicta l4v"},
{"keyword": "niederreiter"},
{"keyword": "nieto verification"},
{"keyword": "nigsberg bridge problem"},
{"keyword": "nist"},
{"keyword": "nist standarisation process"},
{"keyword": "nnf-based algorithms"},
{"keyword": "no-cloning theorem"},
{"keyword": "no-frills state-exception monad"},
{"keyword": "node labeled 1"},
{"keyword": "nodes"},
{"keyword": "nodes labeled"},
{"keyword": "nominal"},
{"keyword": "nominal datatype package"},
{"keyword": "nominal logic"},
{"keyword": "nominal logic formalism"},
{"keyword": "nominal sets"},
{"keyword": "nominal style"},
{"keyword": "nominal2 library"},
{"keyword": "nominal2 package"},
{"keyword": "non-adjacent distinct vertices"},
{"keyword": "non-atomic keys"},
{"keyword": "non-boolean gray code"},
{"keyword": "non-classical negations"},
{"keyword": "non-consecutive fibonacci numbers"},
{"keyword": "non-deterministic algorithm"},
{"keyword": "non-deterministic automata"},
{"keyword": "non-deterministic buechi-automaton"},
{"keyword": "non-deterministic finite state machine"},
{"keyword": "non-deterministic interpreter"},
{"keyword": "non-deterministic languages"},
{"keyword": "non-deterministic monad"},
{"keyword": "non-deterministic tms"},
{"keyword": "non-elementary worst-case blow-"},
{"keyword": "non-functional requirements"},
{"keyword": "non-linear polynomial interpretations"},
{"keyword": "non-local destabilization mechanism"},
{"keyword": "non-negative cost function"},
{"keyword": "non-negative integer"},
{"keyword": "non-negative real"},
{"keyword": "non-negative real matrix"},
{"keyword": "non-negative real-"},
{"keyword": "non-negative reals a_1"},
{"keyword": "non-negative solutions"},
{"keyword": "non-negative weights w_1"},
{"keyword": "non-obvious closed form"},
{"keyword": "non-real critical point"},
{"keyword": "non-redundant clause learning"},
{"keyword": "non-relational reasoning"},
{"keyword": "non-square natural number"},
{"keyword": "non-strict computations"},
{"keyword": "non-strict function abstractions"},
{"keyword": "non-terminating executions"},
{"keyword": "noncommuting words"},
{"keyword": "noncommuting words form"},
{"keyword": "nondeterminism monad"},
{"keyword": "nondeterministic branching"},
{"keyword": "nondeterministic programs"},
{"keyword": "noninterference proofs"},
{"keyword": "noninterference security"},
{"keyword": "noninterference security applying"},
{"keyword": "noninterference theorem"},
{"keyword": "nonnegative cubes"},
{"keyword": "nontrivial size"},
{"keyword": "nonzero rational number"},
{"keyword": "nora szasz"},
{"keyword": "normal filters"},
{"keyword": "normal form"},
{"keyword": "normal form --"},
{"keyword": "normal form property"},
{"keyword": "normal functions"},
{"keyword": "normal logarithm"},
{"keyword": "normal series"},
{"keyword": "normal strategy"},
{"keyword": "normal subgroups"},
{"keyword": "normalisation algorithm"},
{"keyword": "normalisation procedures"},
{"keyword": "normalise monadic hol terms"},
{"keyword": "normalises monadic expressions"},
{"keyword": "normalization equivalence"},
{"keyword": "normalizing strategy"},
{"keyword": "normed space"},
{"keyword": "notable result"},
{"keyword": "notably holcf"},
{"keyword": "notably poicar recurrence theorem"},
{"keyword": "notes"},
{"keyword": "notes introduction"},
{"keyword": "notions probabilistic noninterference"},
{"keyword": "np-complete optimization problems"},
{"keyword": "np-complete problem"},
{"keyword": "np-hard problem"},
{"keyword": "np-hardness proofs"},
{"keyword": "nu_x"},
{"keyword": "null space"},
{"keyword": "nullable types"},
{"keyword": "number"},
{"keyword": "number partitions"},
{"keyword": "number theoretic result"},
{"keyword": "number theoretic transform"},
{"keyword": "number theory"},
{"keyword": "number-theoretic foundations"},
{"keyword": "number-theoretic functions"},
{"keyword": "number-theoretic lemmas"},
{"keyword": "number-theoretic results"},
{"keyword": "numeral type"},
{"keyword": "numeric constants occurring"},
{"keyword": "numerical algorithms"},
{"keyword": "numerous applications"},
{"keyword": "numerous instances"},
{"keyword": "numerous misunderstandings"},
{"keyword": "numerous models"},
{"keyword": "o-automata framework"},
{"keyword": "object logic"},
{"keyword": "object logic chaudhuri"},
{"keyword": "object logic zfc"},
{"keyword": "object oriented design"},
{"keyword": "object-free style"},
{"keyword": "object-oriented data"},
{"keyword": "object-oriented data-type theories generated"},
{"keyword": "object-oriented programming"},
{"keyword": "objects based"},
{"keyword": "observation set"},
{"keyword": "observe execution times"},
{"keyword": "observed sequence"},
{"keyword": "obtain concrete upper bounds"},
{"keyword": "obtain dynamic programming algorithms"},
{"keyword": "obtain efficient certified algorithms"},
{"keyword": "obtain efficient code"},
{"keyword": "obtain efficient imperative algorithms"},
{"keyword": "obtain executable code"},
{"keyword": "obtain executable versions"},
{"keyword": "obtain liouville numbers"},
{"keyword": "obtain maximally consistent sets"},
{"keyword": "ocaml executable instance"},
{"keyword": "occurrence counts"},
{"keyword": "ocl specification"},
{"keyword": "ocl standard"},
{"keyword": "ocl standard targeting"},
{"keyword": "ocl type system"},
{"keyword": "octet string"},
{"keyword": "october 17-21"},
{"keyword": "octonionic product"},
{"keyword": "odd bernoulli numbers"},
{"keyword": "odd natural numbers"},
{"keyword": "odd ranking"},
{"keyword": "odd-set cover"},
{"keyword": "odd-set cover osc"},
{"keyword": "oded maler"},
{"keyword": "ody x0144"},
{"keyword": "offers low-latency data-"},
{"keyword": "official standard"},
{"keyword": "okamoto sigma-protocols"},
{"keyword": "old_datatype command"},
{"keyword": "omega 1 alpha"},
{"keyword": "omega 1 alpha cdot"},
{"keyword": "omega omega"},
{"keyword": "omega operation"},
{"keyword": "omega-complete non-orders"},
{"keyword": "omnipresent foundational errors"},
{"keyword": "one-complete computably enumerable set"},
{"keyword": "one-dimensional case"},
{"keyword": "one-pass uniform substitutions"},
{"keyword": "one-rule term rewrite systems"},
{"keyword": "one-sided sequent calculus"},
{"keyword": "one-time efforts benefit"},
{"keyword": "ongoing development"},
{"keyword": "ontological argument"},
{"keyword": "ontological conformance-checks"},
{"keyword": "ontology definition language"},
{"keyword": "oopsla 2006 paper"},
{"keyword": "open induction schema based"},
{"keyword": "open problem"},
{"keyword": "open publishing association"},
{"keyword": "open sets"},
{"keyword": "operating system"},
{"keyword": "operation results"},
{"keyword": "operational"},
{"keyword": "operational behavior derived"},
{"keyword": "operational constructs coincide"},
{"keyword": "operational correspondence"},
{"keyword": "operational properties"},
{"keyword": "operational rules"},
{"keyword": "operational semantics"},
{"keyword": "operations efficiently"},
{"keyword": "operations needed"},
{"keyword": "operations run"},
{"keyword": "operator applications"},
{"keyword": "operators"},
{"keyword": "operators combine"},
{"keyword": "opinion"},
{"keyword": "opposite case"},
{"keyword": "optimal binary search trees"},
{"keyword": "optimal running time"},
{"keyword": "optimal stationary deterministic solution"},
{"keyword": "optimality equations"},
{"keyword": "optimisations suggested"},
{"keyword": "optimizations heuristics"},
{"keyword": "optimized variant"},
{"keyword": "optimized version"},
{"keyword": "orbit finite"},
{"keyword": "orbit finite set"},
{"keyword": "orbit-stabiliser theorem"},
{"keyword": "order embedding"},
{"keyword": "order extension"},
{"keyword": "order logic"},
{"keyword": "order relation"},
{"keyword": "order relativity theory"},
{"keyword": "order terms"},
{"keyword": "order theory specrel"},
{"keyword": "order types"},
{"keyword": "order-theoretic concepts"},
{"keyword": "ordered bdd"},
{"keyword": "ordered resolution"},
{"keyword": "ordered semirings"},
{"keyword": "ordering properties"},
{"keyword": "orders"},
{"keyword": "ordinal alpha"},
{"keyword": "ordinal arithmetic"},
{"keyword": "ordinal exponentiation"},
{"keyword": "ordinal sum"},
{"keyword": "ordinary assertional reasoning"},
{"keyword": "ordinary category"},
{"keyword": "ordinary differential equations"},
{"keyword": "ordinary functions"},
{"keyword": "ordinary generating function"},
{"keyword": "ordinary transition systems"},
{"keyword": "org abs 1609"},
{"keyword": "org jasmin_blanchette isafol"},
{"keyword": "org vol-3002 paper7"},
{"keyword": "original afp entry"},
{"keyword": "original algorithm presented"},
{"keyword": "original article"},
{"keyword": "original compilation process"},
{"keyword": "original design"},
{"keyword": "original design based"},
{"keyword": "original expression"},
{"keyword": "original formula"},
{"keyword": "original functional sigma-calculus"},
{"keyword": "original functionality"},
{"keyword": "original gray code"},
{"keyword": "original imperative implementation"},
{"keyword": "original kyber algorithms"},
{"keyword": "original language"},
{"keyword": "original linear program"},
{"keyword": "original motivation"},
{"keyword": "original operational semantics"},
{"keyword": "original paper"},
{"keyword": "original parallel postulate"},
{"keyword": "original presentation"},
{"keyword": "original problem"},
{"keyword": "original proof"},
{"keyword": "original quantifier elimination algorithm"},
{"keyword": "original query"},
{"keyword": "original query evaluates"},
{"keyword": "original theorem statement"},
{"keyword": "original version"},
{"keyword": "originally due"},
{"keyword": "originally expressed"},
{"keyword": "originally obtained"},
{"keyword": "originally reported"},
{"keyword": "orthogonal families"},
{"keyword": "orthogonal transformations"},
{"keyword": "orthogonal vectors"},
{"keyword": "osc"},
{"keyword": "outgoing edges"},
{"keyword": "output channels"},
{"keyword": "output consistency"},
{"keyword": "output infinite sequences"},
{"keyword": "output port"},
{"keyword": "output type"},
{"keyword": "outsourcing data storage"},
{"keyword": "outstanding work"},
{"keyword": "outwards-pointing normal vector"},
{"keyword": "over-approximate relational logics"},
{"keyword": "overriding principle"},
{"keyword": "p-adic fields"},
{"keyword": "pace authentication key"},
{"keyword": "pace secure channel"},
{"keyword": "package algorithms applicable"},
{"keyword": "package logic"},
{"keyword": "pages 170-186"},
{"keyword": "pages 20-34"},
{"keyword": "pages 369-379"},
{"keyword": "pages 525-539"},
{"keyword": "pairing heaps"},
{"keyword": "pairs consisting"},
{"keyword": "pairwise balanced designs"},
{"keyword": "pairwise commuting hermitian matrices"},
{"keyword": "pairwise commuting matrices"},
{"keyword": "pairwise comparison"},
{"keyword": "pairwise coprime square-free polynomials"},
{"keyword": "paper"},
{"keyword": "paper assumptions"},
{"keyword": "paper broadcast psi-calculi"},
{"keyword": "paper compositional verification"},
{"keyword": "paper describes"},
{"keyword": "paper describing"},
{"keyword": "paper detailing"},
{"keyword": "paper enriches hoare"},
{"keyword": "paper formalising fisher"},
{"keyword": "paper local lexing"},
{"keyword": "paper mechanising turing machines"},
{"keyword": "paper multi-head monitoring"},
{"keyword": "paper titled verified"},
{"keyword": "paper transport"},
{"keyword": "paper verified construction"},
{"keyword": "paracomplete logics"},
{"keyword": "paraconsistent engineering"},
{"keyword": "paraconsistent logic avoids"},
{"keyword": "paraconsistent logics"},
{"keyword": "paraconsistent many-"},
{"keyword": "parallel branches"},
{"keyword": "parallel composition"},
{"keyword": "parallel mode"},
{"keyword": "parallel postulates"},
{"keyword": "parallel prefix computations"},
{"keyword": "parallel substitution"},
{"keyword": "parameter set"},
{"keyword": "parameterised process architectures"},
{"keyword": "parameterized proofs"},
{"keyword": "parameterized verification framework"},
{"keyword": "parametric solution"},
{"keyword": "parametricity infrastructure"},
{"keyword": "parametrizable equality functions"},
{"keyword": "parent clauses"},
{"keyword": "parigots -calculus"},
{"keyword": "parity wallet bug"},
{"keyword": "parse trees"},
{"keyword": "parser created"},
{"keyword": "parser generator"},
{"keyword": "parser generator verified"},
{"keyword": "parser monad built"},
{"keyword": "parser written"},
{"keyword": "parsing algorithm"},
{"keyword": "parsing concept"},
{"keyword": "part iii"},
{"keyword": "partial binary operation"},
{"keyword": "partial commutativity relationships"},
{"keyword": "partial composition"},
{"keyword": "partial correctness"},
{"keyword": "partial correctness setting"},
{"keyword": "partial data structures"},
{"keyword": "partial derivatives"},
{"keyword": "partial equivalence relations"},
{"keyword": "partial galois connections"},
{"keyword": "partial herbrand interpretations"},
{"keyword": "partial match"},
{"keyword": "partial meet contraction"},
{"keyword": "partial networks"},
{"keyword": "partial orders"},
{"keyword": "partial procedure"},
{"keyword": "partial recursive function"},
{"keyword": "partial semigroups"},
{"keyword": "partial sums"},
{"keyword": "partial synchrony"},
{"keyword": "partially filled"},
{"keyword": "partition function"},
{"keyword": "partition relations concerns generalisations"},
{"keyword": "partition theorem states"},
{"keyword": "partly commented"},
{"keyword": "partly recursive functions found"},
{"keyword": "party cryptographic primitives"},
{"keyword": "party-approval multi-winner elections"},
{"keyword": "party-approval multi-winner voting rules"},
{"keyword": "pascal schreck"},
{"keyword": "password authenticated connection establishment"},
{"keyword": "past experience"},
{"keyword": "past operators"},
{"keyword": "path"},
{"keyword": "path authorization"},
{"keyword": "path authorization mechanism"},
{"keyword": "path integrals"},
{"keyword": "path lengths"},
{"keyword": "path-aware internet architectures"},
{"keyword": "pattern completeness"},
{"keyword": "pattern completeness check"},
{"keyword": "pattern matching"},
{"keyword": "pattern poses"},
{"keyword": "pattern specifications"},
{"keyword": "paul erd"},
{"keyword": "paul thomson"},
{"keyword": "paulson"},
{"keyword": "paulson semantics-based approach"},
{"keyword": "pay special attention"},
{"keyword": "pctl formulas"},
{"keyword": "pdf"},
{"keyword": "peano arithmetic"},
{"keyword": "peculiar mapping argument"},
{"keyword": "pen-and-paper analysis"},
{"keyword": "pen-and-paper counterpart"},
{"keyword": "pen-and-paper proof"},
{"keyword": "pentagonal numbers"},
{"keyword": "perfect field"},
{"keyword": "perfect forward secrecy"},
{"keyword": "perfect logicians"},
{"keyword": "perfect logicians forbidden"},
{"keyword": "perfect matchings"},
{"keyword": "perfect mathematical reals"},
{"keyword": "perfect number theorem"},
{"keyword": "perfect ordinary differential equations"},
{"keyword": "perfect square"},
{"keyword": "perform stream fusion"},
{"keyword": "perform update operations naively"},
{"keyword": "performs comparable"},
{"keyword": "periodic arithmetic functions"},
{"keyword": "periodic bernoulli polynomials"},
{"keyword": "periodic continued fraction expansions"},
{"keyword": "periodic function"},
{"keyword": "periodically adjusting"},
{"keyword": "periodicity lemma"},
{"keyword": "permission amounts held"},
{"keyword": "permissions held"},
{"keyword": "permitting multiset comparisons"},
{"keyword": "perron ndash"},
{"keyword": "persisted size"},
{"keyword": "personal byzantine quorum systems"},
{"keyword": "peter lammich"},
{"keyword": "petersen aplas 2012"},
{"keyword": "phd thesis"},
{"keyword": "phd thesis 3"},
{"keyword": "phd thesis sch02a"},
{"keyword": "phi functions"},
{"keyword": "phi holds"},
{"keyword": "philosophical justification"},
{"keyword": "philosphically grounded basis"},
{"keyword": "physical clocks"},
{"keyword": "physical quantities expressed"},
{"keyword": "pide development environment"},
{"keyword": "pide sub-system"},
{"keyword": "piecewise continuous functions"},
{"keyword": "pierre boutry"},
{"keyword": "pipeline-parallel stream processing"},
{"keyword": "places requirements"},
{"keyword": "planar dynamical systems"},
{"keyword": "planar systems"},
{"keyword": "plane geometry"},
{"keyword": "planetmath article"},
{"keyword": "planning domain definition language"},
{"keyword": "planning system fast-downward"},
{"keyword": "planning tasks language"},
{"keyword": "plas 2009 paper"},
{"keyword": "platonic forms"},
{"keyword": "playfair axiom"},
{"keyword": "pldi 2015 paper"},
{"keyword": "plotkin existential"},
{"keyword": "poincar -bendixson theorem"},
{"keyword": "poincar disc model"},
{"keyword": "poincar disc model development"},
{"keyword": "point-wise reasoning"},
{"keyword": "points constructible"},
{"keyword": "pointwise updates"},
{"keyword": "polar form transformation"},
{"keyword": "policy"},
{"keyword": "policy decision function"},
{"keyword": "policy decision point"},
{"keyword": "policy iteration algorithms"},
{"keyword": "polychronous systems"},
{"keyword": "polygonal number"},
{"keyword": "polygonal number theorems"},
{"keyword": "polylogarithm function"},
{"keyword": "polymorphic edge type"},
{"keyword": "polymorphic lambda-calculus extended"},
{"keyword": "polynomial"},
{"keyword": "polynomial analogue"},
{"keyword": "polynomial division"},
{"keyword": "polynomial factorisation algorithms ndash"},
{"keyword": "polynomial growth"},
{"keyword": "polynomial identity testing"},
{"keyword": "polynomial interpolation"},
{"keyword": "polynomial interpretations"},
{"keyword": "polynomial rings"},
{"keyword": "polynomial sequences"},
{"keyword": "polynomial time"},
{"keyword": "polynomial-time algorithm"},
{"keyword": "polynomial-time basis reduction algorithm"},
{"keyword": "polynomial-time turing machine"},
{"keyword": "polynomially bounded"},
{"keyword": "polynomials t_n"},
{"keyword": "polytimed systems"},
{"keyword": "pop-refinement enables"},
{"keyword": "poplmark challenge designed"},
{"keyword": "popular introduction"},
{"keyword": "popular notion"},
{"keyword": "popular theorems attributed"},
{"keyword": "port proofs"},
{"keyword": "posets preserves suprema"},
{"keyword": "positional determinacy"},
{"keyword": "positive coprime integers"},
{"keyword": "positive fractions"},
{"keyword": "positive integer"},
{"keyword": "positive linear functional"},
{"keyword": "positive llists"},
{"keyword": "positive parts"},
{"keyword": "positive rationals"},
{"keyword": "positive real numbers"},
{"keyword": "positive real roots"},
{"keyword": "positive slopes"},
{"keyword": "posix matching"},
{"keyword": "possibilistic information-flow properties"},
{"keyword": "possibilistic information-flow security properties"},
{"keyword": "possibilistic noninterference afp entry"},
{"keyword": "postponing soundness-critical admissibility checks"},
{"keyword": "potential applications"},
{"keyword": "potential breaks"},
{"keyword": "potential negative cycles"},
{"keyword": "potentials due"},
{"keyword": "power allegories extended"},
{"keyword": "power series connections"},
{"keyword": "power series expansion"},
{"keyword": "power set relation algebras"},
{"keyword": "power sum polynomials"},
{"keyword": "powerful locale system"},
{"keyword": "powerful mathematical tools"},
{"keyword": "powerful result called"},
{"keyword": "powerset algebra"},
{"keyword": "powerset construction mapping nfas"},
{"keyword": "powerset extensions"},
{"keyword": "powerset monad"},
{"keyword": "practical algebraic calculus"},
{"keyword": "practical application"},
{"keyword": "practical calculations"},
{"keyword": "practical combinations"},
{"keyword": "practical interoperability protocol"},
{"keyword": "practical purposes"},
{"keyword": "practical purposes impossible"},
{"keyword": "practically successful method"},
{"keyword": "practically usable verification environment"},
{"keyword": "practically worse time complexity"},
{"keyword": "pragmatic interest"},
{"keyword": "pragmatic reasons"},
{"keyword": "precise algorithms"},
{"keyword": "precise effect"},
{"keyword": "precise proof"},
{"keyword": "precise region"},
{"keyword": "precisely compute roots"},
{"keyword": "precomputed table"},
{"keyword": "predecessor sets"},
{"keyword": "predicate"},
{"keyword": "predicate abstraction"},
{"keyword": "predicate identifies"},
{"keyword": "predicate satisfied"},
{"keyword": "predicate taking"},
{"keyword": "predicate transformer semantics"},
{"keyword": "predicate transformers"},
{"keyword": "predicates stating"},
{"keyword": "predictable processes"},
{"keyword": "preexisting definitions coincide"},
{"keyword": "prefix length"},
{"keyword": "prefix match"},
{"keyword": "prefix order"},
{"keyword": "preliminaries chapter"},
{"keyword": "preliminary evaluations"},
{"keyword": "preorder relations"},
{"keyword": "presburger arithmetic"},
{"keyword": "present"},
{"keyword": "present article"},
{"keyword": "present development"},
{"keyword": "present formalisation formed"},
{"keyword": "present formalization"},
{"keyword": "present interpretations"},
{"keyword": "present polished"},
{"keyword": "present proof development represents"},
{"keyword": "present sufficient conditions"},
{"keyword": "present version hol-csp profits"},
{"keyword": "present work"},
{"keyword": "present work addresses"},
{"keyword": "presentation"},
{"keyword": "presented formalization"},
{"keyword": "presented theory"},
{"keyword": "presented variants increase"},
{"keyword": "presented work"},
{"keyword": "presents experimental results"},
{"keyword": "presents interesting results"},
{"keyword": "preservation lemmas"},
{"keyword": "preserve spectral properties"},
{"keyword": "preserves semantics"},
{"keyword": "preserves suprema"},
{"keyword": "pretty printers"},
{"keyword": "pretty printing"},
{"keyword": "previous afp article"},
{"keyword": "previous afp entry"},
{"keyword": "previous algorithms"},
{"keyword": "previous analogous"},
{"keyword": "previous article"},
{"keyword": "previous axiomatic encoding"},
{"keyword": "previous berlekamp zassenhaus development"},
{"keyword": "previous cc formalization constructive_cryptography"},
{"keyword": "previous entry quasi-borel spaces"},
{"keyword": "previous formalisation"},
{"keyword": "previous theorem"},
{"keyword": "previous unifiers"},
{"keyword": "previous work"},
{"keyword": "previously break"},
{"keyword": "previously replaced term"},
{"keyword": "previously stable unknowns"},
{"keyword": "previously unknown paradox"},
{"keyword": "price determination"},
{"keyword": "price function"},
{"keyword": "price vickrey auction"},
{"keyword": "prim"},
{"keyword": "primal problem"},
{"keyword": "primarily based"},
{"keyword": "primary challenge point"},
{"keyword": "prime fields"},
{"keyword": "prime harmonic series"},
{"keyword": "prime iff"},
{"keyword": "prime ndash"},
{"keyword": "prime number"},
{"keyword": "prime number rdquo"},
{"keyword": "prime number theorem"},
{"keyword": "prime number theorem builds"},
{"keyword": "prime power"},
{"keyword": "prime-factorization algorithms"},
{"keyword": "primes"},
{"keyword": "primitive authentication construct"},
{"keyword": "primitive data types"},
{"keyword": "primitive list mathtt"},
{"keyword": "primitive pythagorean triples"},
{"keyword": "primitive recursive function"},
{"keyword": "primitively corecursive-"},
{"keyword": "primitives"},
{"keyword": "primitivity preserving"},
{"keyword": "principal ideal domains"},
{"keyword": "printing case expressions"},
{"keyword": "prior formalisation"},
{"keyword": "prior formalization attempt"},
{"keyword": "prior non-mechanized soundness proofs"},
{"keyword": "priority"},
{"keyword": "priority queue"},
{"keyword": "priority search tree"},
{"keyword": "privacy-preserving machine-learning framework based"},
{"keyword": "private information"},
{"keyword": "probabilistic arguments"},
{"keyword": "probabilistic behaviour"},
{"keyword": "probabilistic correctness theorems"},
{"keyword": "probabilistic data structure"},
{"keyword": "probabilistic existence proof"},
{"keyword": "probabilistic functional language"},
{"keyword": "probabilistic functional programming language"},
{"keyword": "probabilistic functions"},
{"keyword": "probabilistic loop termination"},
{"keyword": "probabilistic method"},
{"keyword": "probabilistic model"},
{"keyword": "probabilistic model checking"},
{"keyword": "probabilistic noninterference"},
{"keyword": "probabilistic part"},
{"keyword": "probabilistic programs"},
{"keyword": "probabilistic proof systems"},
{"keyword": "probabilistic proofs"},
{"keyword": "probabilistic system types"},
{"keyword": "probabilistic systems"},
{"keyword": "probabilistic timed automata"},
{"keyword": "probabilistic variant"},
{"keyword": "probability kernel"},
{"keyword": "probability kernel kappa"},
{"keyword": "probability larger"},
{"keyword": "probability mass functions"},
{"keyword": "probability monad"},
{"keyword": "probability space"},
{"keyword": "probability theory"},
{"keyword": "probable hidden state sequence"},
{"keyword": "problem arithmetic progressions"},
{"keyword": "problem reduction"},
{"keyword": "problems"},
{"keyword": "process calculi encodings"},
{"keyword": "process control"},
{"keyword": "process crashes"},
{"keyword": "process invariant"},
{"keyword": "process trace"},
{"keyword": "processing components"},
{"keyword": "processor maintains"},
{"keyword": "prod limits_"},
{"keyword": "produce labeled subgoals"},
{"keyword": "produce observable outputs"},
{"keyword": "produce uniformly smaller automata"},
{"keyword": "product spaces"},
{"keyword": "product spaces carry"},
{"keyword": "product type"},
{"keyword": "profound formalism"},
{"keyword": "program -- addressed"},
{"keyword": "program analysis"},
{"keyword": "program compositions"},
{"keyword": "program construction"},
{"keyword": "program dependence graphs"},
{"keyword": "program execution"},
{"keyword": "program executions based"},
{"keyword": "program fulfilling"},
{"keyword": "program logic"},
{"keyword": "program logics similar"},
{"keyword": "program properties"},
{"keyword": "program refinement techniques"},
{"keyword": "program representation"},
{"keyword": "program trace semantics"},
{"keyword": "program traces"},
{"keyword": "program verification"},
{"keyword": "program verification competition"},
{"keyword": "program verification environment"},
{"keyword": "programming applications"},
{"keyword": "programming language"},
{"keyword": "programming languages sml"},
{"keyword": "programming languages support working"},
{"keyword": "programs checking certificates"},
{"keyword": "programs written"},
{"keyword": "progress tracking protocol"},
{"keyword": "progressive measurability"},
{"keyword": "progressively measurable"},
{"keyword": "prohibited requests directly"},
{"keyword": "projection functions"},
{"keyword": "projections separate points"},
{"keyword": "projective coordinates"},
{"keyword": "projective geometry"},
{"keyword": "projective plane geometry"},
{"keyword": "projective space geometry"},
{"keyword": "projective spaces"},
{"keyword": "prominent derandomization techniques"},
{"keyword": "promising increased tolerance"},
{"keyword": "promotes proof reuse"},
{"keyword": "pronounced lambda auth"},
{"keyword": "proof"},
{"keyword": "proof applies"},
{"keyword": "proof approach"},
{"keyword": "proof assistant"},
{"keyword": "proof assistant approach"},
{"keyword": "proof assistant coq"},
{"keyword": "proof calculus"},
{"keyword": "proof closely"},
{"keyword": "proof details"},
{"keyword": "proof document supports"},
{"keyword": "proof due"},
{"keyword": "proof easily"},
{"keyword": "proof generalises euler"},
{"keyword": "proof involves removing"},
{"keyword": "proof language"},
{"keyword": "proof method"},
{"keyword": "proof method casify"},
{"keyword": "proof obligations automatically"},
{"keyword": "proof outlines"},
{"keyword": "proof principles"},
{"keyword": "proof relies"},
{"keyword": "proof reuses"},
{"keyword": "proof rules"},
{"keyword": "proof rules indexed"},
{"keyword": "proof search procedure"},
{"keyword": "proof significantly"},
{"keyword": "proof sketch"},
{"keyword": "proof sketches found"},
{"keyword": "proof step"},
{"keyword": "proof structure"},
{"keyword": "proof system"},
{"keyword": "proof techniques"},
{"keyword": "proof technology"},
{"keyword": "proof term checker embedded"},
{"keyword": "proof terms"},
{"keyword": "proof theory"},
{"keyword": "proof theory enables application"},
{"keyword": "proof tool"},
{"keyword": "proof trees"},
{"keyword": "proof-carrying-code style encoding"},
{"keyword": "proofs correct incompletenesses"},
{"keyword": "proofs follow cohen"},
{"keyword": "proofs involving independence"},
{"keyword": "proofs involving linear algebra"},
{"keyword": "proofs necessitate"},
{"keyword": "proofs remain manageable"},
{"keyword": "proofs require"},
{"keyword": "proper generic extension"},
{"keyword": "proper grounding"},
{"keyword": "properties"},
{"keyword": "properties related"},
{"keyword": "property"},
{"keyword": "proposed approach"},
{"keyword": "proposed under-approximate logics"},
{"keyword": "proposes axiom systems"},
{"keyword": "propositional abstract separation logic"},
{"keyword": "propositional calculus"},
{"keyword": "propositional calculus embeds"},
{"keyword": "propositional clauses"},
{"keyword": "propositional fragment"},
{"keyword": "propositional linear-time temporal logic"},
{"keyword": "propositional logic"},
{"keyword": "propositional logic based"},
{"keyword": "propositional predicate symbols"},
{"keyword": "propositional sequent calculus"},
{"keyword": "propositional tableau calculus"},
{"keyword": "protect paths"},
{"keyword": "protecting authorized paths"},
{"keyword": "protocol"},
{"keyword": "protocol abstracts"},
{"keyword": "protocol analysis"},
{"keyword": "protocol analysis tools"},
{"keyword": "protocol transcript"},
{"keyword": "protocol verification"},
{"keyword": "protocols secure"},
{"keyword": "protocols sharing common structure"},
{"keyword": "protocols supported"},
{"keyword": "provably demonstrate"},
{"keyword": "prover implementing"},
{"keyword": "providing formalizations"},
{"keyword": "providing sequential composition"},
{"keyword": "providing stronger guarantees"},
{"keyword": "proving correctness"},
{"keyword": "proving functional correctness"},
{"keyword": "proving information flow security"},
{"keyword": "proving open properties"},
{"keyword": "proving progress"},
{"keyword": "proving safety"},
{"keyword": "proving secure information flow"},
{"keyword": "proving termination"},
{"keyword": "pseudo-bl algebras"},
{"keyword": "pseudo-random functions"},
{"keyword": "pseudo-wajsberg algebras"},
{"keyword": "pseudonatural transformations"},
{"keyword": "pseudonymous identifiers output"},
{"keyword": "psi holds"},
{"keyword": "psi vdash phi"},
{"keyword": "public announcement logic"},
{"keyword": "public key cryptography"},
{"keyword": "public output ports"},
{"keyword": "public ports"},
{"keyword": "public-coin interactive proofs"},
{"keyword": "publication forthcoming"},
{"keyword": "publication tphols 2009"},
{"keyword": "publisher component"},
{"keyword": "publisher subscriber"},
{"keyword": "publisher subscriber pattern"},
{"keyword": "pure exchange economy"},
{"keyword": "pure mathematical subjects"},
{"keyword": "purely algebraic"},
{"keyword": "purely axiomatic manner"},
{"keyword": "purely denotational"},
{"keyword": "purely functional"},
{"keyword": "purely functional algorithms"},
{"keyword": "purely functional implementation based"},
{"keyword": "purely logical result yielding"},
{"keyword": "purely syntactic criteria"},
{"keyword": "purely syntactic normalisation procedure"},
{"keyword": "purposefully incomplete"},
{"keyword": "push-relabel algorithms"},
{"keyword": "pushdown reachability"},
{"keyword": "pushdown reachability algorithms post"},
{"keyword": "pushdown reachability called pdaaal"},
{"keyword": "pushdown systems"},
{"keyword": "putnam exam problems"},
{"keyword": "puzzle"},
{"keyword": "pythagoras law"},
{"keyword": "pythagorean triples"},
{"keyword": "q0 proof system"},
{"keyword": "qdimacs input format"},
{"keyword": "quad int_0 1"},
{"keyword": "quad left"},
{"keyword": "quad text"},
{"keyword": "quadratic irrationals"},
{"keyword": "quadratic real arithmetic"},
{"keyword": "quadratic virtual substitution"},
{"keyword": "quadtrees"},
{"keyword": "qualitative applications"},
{"keyword": "qualitative temporal representation"},
{"keyword": "quality criteria"},
{"keyword": "quantalic structure"},
{"keyword": "quantic nuclei"},
{"keyword": "quantified boolean formula"},
{"keyword": "quantified formula"},
{"keyword": "quantified modal logic kb"},
{"keyword": "quantifier elimination procedures"},
{"keyword": "quantifier elimination theorem"},
{"keyword": "quantitative analysis"},
{"keyword": "quantitative temporal constraints"},
{"keyword": "quantities induces congruences"},
{"keyword": "quantum circuits"},
{"keyword": "quantum computing"},
{"keyword": "quantum hoare logic"},
{"keyword": "quantum information"},
{"keyword": "quantum information theory"},
{"keyword": "quantum measurements"},
{"keyword": "quantum mechanics"},
{"keyword": "quantum prisoner"},
{"keyword": "quantum programs"},
{"keyword": "quantum projective measurements"},
{"keyword": "quantum registers"},
{"keyword": "quantum setting"},
{"keyword": "quantum setting permits"},
{"keyword": "quantum state"},
{"keyword": "quantum teleportation"},
{"keyword": "quartic equation"},
{"keyword": "quasi-borel spaces"},
{"keyword": "quasi-fixed point"},
{"keyword": "quelques probl"},
{"keyword": "query evaluation"},
{"keyword": "query optimization consisting"},
{"keyword": "queue data structures"},
{"keyword": "quickly verified"},
{"keyword": "quickstart guide"},
{"keyword": "quotient construction"},
{"keyword": "rabin automata"},
{"keyword": "racing effects"},
{"keyword": "radical coordinates"},
{"keyword": "radical expressions"},
{"keyword": "radix sort"},
{"keyword": "rado"},
{"keyword": "ramanujan sums gauss sums"},
{"keyword": "ramsey"},
{"keyword": "ramsey theory"},
{"keyword": "randall munroe"},
{"keyword": "random"},
{"keyword": "random binary search trees"},
{"keyword": "random bst"},
{"keyword": "random coin flips"},
{"keyword": "random element"},
{"keyword": "random experiment"},
{"keyword": "random graph"},
{"keyword": "random monad"},
{"keyword": "random order"},
{"keyword": "random pivot choice"},
{"keyword": "random serial dictatorship"},
{"keyword": "random systems"},
{"keyword": "random variable"},
{"keyword": "random walks"},
{"keyword": "random-permutation random-function switching lemma"},
{"keyword": "randomised binary search trees"},
{"keyword": "randomised skip list"},
{"keyword": "randomised treaps"},
{"keyword": "randomized algorithm"},
{"keyword": "randomized approximation algorithms"},
{"keyword": "randomized comb algorithm"},
{"keyword": "randomized list update algorithm"},
{"keyword": "randomly chosen inputs"},
{"keyword": "randomly generated inputs"},
{"keyword": "range queries"},
{"keyword": "range search algorithm"},
{"keyword": "rank nullity theorem entry"},
{"keyword": "rank-nullity theorem"},
{"keyword": "rank-nullity theorem generalises"},
{"keyword": "rank-nullity theorem roughly follow"},
{"keyword": "rapid prototyping"},
{"keyword": "rapidly growing literature"},
{"keyword": "rational actors"},
{"keyword": "rational exponents"},
{"keyword": "rational number"},
{"keyword": "rational polynomials"},
{"keyword": "rational root test"},
{"keyword": "rational roots"},
{"keyword": "re-usable dfs-based algorithms"},
{"keyword": "reachability analysis"},
{"keyword": "reachability relation"},
{"keyword": "reachable nodes"},
{"keyword": "reachable states"},
{"keyword": "reactive systems"},
{"keyword": "reading heads asynchronously"},
{"keyword": "real analysis"},
{"keyword": "real arithmetic"},
{"keyword": "real case"},
{"keyword": "real closed field"},
{"keyword": "real coefficients"},
{"keyword": "real component"},
{"keyword": "real eigenvalue"},
{"keyword": "real error function erf"},
{"keyword": "real exponents"},
{"keyword": "real gamma function gamma"},
{"keyword": "real ideal world paradigm"},
{"keyword": "real matrix"},
{"keyword": "real normed division algebras"},
{"keyword": "real numbers"},
{"keyword": "real polynomial"},
{"keyword": "real polynomial lies inside"},
{"keyword": "real roots"},
{"keyword": "real vector ordering"},
{"keyword": "real vectors spaces"},
{"keyword": "real world"},
{"keyword": "real world distributed systems"},
{"keyword": "real-normed fields"},
{"keyword": "real-time constraints"},
{"keyword": "real-word firewall errors"},
{"keyword": "real-world computer networks"},
{"keyword": "real-world imperative programming languages"},
{"keyword": "real-world programming languages"},
{"keyword": "real-world protocol"},
{"keyword": "realistic virtual machine"},
{"keyword": "reasonable efficiency"},
{"keyword": "reasoning infrastructure"},
{"keyword": "reasoning stays"},
{"keyword": "recently proposed framework"},
{"keyword": "recovering structure"},
{"keyword": "recovery operators"},
{"keyword": "recurrence equations"},
{"keyword": "recurrence relation"},
{"keyword": "recursion combinator"},
{"keyword": "recursion principle"},
{"keyword": "recursion theorems"},
{"keyword": "recursion theory --- definitions"},
{"keyword": "recursive block matrices"},
{"keyword": "recursive datatype"},
{"keyword": "recursive enumerability"},
{"keyword": "recursive evaluation strategy"},
{"keyword": "recursive fashion"},
{"keyword": "recursive fast fourier transform"},
{"keyword": "recursive formalization"},
{"keyword": "recursive function operates"},
{"keyword": "recursive functions"},
{"keyword": "recursive functions heavily inspired"},
{"keyword": "recursive inseparability"},
{"keyword": "recursive path order"},
{"keyword": "recursive procedures"},
{"keyword": "recursive programs based"},
{"keyword": "recursively enumerable set"},
{"keyword": "recursively expressed"},
{"keyword": "recursively inseparable"},
{"keyword": "red-black trees"},
{"keyword": "reduced echelon form"},
{"keyword": "reduced row echelon form"},
{"keyword": "reduces proof obligations"},
{"keyword": "reducible control flow graph"},
{"keyword": "reduction conformance relations"},
{"keyword": "reduction path"},
{"keyword": "reduction step"},
{"keyword": "reduction theorem"},
{"keyword": "reference implementation"},
{"keyword": "reference point"},
{"keyword": "refine system specifications"},
{"keyword": "refined version"},
{"keyword": "refinement approach scales"},
{"keyword": "refinement based verification"},
{"keyword": "refinement calculus literature"},
{"keyword": "refinement framework"},
{"keyword": "refinement kleene algebra"},
{"keyword": "refinement orders"},
{"keyword": "refinement proof"},
{"keyword": "refinement relations"},
{"keyword": "refinement steps"},
{"keyword": "refinement techniques"},
{"keyword": "refinement theorem"},
{"keyword": "refinement theory"},
{"keyword": "refinement type systems"},
{"keyword": "refinement-based theorem proving approach"},
{"keyword": "reflected binary code"},
{"keyword": "reflection formula"},
{"keyword": "reflection-based decision procedure"},
{"keyword": "reflective quantifier elimination procedures"},
{"keyword": "reflexive transitive closure"},
{"keyword": "reflexive transitive closure operation"},
{"keyword": "reflexive-transitive closures"},
{"keyword": "refused events"},
{"keyword": "refutational completeness"},
{"keyword": "refutational theorem proving"},
{"keyword": "refutationally complete"},
{"keyword": "regain sequential consistency"},
{"keyword": "region boundaries explicitly"},
{"keyword": "region quadtrees"},
{"keyword": "register aliasing"},
{"keyword": "register refers"},
{"keyword": "registering applicative functors"},
{"keyword": "registering automatic methods"},
{"keyword": "regular algebra hierarchy"},
{"keyword": "regular algebras"},
{"keyword": "regular algebras axiomatise"},
{"keyword": "regular arithmetic geometric"},
{"keyword": "regular expression"},
{"keyword": "regular expression equivalence"},
{"keyword": "regular expression matches"},
{"keyword": "regular expressions extended"},
{"keyword": "regular expressions needed"},
{"keyword": "regular identities"},
{"keyword": "regular language identity"},
{"keyword": "regular languages"},
{"keyword": "regular operations"},
{"keyword": "regular sets"},
{"keyword": "regular structures"},
{"keyword": "regularity lemma"},
{"keyword": "reifies property patterns"},
{"keyword": "reify property patterns"},
{"keyword": "reimposing upper bounds"},
{"keyword": "relabelling function"},
{"keyword": "related concepts"},
{"keyword": "related equation"},
{"keyword": "related formalizations"},
{"keyword": "related recurrence relations"},
{"keyword": "related rewrite rules"},
{"keyword": "related splay heaps"},
{"keyword": "related static type system"},
{"keyword": "related structures"},
{"keyword": "related theorem"},
{"keyword": "relation algebra"},
{"keyword": "relation algebras equipped"},
{"keyword": "relation algebras extended"},
{"keyword": "relation composition"},
{"keyword": "relation constraints"},
{"keyword": "relation reduces"},
{"keyword": "relation-algebraic concepts"},
{"keyword": "relational concurrent separation logic"},
{"keyword": "relational constructors"},
{"keyword": "relational core"},
{"keyword": "relational language based"},
{"keyword": "relational model"},
{"keyword": "relational monoids"},
{"keyword": "relational parametricity"},
{"keyword": "relational parametricity due"},
{"keyword": "relational program logics"},
{"keyword": "relational tt-lifting"},
{"keyword": "relative safety"},
{"keyword": "relative security"},
{"keyword": "relative security presented"},
{"keyword": "relative soundness results"},
{"keyword": "relativised concepts"},
{"keyword": "relativize paulson"},
{"keyword": "relativized general knowledge"},
{"keyword": "release ownership"},
{"keyword": "relevant definitions"},
{"keyword": "relevant material"},
{"keyword": "relevant proof methods"},
{"keyword": "relevant standard"},
{"keyword": "rely condition generalised"},
{"keyword": "rely guarantee reasoning"},
{"keyword": "rely quotient"},
{"keyword": "rely-guarantee-style reasoning"},
{"keyword": "remain anonymous"},
{"keyword": "remainder sequences"},
{"keyword": "remainder term"},
{"keyword": "remaining computation"},
{"keyword": "remaining rules"},
{"keyword": "removes exception handler entries"},
{"keyword": "removes syntactic sugar"},
{"keyword": "removing intermediate list structures"},
{"keyword": "renaming-enriched sets"},
{"keyword": "repeated factors"},
{"keyword": "repeated opening"},
{"keyword": "replacement rule"},
{"keyword": "replacement theorem"},
{"keyword": "replicated data"},
{"keyword": "replicated databases"},
{"keyword": "replicated datatypes"},
{"keyword": "replicated growable array"},
{"keyword": "represent objects"},
{"keyword": "represent physical quantities"},
{"keyword": "represent quantum states"},
{"keyword": "represent recursively enumerable sets"},
{"keyword": "represent two-dimensional images"},
{"keyword": "representable bounds"},
{"keyword": "representation executable"},
{"keyword": "representation function"},
{"keyword": "representation independence"},
{"keyword": "representation theorem"},
{"keyword": "representative dynamic programming problems"},
{"keyword": "representing algorithms"},
{"keyword": "representing documents"},
{"keyword": "representing legal agreements"},
{"keyword": "represents dominators"},
{"keyword": "reproduce faithfully"},
{"keyword": "reproduced faithfully"},
{"keyword": "requested computation"},
{"keyword": "require"},
{"keyword": "require eventual consistency"},
{"keyword": "require guardedness up-"},
{"keyword": "require intermediate operational semantics"},
{"keyword": "required induction rule"},
{"keyword": "required truth lemma"},
{"keyword": "requirements"},
{"keyword": "requires precise statements"},
{"keyword": "research project"},
{"keyword": "research started"},
{"keyword": "residuated boolean algebra"},
{"keyword": "residuated functions"},
{"keyword": "residuated lattices"},
{"keyword": "residuated transition system"},
{"keyword": "residuation operation"},
{"keyword": "residue classes"},
{"keyword": "resolution calculus"},
{"keyword": "resolution rule"},
{"keyword": "resolution theorem proving chapter"},
{"keyword": "resolvable designs"},
{"keyword": "resource bound"},
{"keyword": "resp"},
{"keyword": "respect stream equivalence"},
{"keyword": "respective frameworks"},
{"keyword": "respective fundamental homomorphism theorems"},
{"keyword": "respective properties"},
{"keyword": "restricted definition"},
{"keyword": "restricted growth functions"},
{"keyword": "restricted identification"},
{"keyword": "restricted schedules"},
{"keyword": "restricted solution space"},
{"keyword": "restricted type"},
{"keyword": "restrictive definition"},
{"keyword": "result due"},
{"keyword": "result presented"},
{"keyword": "resulting automata"},
{"keyword": "resulting automaton"},
{"keyword": "resulting bst"},
{"keyword": "resulting code"},
{"keyword": "resulting framework"},
{"keyword": "resulting generalized counting sort"},
{"keyword": "resulting hierarchy"},
{"keyword": "resulting logic"},
{"keyword": "resulting proof system"},
{"keyword": "resulting recursion induction rules"},
{"keyword": "resulting set"},
{"keyword": "resulting system"},
{"keyword": "resulting tree"},
{"keyword": "results"},
{"keyword": "results hold"},
{"keyword": "results presented"},
{"keyword": "resuting proofs"},
{"keyword": "retain key properties"},
{"keyword": "returns equi-satisfiable inequalities"},
{"keyword": "reusable building blocks"},
{"keyword": "reusable libraries"},
{"keyword": "reusable modelling"},
{"keyword": "reusable probability space framework"},
{"keyword": "reusable proof components"},
{"keyword": "reusable reasoning infrastructure"},
{"keyword": "reusing facts"},
{"keyword": "reverse post order number"},
{"keyword": "reversed morphisms"},
{"keyword": "revision 6081d5be8d08"},
{"keyword": "revision functions launches"},
{"keyword": "rewrite equivalent definitions"},
{"keyword": "rewrite rule"},
{"keyword": "rewriting tactics"},
{"keyword": "rfloor hspace 3mm"},
{"keyword": "rgen villadsen"},
{"keyword": "ribbon proofs"},
{"keyword": "ribbon proofs emphasise"},
{"keyword": "rich expression typing rules"},
{"keyword": "richard char-tung lee"},
{"keyword": "riemann integral"},
{"keyword": "riemann roch"},
{"keyword": "riemann zeta"},
{"keyword": "riemann zeta function"},
{"keyword": "riesz-markov-kakutani representation theorem"},
{"keyword": "right-hand side"},
{"keyword": "rigorous definition"},
{"keyword": "rigorous numerical algorithms"},
{"keyword": "rigorous polynomial approximation"},
{"keyword": "ring theory development"},
{"keyword": "ringed spaces"},
{"keyword": "risk-free lending protocol"},
{"keyword": "rivest commitment schemes"},
{"keyword": "road traffic"},
{"keyword": "rob arthan"},
{"keyword": "robbins conjecture"},
{"keyword": "robin smith"},
{"keyword": "robust supporting theory"},
{"keyword": "roger lipsett"},
{"keyword": "root-balanced trees"},
{"keyword": "roots"},
{"keyword": "rose bohrer"},
{"keyword": "routh-hurwitz stability criterion"},
{"keyword": "routing policies"},
{"keyword": "routing table"},
{"keyword": "routing table entry"},
{"keyword": "rsa cryptography standard"},
{"keyword": "rsa keys"},
{"keyword": "rts"},
{"keyword": "rts algorithm"},
{"keyword": "rts algorithms select"},
{"keyword": "rts definition mandates safety"},
{"keyword": "rts determines"},
{"keyword": "rts-category bf rts dagger"},
{"keyword": "rule induction"},
{"keyword": "rule modus ponens"},
{"keyword": "rules applying"},
{"keyword": "rules controls"},
{"keyword": "run construction rules"},
{"keyword": "runge-kutta methods"},
{"keyword": "running average"},
{"keyword": "running time"},
{"keyword": "running time bounds"},
{"keyword": "runtime bounds"},
{"keyword": "runtime faults"},
{"keyword": "runtime monitoring"},
{"keyword": "runtime verification"},
{"keyword": "runtime verification applications"},
{"keyword": "runtime verification tool"},
{"keyword": "ruzsa triangle inequality"},
{"keyword": "s-finite measure monad"},
{"keyword": "safe approximation"},
{"keyword": "safe distance"},
{"keyword": "safe distance rule"},
{"keyword": "safe navigation operations"},
{"keyword": "safe ocl distincts nullable"},
{"keyword": "safe ocl typing rules"},
{"keyword": "safe regression test selection"},
{"keyword": "safe-range queries evaluate"},
{"keyword": "safe-range query"},
{"keyword": "safely composable"},
{"keyword": "safely composable dom"},
{"keyword": "safely composable web components"},
{"keyword": "safety policy"},
{"keyword": "safety properties"},
{"keyword": "safety violations"},
{"keyword": "salomon sickert"},
{"keyword": "sample authentication protocol"},
{"keyword": "sample computations"},
{"keyword": "sample main"},
{"keyword": "sat solver"},
{"keyword": "sat solver correctness proofs"},
{"keyword": "sat solver descriptions"},
{"keyword": "sat solver installs"},
{"keyword": "sat solver written"},
{"keyword": "satisfaction relation"},
{"keyword": "satisfying assignment"},
{"keyword": "satisfying model"},
{"keyword": "satisfying tuples"},
{"keyword": "saturated mcss"},
{"keyword": "saturation theorem proving"},
{"keyword": "saturation-based heuristic prover"},
{"keyword": "sauer-shelah lemma"},
{"keyword": "scalar multiplication"},
{"keyword": "sch nhage"},
{"keyword": "sch nhage-strassen multiplication"},
{"keyword": "sch02a stefan schwoon"},
{"keyword": "sch15 anders schlichtkrull"},
{"keyword": "sch16 anders schlichtkrull"},
{"keyword": "sch18 anders schlichtkrull"},
{"keyword": "scheduling activity"},
{"keyword": "schneider"},
{"keyword": "schultz refers"},
{"keyword": "schur decomposition"},
{"keyword": "schwartz-zippel lemma"},
{"keyword": "scl backtrack rule"},
{"keyword": "score admits 2"},
{"keyword": "scott-continuous monad morphism"},
{"keyword": "sd-strategy- proofness"},
{"keyword": "sdss random dictatorship"},
{"keyword": "search algorithms"},
{"keyword": "search path"},
{"keyword": "search tree"},
{"keyword": "search trees based"},
{"keyword": "search-time information"},
{"keyword": "search-tree property"},
{"keyword": "second-countable topology"},
{"keyword": "second-order derivation"},
{"keyword": "second-order logic"},
{"keyword": "second-order properties"},
{"keyword": "secret data"},
{"keyword": "secret data manipulated"},
{"keyword": "secret-directed unwinding"},
{"keyword": "secret-directed unwinding disproof method"},
{"keyword": "secure auto-completion"},
{"keyword": "secure hash standard"},
{"keyword": "secure information flow"},
{"keyword": "secure messaging channel established"},
{"keyword": "secure multiple case studies"},
{"keyword": "secure network configurations"},
{"keyword": "secure process"},
{"keyword": "secure stateful implementation"},
{"keyword": "security concepts"},
{"keyword": "security configuration actual firewall"},
{"keyword": "security definition"},
{"keyword": "security expressed"},
{"keyword": "security guarantees"},
{"keyword": "security invariant theory"},
{"keyword": "security invariants"},
{"keyword": "security invariants hold"},
{"keyword": "security policy"},
{"keyword": "security proof"},
{"keyword": "security properties"},
{"keyword": "security properties turn"},
{"keyword": "security property"},
{"keyword": "security protocols based"},
{"keyword": "security requirements expressed"},
{"keyword": "security statements"},
{"keyword": "security systems"},
{"keyword": "security type system"},
{"keyword": "security unwinding technique"},
{"keyword": "security violations"},
{"keyword": "selected programs"},
{"keyword": "selection functions"},
{"keyword": "selection sort"},
{"keyword": "self-adjusting binary search trees"},
{"keyword": "self-contained certifier"},
{"keyword": "self-contained specification"},
{"keyword": "self-referential implementation"},
{"keyword": "seligman-style tableau system"},
{"keyword": "semantic annotations"},
{"keyword": "semantic arguments"},
{"keyword": "semantic back-ends"},
{"keyword": "semantic definitions"},
{"keyword": "semantic domain"},
{"keyword": "semantic embedding"},
{"keyword": "semantic engine"},
{"keyword": "semantic information directly embedded"},
{"keyword": "semantic interpretation"},
{"keyword": "semantic model"},
{"keyword": "semantic optimization vulnerabilities"},
{"keyword": "semantic resolution"},
{"keyword": "semantic side conditions"},
{"keyword": "semantic trees"},
{"keyword": "semantic type soundness"},
{"keyword": "semantical representation"},
{"keyword": "semi-honest security setting"},
{"keyword": "seminal paper natural semantics"},
{"keyword": "sending end host selects"},
{"keyword": "sends pairs"},
{"keyword": "separable characters induced moduli"},
{"keyword": "separate afp entries goedel_hfset_semantic"},
{"keyword": "separate afp entry"},
{"keyword": "separating conjunction"},
{"keyword": "separation algebra"},
{"keyword": "separation kernels"},
{"keyword": "separation logic"},
{"keyword": "separation logic assertion"},
{"keyword": "separation logic connective"},
{"keyword": "separation logic formulae"},
{"keyword": "separation logic framework"},
{"keyword": "separation logic theory"},
{"keyword": "separation logic utilities"},
{"keyword": "separation-logic based correctness proofs"},
{"keyword": "separator smaller"},
{"keyword": "sepref tool"},
{"keyword": "sequence preserves fairness"},
{"keyword": "sequent calculus"},
{"keyword": "sequent calculus prover"},
{"keyword": "sequential compactness"},
{"keyword": "sequential composition"},
{"keyword": "sequential consistency"},
{"keyword": "sequential imperative programming language"},
{"keyword": "sequential java bytecode"},
{"keyword": "sequential semantics"},
{"keyword": "sequentially consistent"},
{"keyword": "serge lang"},
{"keyword": "series consisting"},
{"keyword": "session hol-csp"},
{"keyword": "session keys"},
{"keyword": "set"},
{"keyword": "set based representation"},
{"keyword": "set categories"},
{"keyword": "set category"},
{"keyword": "set category locale"},
{"keyword": "set construction"},
{"keyword": "set mapping"},
{"keyword": "set monad notation"},
{"keyword": "set operations"},
{"keyword": "set partitions"},
{"keyword": "set theoretic formulation"},
{"keyword": "set theory"},
{"keyword": "set theory framework"},
{"keyword": "set-based notion"},
{"keyword": "setup required"},
{"keyword": "severe limitation"},
{"keyword": "shadow dom"},
{"keyword": "shadow root"},
{"keyword": "shadow tree"},
{"keyword": "shallow embedding"},
{"keyword": "shallow embedding manner"},
{"keyword": "shallow learning"},
{"keyword": "shallow semantic embeddings"},
{"keyword": "shallow semantical embeddings"},
{"keyword": "shallowly embed"},
{"keyword": "shallowly embedded"},
{"keyword": "shannon decomposition"},
{"keyword": "shapeless library"},
{"keyword": "share common algorithmic ideas"},
{"keyword": "shared bdd"},
{"keyword": "shared data"},
{"keyword": "shared data commute"},
{"keyword": "shared data structure"},
{"keyword": "shared environments"},
{"keyword": "shared resources"},
{"keyword": "shaz qadeer"},
{"keyword": "sheldon axler"},
{"keyword": "shifting intervals"},
{"keyword": "short applications"},
{"keyword": "short derivation"},
{"keyword": "short entry"},
{"keyword": "short explanation"},
{"keyword": "short outline"},
{"keyword": "short proof"},
{"keyword": "short sketch"},
{"keyword": "short vector produced"},
{"keyword": "shorter refinement proofs"},
{"keyword": "shortest non-"},
{"keyword": "shortest path"},
{"keyword": "shortest vector problem"},
{"keyword": "showcase haskell"},
{"keyword": "showing termination based"},
{"keyword": "side conditions"},
{"keyword": "side effects"},
{"keyword": "side product"},
{"keyword": "sifum_type_systems afp entry"},
{"keyword": "sigma -algebra"},
{"keyword": "sigma -finite"},
{"keyword": "sigma -finite measure"},
{"keyword": "sigma function"},
{"keyword": "signed diffie-hellman"},
{"keyword": "signed measure"},
{"keyword": "signed words"},
{"keyword": "significant bit"},
{"keyword": "significant confidentiality theorems"},
{"keyword": "significant contribution"},
{"keyword": "significant dependencies"},
{"keyword": "significant extensions"},
{"keyword": "significant gain"},
{"keyword": "significant generalization"},
{"keyword": "significant piece"},
{"keyword": "significantly based"},
{"keyword": "significantly differ"},
{"keyword": "significantly expands"},
{"keyword": "significantly larger"},
{"keyword": "significantly reduce"},
{"keyword": "significantly worse"},
{"keyword": "sim gamma"},
{"keyword": "sim phi"},
{"keyword": "sim sqrt 2 pi"},
{"keyword": "simd extensions"},
{"keyword": "similar cegar-"},
{"keyword": "similar construction"},
{"keyword": "similar documentation"},
{"keyword": "similar level"},
{"keyword": "similar normal form"},
{"keyword": "similar preferences"},
{"keyword": "similar proof"},
{"keyword": "similar systems"},
{"keyword": "simon robillard"},
{"keyword": "simple"},
{"keyword": "simple algebraic basis"},
{"keyword": "simple clause learning"},
{"keyword": "simple compilation function"},
{"keyword": "simple executable algorithms"},
{"keyword": "simple exercises"},
{"keyword": "simple firewall model"},
{"keyword": "simple formalization covering"},
{"keyword": "simple functions"},
{"keyword": "simple graph"},
{"keyword": "simple hops"},
{"keyword": "simple hybrid programs"},
{"keyword": "simple imperative language"},
{"keyword": "simple imperative language imp"},
{"keyword": "simple inductive proof"},
{"keyword": "simple interactive proof assistant"},
{"keyword": "simple language"},
{"keyword": "simple model"},
{"keyword": "simple object calculus"},
{"keyword": "simple paper proof"},
{"keyword": "simple polygon"},
{"keyword": "simple procedure call mechanism"},
{"keyword": "simple programming language"},
{"keyword": "simple proofs"},
{"keyword": "simple qbf solvers"},
{"keyword": "simple relation-algebraic semantics"},
{"keyword": "simple solution"},
{"keyword": "simple specification"},
{"keyword": "simple subformula conditions"},
{"keyword": "simple summation conversion"},
{"keyword": "simple techniques"},
{"keyword": "simple theory"},
{"keyword": "simple type system"},
{"keyword": "simple type theory"},
{"keyword": "simple verification conditions"},
{"keyword": "simple verified token"},
{"keyword": "simple while-language"},
{"keyword": "simpler operations"},
{"keyword": "simpler problem"},
{"keyword": "simpler pseudo-random construction avoiding"},
{"keyword": "simpler recursive fixpoint algorithm"},
{"keyword": "simpler secure processes"},
{"keyword": "simpler sigma-calculus based"},
{"keyword": "simpler versions"},
{"keyword": "simplex algorithm"},
{"keyword": "simplicial complex"},
{"keyword": "simplicial complexes"},
{"keyword": "simplifier integration"},
{"keyword": "simplify complex iptables rulests"},
{"keyword": "simplify program verification"},
{"keyword": "simplify protocol verification"},
{"keyword": "simply hermite-lindemann"},
{"keyword": "simply import"},
{"keyword": "simply strengthen"},
{"keyword": "simply transforms"},
{"keyword": "simply-typed lambda terms"},
{"keyword": "simulate minsky machines"},
{"keyword": "simulation code generation"},
{"keyword": "simulation preorders"},
{"keyword": "simulation relation"},
{"keyword": "simulation-based proofs"},
{"keyword": "simulation-based security paradigms"},
{"keyword": "simultaneously empowering end hosts"},
{"keyword": "simultaneously reason"},
{"keyword": "simultaneously solving"},
{"keyword": "sin nx u_n"},
{"keyword": "sin state"},
{"keyword": "single binders"},
{"keyword": "single component"},
{"keyword": "single element"},
{"keyword": "single event list varying"},
{"keyword": "single exponential blow-"},
{"keyword": "single infinite point"},
{"keyword": "single nodes"},
{"keyword": "single parse tree"},
{"keyword": "single partial binary operation"},
{"keyword": "single partial composition operation"},
{"keyword": "single permanent failure"},
{"keyword": "single setting"},
{"keyword": "single strip"},
{"keyword": "single triangle"},
{"keyword": "single unit"},
{"keyword": "single variable ranging"},
{"keyword": "single-set axiomatisation"},
{"keyword": "single-set categories"},
{"keyword": "single-source shortest path function"},
{"keyword": "single-source shortest path problem"},
{"keyword": "sizeable family"},
{"keyword": "sk sum"},
{"keyword": "sketches found"},
{"keyword": "skew binomial heaps"},
{"keyword": "skew heaps"},
{"keyword": "skew links"},
{"keyword": "skew product"},
{"keyword": "skip blocks"},
{"keyword": "skip lists"},
{"keyword": "skip lists consists"},
{"keyword": "sliced graph"},
{"keyword": "slicing based"},
{"keyword": "slide operation"},
{"keyword": "sliding window algorithm"},
{"keyword": "slightly advanced properties"},
{"keyword": "slightly extended"},
{"keyword": "slightly mars"},
{"keyword": "slightly modified"},
{"keyword": "slightly stronger hypothesis"},
{"keyword": "slightly weaker bounds"},
{"keyword": "sligthly modified"},
{"keyword": "small abstract subsystems"},
{"keyword": "small classes"},
{"keyword": "small extensional rts"},
{"keyword": "small imperative language imp"},
{"keyword": "small positive epsilon"},
{"keyword": "small predicate"},
{"keyword": "small set"},
{"keyword": "small step operational semantics"},
{"keyword": "small step program refinement"},
{"keyword": "small step semantics"},
{"keyword": "small-step operational semantics"},
{"keyword": "small-step semantics akin"},
{"keyword": "small-step semantics instrumented"},
{"keyword": "smaller fixed fraction returned"},
{"keyword": "smaller set"},
{"keyword": "smallest disc"},
{"keyword": "smallest number n_"},
{"keyword": "smallest sigma -algebra"},
{"keyword": "smith normal form"},
{"keyword": "sml parser"},
{"keyword": "smooth manifolds"},
{"keyword": "smooth maps"},
{"keyword": "smooth ontology development"},
{"keyword": "smooth vector fields"},
{"keyword": "smt"},
{"keyword": "smt proof"},
{"keyword": "snyder found"},
{"keyword": "so-called desargues"},
{"keyword": "so-called hessenberg"},
{"keyword": "so-called hyperproperties"},
{"keyword": "so-called key equalities"},
{"keyword": "so-called sturm sequences"},
{"keyword": "social decision schemes"},
{"keyword": "social welfare"},
{"keyword": "software framework"},
{"keyword": "software framework incorporates"},
{"keyword": "software security"},
{"keyword": "software tool"},
{"keyword": "software tool authors"},
{"keyword": "solid polyhedra"},
{"keyword": "solomon feferman"},
{"keyword": "solovay ndash"},
{"keyword": "solution"},
{"keyword": "solution obtained"},
{"keyword": "solutions based"},
{"keyword": "solve automatically"},
{"keyword": "solve clique"},
{"keyword": "solve mdps"},
{"keyword": "solved deterministically"},
{"keyword": "solved explicitly"},
{"keyword": "solver based"},
{"keyword": "solving equational systems"},
{"keyword": "solving equations"},
{"keyword": "solving linear programs"},
{"keyword": "solving markov decision processes"},
{"keyword": "sophie tourret"},
{"keyword": "sophisticated languages"},
{"keyword": "sophisticated object-oriented bytecode language"},
{"keyword": "sorted linked lists"},
{"keyword": "sorted linked lists enhanced"},
{"keyword": "sorted monadic equational logic"},
{"keyword": "sorted set"},
{"keyword": "sorting algorithm"},
{"keyword": "sorts objects"},
{"keyword": "sound"},
{"keyword": "sound syntactic criteria"},
{"keyword": "soundness proof"},
{"keyword": "soundness theorem"},
{"keyword": "source code"},
{"keyword": "source coding theorem"},
{"keyword": "source type"},
{"keyword": "source-to-assembly step matching"},
{"keyword": "space complexity"},
{"keyword": "space complexity guarantees"},
{"keyword": "space usage"},
{"keyword": "spacetime location"},
{"keyword": "spanning basic algorithms"},
{"keyword": "spanning subhypergraphs"},
{"keyword": "sparcv8 architecture"},
{"keyword": "sparcv8 cpu"},
{"keyword": "sparcv8 cpu simulator"},
{"keyword": "sparcv8 instruction set architecture"},
{"keyword": "spark certify"},
{"keyword": "sparse grid"},
{"keyword": "sparse relations"},
{"keyword": "spatially-separated views"},
{"keyword": "spatio-temporal multi-modal logic"},
{"keyword": "special attention"},
{"keyword": "special care"},
{"keyword": "special case"},
{"keyword": "special combination"},
{"keyword": "special form"},
{"keyword": "special functions"},
{"keyword": "special halting problem"},
{"keyword": "special issue"},
{"keyword": "specialized sliding window algorithm"},
{"keyword": "specially well-"},
{"keyword": "specific conflict analysis algorithm"},
{"keyword": "specific instantiations"},
{"keyword": "specific integer polynomial"},
{"keyword": "specific isomorphism expressing"},
{"keyword": "specific operations"},
{"keyword": "specific parameterization"},
{"keyword": "specific part"},
{"keyword": "specific series fulfilling"},
{"keyword": "specific tactic support"},
{"keyword": "specific variants"},
{"keyword": "specification decomposition principles"},
{"keyword": "specification holds"},
{"keyword": "specification language"},
{"keyword": "specification language statecharts"},
{"keyword": "specification language tla"},
{"keyword": "specification mechanism"},
{"keyword": "specifies compilation"},
{"keyword": "spectral gap"},
{"keyword": "spectral radius"},
{"keyword": "spectral radius theory"},
{"keyword": "spectral theorem states"},
{"keyword": "spectre benchmark"},
{"keyword": "speculative execution"},
{"keyword": "speculative linearizability framework"},
{"keyword": "splay heaps"},
{"keyword": "splay trees"},
{"keyword": "splitting compilation"},
{"keyword": "sqrt sin"},
{"keyword": "square complex matrix"},
{"keyword": "square integrable functions"},
{"keyword": "square matrices form"},
{"keyword": "square roots"},
{"keyword": "square-free factorization algorithm"},
{"keyword": "square-free part"},
{"keyword": "squarefree integers"},
{"keyword": "squares"},
{"keyword": "squares euclid"},
{"keyword": "squares problem"},
{"keyword": "squares theorem"},
{"keyword": "ssa"},
{"keyword": "ssst22 anders schlichtkrull"},
{"keyword": "stability"},
{"keyword": "stable configuration"},
{"keyword": "stable property detection"},
{"keyword": "standalone code generation target"},
{"keyword": "standard"},
{"keyword": "standard algorithms textbooks"},
{"keyword": "standard approach"},
{"keyword": "standard arithmetic"},
{"keyword": "standard axiomatisation"},
{"keyword": "standard boolean algebra operations"},
{"keyword": "standard borel space"},
{"keyword": "standard compliant formalization"},
{"keyword": "standard construction"},
{"keyword": "standard definitions"},
{"keyword": "standard disassembly tool objdump"},
{"keyword": "standard dolev-yao"},
{"keyword": "standard estimations"},
{"keyword": "standard finite_map theory"},
{"keyword": "standard laws"},
{"keyword": "standard logistic function"},
{"keyword": "standard models"},
{"keyword": "standard operators"},
{"keyword": "standard prelude"},
{"keyword": "standard proof methods"},
{"keyword": "standard protocol descriptions based"},
{"keyword": "standard real cartesian model"},
{"keyword": "standard reduction path"},
{"keyword": "standard redundancy criterion"},
{"keyword": "standard restrictions"},
{"keyword": "standard security protocols"},
{"keyword": "standard semantics"},
{"keyword": "standard semirings"},
{"keyword": "standard signature algorithm"},
{"keyword": "standard superposition calculus corresponds"},
{"keyword": "standard system"},
{"keyword": "standard textbook proof"},
{"keyword": "standard textbook version"},
{"keyword": "standard theorems"},
{"keyword": "standard total-correctness hoare logic"},
{"keyword": "standard transfinite kbo"},
{"keyword": "standard two-phase slicer"},
{"keyword": "standard types"},
{"keyword": "standard verification technology"},
{"keyword": "standard versions"},
{"keyword": "standardization theorem"},
{"keyword": "standards operate"},
{"keyword": "stanford encyclopedia"},
{"keyword": "star-free regular expressions"},
{"keyword": "starting point"},
{"keyword": "state monad"},
{"keyword": "state proofs"},
{"keyword": "state sigma iff"},
{"keyword": "state sigma_a"},
{"keyword": "state space"},
{"keyword": "state transformers"},
{"keyword": "state-based non-deterministic sequential computations"},
{"keyword": "state-based semantics based"},
{"keyword": "state-merging technique"},
{"keyword": "state-normalisation allowing"},
{"keyword": "state-of-the-art automated protocol verifiers"},
{"keyword": "state-of-the-art sat-based planner"},
{"keyword": "state-of-the-art smt solvers"},
{"keyword": "state-space construction"},
{"keyword": "stateful connection semantics"},
{"keyword": "stateful intransitive noninterference"},
{"keyword": "stateful network implementation"},
{"keyword": "statement"},
{"keyword": "statement applies"},
{"keyword": "statement boundaries"},
{"keyword": "states"},
{"keyword": "states common definitions"},
{"keyword": "static analysis"},
{"keyword": "static fields"},
{"keyword": "static interprocedural slicing"},
{"keyword": "static intraprocedural slicing"},
{"keyword": "static intraprocedural slicing based"},
{"keyword": "static openflow rules"},
{"keyword": "static program analysis"},
{"keyword": "static refutational completeness"},
{"keyword": "static security type systems"},
{"keyword": "static single assignment"},
{"keyword": "static single assignment form"},
{"keyword": "static type system"},
{"keyword": "stationary distributions"},
{"keyword": "steam boiler system"},
{"keyword": "stefan schmid"},
{"keyword": "stein"},
{"keyword": "stellar quorum systems"},
{"keyword": "step functions"},
{"keyword": "step-wise refinement based"},
{"keyword": "stephanie bell"},
{"keyword": "stephen schanuel"},
{"keyword": "stepping stone"},
{"keyword": "stepwise inductive definition"},
{"keyword": "stepwise manner"},
{"keyword": "stepwise program refinement"},
{"keyword": "stepwise program refinement techniques"},
{"keyword": "stepwise refinement"},
{"keyword": "stepwise refinement based approach"},
{"keyword": "stepwise refinement techniques"},
{"keyword": "stieltjes constants"},
{"keyword": "stiffness matrix"},
{"keyword": "stiffness matrix represents"},
{"keyword": "stimulus structure"},
{"keyword": "stochastic dominance"},
{"keyword": "stochastic matrices"},
{"keyword": "stochastic matrix"},
{"keyword": "stochastic processes"},
{"keyword": "stone algebra"},
{"keyword": "stone relation algebras"},
{"keyword": "stone-cech compactification"},
{"keyword": "stone-cech extension property"},
{"keyword": "stone-kleene relation algebras"},
{"keyword": "store buffer"},
{"keyword": "store buffer forwarding"},
{"keyword": "store buffering"},
{"keyword": "stores key information"},
{"keyword": "stothers theorem"},
{"keyword": "straightforward analytic proof"},
{"keyword": "stream fusion"},
{"keyword": "stream fusion library"},
{"keyword": "stream fusion transformation"},
{"keyword": "stream processing components"},
{"keyword": "stream processing functions"},
{"keyword": "stream types"},
{"keyword": "stream versions"},
{"keyword": "streaming algorithm presented"},
{"keyword": "streamlining formal definitions"},
{"keyword": "strengthen mertens"},
{"keyword": "strict omega -categories"},
{"keyword": "strict omega -category"},
{"keyword": "strict partial orders"},
{"keyword": "strict preferences"},
{"keyword": "strict standard compliance formalization"},
{"keyword": "strict version"},
{"keyword": "stricter bound"},
{"keyword": "stricter safety guarantess"},
{"keyword": "strictly dominated"},
{"keyword": "strictly increasing"},
{"keyword": "strictly larger"},
{"keyword": "strictly satisfiable"},
{"keyword": "strictness theorem"},
{"keyword": "strips fragment"},
{"keyword": "strips soundness meta-theory"},
{"keyword": "strong duality theorem"},
{"keyword": "strong eventual consistency"},
{"keyword": "strong eventual consistency guarantees"},
{"keyword": "strong law"},
{"keyword": "strong local confluence"},
{"keyword": "strong normalization"},
{"keyword": "strong nullstellensatz"},
{"keyword": "strong properties"},
{"keyword": "strong security"},
{"keyword": "strong soundness"},
{"keyword": "strong ties"},
{"keyword": "strong versions"},
{"keyword": "stronger notion"},
{"keyword": "stronger safety guarantees"},
{"keyword": "stronger version"},
{"keyword": "strongest postconditions based"},
{"keyword": "strongly connected components"},
{"keyword": "strongly explicit construction"},
{"keyword": "strongly normalizing"},
{"keyword": "structurally recursive approach"},
{"keyword": "structure abstractly"},
{"keyword": "structure proofs"},
{"keyword": "structured framework"},
{"keyword": "structured isar proofs"},
{"keyword": "structured proof techniques"},
{"keyword": "structures"},
{"keyword": "structures play"},
{"keyword": "structures rts-categories"},
{"keyword": "stuart rankin"},
{"keyword": "study filters based"},
{"keyword": "study models"},
{"keyword": "study second-order formalisations"},
{"keyword": "studying system-level properties"},
{"keyword": "sturm proof method"},
{"keyword": "sturm-tarksi theorem forms"},
{"keyword": "stuttering"},
{"keyword": "stuttering equivalence"},
{"keyword": "stuttering equivalence afp-entry"},
{"keyword": "stuttering equivalent"},
{"keyword": "stuttering equivalent runs"},
{"keyword": "stuttering invariance central"},
{"keyword": "stuttering sampling functions"},
{"keyword": "style presented"},
{"keyword": "sub-probability mass functions"},
{"keyword": "subcategory comprised"},
{"keyword": "subject reduction property"},
{"keyword": "sublists alternately extracted"},
{"keyword": "submission"},
{"keyword": "subresultant polynomial remainder sequence"},
{"keyword": "subsequent article smooth manifolds"},
{"keyword": "subsequent formalisation"},
{"keyword": "subsequent improvements"},
{"keyword": "subset relation"},
{"keyword": "subset sum"},
{"keyword": "subseteq alpha"},
{"keyword": "subseteq alpha order-isomorphic"},
{"keyword": "substantial application"},
{"keyword": "substantial background"},
{"keyword": "substantial performance penalty"},
{"keyword": "substantial set"},
{"keyword": "substantially optimizing"},
{"keyword": "substitute hybrid games"},
{"keyword": "substructural logics"},
{"keyword": "subsumes lexicographic path orders"},
{"keyword": "subsumption order"},
{"keyword": "subsumption relations"},
{"keyword": "subsystems"},
{"keyword": "subsystems involves causality"},
{"keyword": "subterm coefficient functions"},
{"keyword": "subterm coefficients"},
{"keyword": "subterm property"},
{"keyword": "subtle algorithmic mechanisms"},
{"keyword": "subtle behaviors"},
{"keyword": "subtypes inherit"},
{"keyword": "success probability"},
{"keyword": "success probability grows exponentially"},
{"keyword": "success sensitiveness"},
{"keyword": "successful model checkers"},
{"keyword": "successful termination"},
{"keyword": "successfully analyzed threads satisfies"},
{"keyword": "successfully formalising"},
{"keyword": "successively extending"},
{"keyword": "successor function"},
{"keyword": "successor search"},
{"keyword": "sufficient condition"},
{"keyword": "sufficient criterion"},
{"keyword": "sufficiently efficient"},
{"keyword": "sufficiently good"},
{"keyword": "sufficiently large"},
{"keyword": "sufficiently large group"},
{"keyword": "sufficiently large inputs"},
{"keyword": "sufficiently nice sdss"},
{"keyword": "sufficiently rich"},
{"keyword": "suffix"},
{"keyword": "suffix comparability"},
{"keyword": "suitable choice"},
{"keyword": "suitable closure properties"},
{"keyword": "suitable denotational model"},
{"keyword": "suitable distributed system model"},
{"keyword": "suitable inductive predicate"},
{"keyword": "suitable invariants"},
{"keyword": "suitable limits"},
{"keyword": "suitable locale definitions"},
{"keyword": "suitable representative"},
{"keyword": "suitable setup"},
{"keyword": "suitable shorthand notation"},
{"keyword": "suitably extending paulson"},
{"keyword": "sum"},
{"keyword": "sum composition"},
{"keyword": "sum phi leftarrow phi"},
{"keyword": "sum psi leftarrow psi"},
{"keyword": "sum type"},
{"keyword": "sumcheck instances based"},
{"keyword": "sumcheck protocol"},
{"keyword": "summary edges"},
{"keyword": "summation bounds grow"},
{"keyword": "sunflower lemma"},
{"keyword": "superposition calculus"},
{"keyword": "superposition rules"},
{"keyword": "support"},
{"keyword": "support arbitrary nesting"},
{"keyword": "support epsilon transitions"},
{"keyword": "support negative joins"},
{"keyword": "support tostring functions"},
{"keyword": "supported unicode characters"},
{"keyword": "supporting automatic refinement"},
{"keyword": "supports low-effort security proofs"},
{"keyword": "supports mutual recursion"},
{"keyword": "supports operation"},
{"keyword": "supports range queries"},
{"keyword": "surely produce"},
{"keyword": "surjective function"},
{"keyword": "surprise hanging"},
{"keyword": "surprisingly complex proof"},
{"keyword": "survey papers monographs"},
{"keyword": "survival model"},
{"keyword": "swierczkowski ndash"},
{"keyword": "switching conveniently"},
{"keyword": "sylow p-subgroups"},
{"keyword": "sylow theorem"},
{"keyword": "symbolic computations"},
{"keyword": "symbolic execution"},
{"keyword": "symbolic execution engines"},
{"keyword": "symbolic execution step"},
{"keyword": "symbolic states"},
{"keyword": "symbolic transitions systems"},
{"keyword": "symmetric cases"},
{"keyword": "symmetric directed graphs"},
{"keyword": "symmetric multivariate polynomials"},
{"keyword": "symmetric polynomial"},
{"keyword": "symmetric polynomial combination"},
{"keyword": "symmetric range"},
{"keyword": "symmetry arguments"},
{"keyword": "symmetry properties"},
{"keyword": "symmetry property"},
{"keyword": "synchronous step semantics"},
{"keyword": "syntactic approximations"},
{"keyword": "syntactic approximations imply"},
{"keyword": "syntactic bisimulation"},
{"keyword": "syntactic context"},
{"keyword": "syntactic formula"},
{"keyword": "syntactic multiplication"},
{"keyword": "syntactic rewrite rules"},
{"keyword": "syntax syntax"},
{"keyword": "syntax tree"},
{"keyword": "syntax-independent logic infrastructure"},
{"keyword": "synthesize imperative programs"},
{"keyword": "synthetic approach"},
{"keyword": "synthetic method"},
{"keyword": "system"},
{"keyword": "system describes"},
{"keyword": "system enters"},
{"keyword": "system implies"},
{"keyword": "system types"},
{"keyword": "system verification"},
{"keyword": "systematic development"},
{"keyword": "systems communication"},
{"keyword": "systems communication patterns"},
{"keyword": "systems communication plays"},
{"keyword": "szekeres found"},
{"keyword": "szl kalm"},
{"keyword": "tableau blocks"},
{"keyword": "tableau systems"},
{"keyword": "tactic code"},
{"keyword": "tail bounds"},
{"keyword": "tail-recursive function"},
{"keyword": "tail-recursive function definitions"},
{"keyword": "tail-recursive generalization"},
{"keyword": "tail-recursive implementation"},
{"keyword": "taking advantage"},
{"keyword": "talking explicitly"},
{"keyword": "tame plane graphs"},
{"keyword": "tangent bundle"},
{"keyword": "tangent bundle tm"},
{"keyword": "target concurrent operating systems"},
{"keyword": "target imperative hol"},
{"keyword": "target language"},
{"keyword": "target language features"},
{"keyword": "target logic"},
{"keyword": "target terms"},
{"keyword": "target theory"},
{"keyword": "target-language expression"},
{"keyword": "targeted security property"},
{"keyword": "tarski-seidenberg theorem established"},
{"keyword": "tauberian theorem"},
{"keyword": "tautology elimination"},
{"keyword": "taylor expansions"},
{"keyword": "taylor models"},
{"keyword": "taylor series expansions"},
{"keyword": "teaching purposes"},
{"keyword": "technical challenge"},
{"keyword": "technical issues"},
{"keyword": "technical problems"},
{"keyword": "technical reports requiring"},
{"keyword": "technical university"},
{"keyword": "technical university munich"},
{"keyword": "technique"},
{"keyword": "technique widely applicable"},
{"keyword": "technische universit"},
{"keyword": "tedious proofs"},
{"keyword": "temporal intervals"},
{"keyword": "temporal logic"},
{"keyword": "temporal logic operators"},
{"keyword": "temporal operators"},
{"keyword": "temporal order"},
{"keyword": "temporal specification technique"},
{"keyword": "ten lemmas"},
{"keyword": "tensor analysis"},
{"keyword": "tensor product"},
{"keyword": "term focus"},
{"keyword": "term occurring"},
{"keyword": "term rewrite system cover"},
{"keyword": "term rewrite systems"},
{"keyword": "term rewriting"},
{"keyword": "term shallow-style embedding"},
{"keyword": "terminated successfully"},
{"keyword": "terminating executions"},
{"keyword": "termination behavior"},
{"keyword": "termination techniques"},
{"keyword": "termination-sensitive information flow correctness"},
{"keyword": "termination-sensitive information flow security"},
{"keyword": "terms"},
{"keyword": "terms algebraically"},
{"keyword": "terms relevant"},
{"keyword": "terms reusing"},
{"keyword": "ternary fractions"},
{"keyword": "ternary kripke frames"},
{"keyword": "ternary relation"},
{"keyword": "test check"},
{"keyword": "test decides primality"},
{"keyword": "test output formats"},
{"keyword": "test strategies"},
{"keyword": "test suite"},
{"keyword": "test vectors"},
{"keyword": "test-case generators"},
{"keyword": "test-generation techniques"},
{"keyword": "testing contexts"},
{"keyword": "tetrahedral group"},
{"keyword": "text"},
{"keyword": "text book level"},
{"keyword": "text gcd"},
{"keyword": "text introduction"},
{"keyword": "text li _ s-1"},
{"keyword": "text min"},
{"keyword": "text mod"},
{"keyword": "text mod varphi"},
{"keyword": "textbook computational complexity"},
{"keyword": "textbook first-order logic"},
{"keyword": "textbook modal logic"},
{"keyword": "textbook presentation"},
{"keyword": "textbook proof"},
{"keyword": "textbook ramsey theory"},
{"keyword": "textbook reasoning"},
{"keyword": "textbook types"},
{"keyword": "textual language"},
{"keyword": "tfrac 1 2 log"},
{"keyword": "thematic section"},
{"keyword": "theology"},
{"keyword": "theorem"},
{"keyword": "theorem 2"},
{"keyword": "theorem applying"},
{"keyword": "theorem due"},
{"keyword": "theorem implies"},
{"keyword": "theorem implies combinatorial planarity"},
{"keyword": "theorem prover"},
{"keyword": "theorem prover based"},
{"keyword": "theorem prover ehdm"},
{"keyword": "theorem relates"},
{"keyword": "theorem statement"},
{"keyword": "theorem states"},
{"keyword": "theorems hold"},
{"keyword": "theorems related"},
{"keyword": "theorems state"},
{"keyword": "theorems state propositions"},
{"keyword": "theorems stated"},
{"keyword": "theoretical computer science"},
{"keyword": "theoretical evidence"},
{"keyword": "theoretical framework"},
{"keyword": "theoretical insights"},
{"keyword": "theoretically incomparable"},
{"keyword": "theories list"},
{"keyword": "theories listinf"},
{"keyword": "theories presented"},
{"keyword": "theories presents"},
{"keyword": "theories reasoning"},
{"keyword": "theory"},
{"keyword": "theory builds"},
{"keyword": "theory change"},
{"keyword": "theory development"},
{"keyword": "theory dpt_sat_solver"},
{"keyword": "theory fair-stream"},
{"keyword": "theory file"},
{"keyword": "theory generates"},
{"keyword": "theory listinf list2"},
{"keyword": "therories describe hoare logics"},
{"keyword": "thesis linked"},
{"keyword": "thesis presents"},
{"keyword": "thick chamber complexes endowed"},
{"keyword": "thomas jech"},
{"keyword": "thread creation"},
{"keyword": "threat models"},
{"keyword": "three-party computation framework"},
{"keyword": "threshold probability"},
{"keyword": "thy -files"},
{"keyword": "thy files"},
{"keyword": "tight upper bound"},
{"keyword": "tightening linear inequalities"},
{"keyword": "tim gowers"},
{"keyword": "time"},
{"keyword": "time bounds"},
{"keyword": "time complexity"},
{"keyword": "time complexity bound"},
{"keyword": "time domain"},
{"keyword": "time events"},
{"keyword": "time frames"},
{"keyword": "time monad"},
{"keyword": "time polynomial"},
{"keyword": "time real exponents"},
{"keyword": "time sufficient properties"},
{"keyword": "timed automata"},
{"keyword": "timed automata carries"},
{"keyword": "timed automata model checking"},
{"keyword": "timed coordination"},
{"keyword": "timely dataflow"},
{"keyword": "timing functions"},
{"keyword": "timing information"},
{"keyword": "timothy gowers"},
{"keyword": "timothy gowers introduction"},
{"keyword": "title formal verification"},
{"keyword": "tla axioms"},
{"keyword": "tla specifications"},
{"keyword": "tlc model checker"},
{"keyword": "to-string functions"},
{"keyword": "tokenized json string"},
{"keyword": "tolerate faults"},
{"keyword": "tom ridge"},
{"keyword": "tool box allowing"},
{"keyword": "tool implementors"},
{"keyword": "top 100 mathematical theorems"},
{"keyword": "top 100 theorems list"},
{"keyword": "topological boolean algebras"},
{"keyword": "topological curiosity discovered"},
{"keyword": "topological groups"},
{"keyword": "topological nature"},
{"keyword": "topological proof"},
{"keyword": "topological space generated"},
{"keyword": "topological spaces"},
{"keyword": "torino group"},
{"keyword": "total"},
{"keyword": "total correctness"},
{"keyword": "total correctness based"},
{"keyword": "total correctness proof"},
{"keyword": "total learning"},
{"keyword": "total order relation"},
{"keyword": "total recursive functions"},
{"keyword": "total store order"},
{"keyword": "total supremum function"},
{"keyword": "totally ordered hoop"},
{"keyword": "totient function phi"},
{"keyword": "tour revisited"},
{"keyword": "tphols 2008 paper"},
{"keyword": "trace based"},
{"keyword": "trace inclusion checking"},
{"keyword": "trace set"},
{"keyword": "trace set inclusion"},
{"keyword": "trace set process"},
{"keyword": "trace set processes"},
{"keyword": "traceback properties"},
{"keyword": "track counter-party obligations"},
{"keyword": "traditional approach"},
{"keyword": "traditional formalisations"},
{"keyword": "traditional hoare logics"},
{"keyword": "traditional pen-and-paper-based reasoning"},
{"keyword": "traditional proof outlines"},
{"keyword": "traditional query languages"},
{"keyword": "traditional query plan optimizations"},
{"keyword": "traditional topological proof strategies"},
{"keyword": "transactional memory"},
{"keyword": "transcendence"},
{"keyword": "transcendence criteria"},
{"keyword": "transcendental numbers"},
{"keyword": "transfer package"},
{"keyword": "transferring lifted properties back"},
{"keyword": "transfinite cardinalities"},
{"keyword": "transfinite induction"},
{"keyword": "transfinite recursion"},
{"keyword": "transfinite version"},
{"keyword": "transformations"},
{"keyword": "transforming xml trees"},
{"keyword": "transient execution vulnerabilities"},
{"keyword": "transition execution function"},
{"keyword": "transition function relation"},
{"keyword": "transition paths"},
{"keyword": "transition system"},
{"keyword": "transitive class"},
{"keyword": "transitive closure"},
{"keyword": "transitive closure bypasses matrices"},
{"keyword": "transitive noninterference policies"},
{"keyword": "translate mathematical contest problems"},
{"keyword": "transparent exchange"},
{"keyword": "transport programs"},
{"keyword": "transport theorems"},
{"keyword": "transposition theorem"},
{"keyword": "travel faster"},
{"keyword": "traversing sets"},
{"keyword": "treat binding sequences"},
{"keyword": "treated abstractly"},
{"keyword": "treated implicitly"},
{"keyword": "tree automata"},
{"keyword": "tree automata apf-entry"},
{"keyword": "tree automata encodings"},
{"keyword": "tree automata technique"},
{"keyword": "tree boundaries set"},
{"keyword": "tree decomposition"},
{"keyword": "tree theorem"},
{"keyword": "tree width"},
{"keyword": "tree-regular constraints"},
{"keyword": "tree-regular languages"},
{"keyword": "triangle"},
{"keyword": "triangle constructed"},
{"keyword": "triangle counting lemma"},
{"keyword": "triangle removal lemma"},
{"keyword": "triangular numbers"},
{"keyword": "trick"},
{"keyword": "trie data structure invented"},
{"keyword": "trigger events"},
{"keyword": "trivially unsatisfiable inequality"},
{"keyword": "true preferences"},
{"keyword": "trusted base"},
{"keyword": "trusted external trusted components"},
{"keyword": "trusted randomness"},
{"keyword": "trusted reference implementation"},
{"keyword": "trustworthy procedure"},
{"keyword": "truth lemma"},
{"keyword": "tsinakis conditions"},
{"keyword": "tuples satisfying"},
{"keyword": "turing computability"},
{"keyword": "turing decidability"},
{"keyword": "turing machines"},
{"keyword": "turing machines arose"},
{"keyword": "turing reducibility"},
{"keyword": "turn outputs descriptions"},
{"keyword": "turn required"},
{"keyword": "twelve bijections"},
{"keyword": "two-argument partition function"},
{"keyword": "two-element security lattice"},
{"keyword": "two-player game trees"},
{"keyword": "two-tape oblivious turing machine"},
{"keyword": "type"},
{"keyword": "type checker"},
{"keyword": "type checking phase"},
{"keyword": "type class"},
{"keyword": "type class functions"},
{"keyword": "type class hierarchy"},
{"keyword": "type class laws"},
{"keyword": "type class real_algebra_1"},
{"keyword": "type class system"},
{"keyword": "type classes"},
{"keyword": "type classes connected"},
{"keyword": "type construction"},
{"keyword": "type constructor"},
{"keyword": "type constructor representing"},
{"keyword": "type definitions"},
{"keyword": "type inference algorithm"},
{"keyword": "type inference rules"},
{"keyword": "type information"},
{"keyword": "type preservation"},
{"keyword": "type safety"},
{"keyword": "type safety proof"},
{"keyword": "type synonym"},
{"keyword": "type system"},
{"keyword": "type system restrictions"},
{"keyword": "type theory"},
{"keyword": "type theory presented"},
{"keyword": "type-class based structures"},
{"keyword": "type-safe conversions"},
{"keyword": "typed model"},
{"keyword": "types int"},
{"keyword": "types-to-sets mechanism"},
{"keyword": "typical best-practice applications"},
{"keyword": "typical computer"},
{"keyword": "typing rules"},
{"keyword": "uiuc"},
{"keyword": "ultimately culminating"},
{"keyword": "ultimately refutational completeness"},
{"keyword": "uml class diagrams"},
{"keyword": "unbounded nondeterminism"},
{"keyword": "unbounded sequences"},
{"keyword": "unbounded version"},
{"keyword": "unboundedly long path"},
{"keyword": "unboxing optimization"},
{"keyword": "unchanged results"},
{"keyword": "uncountable transfinite sequences"},
{"keyword": "under-approximate hoare logic"},
{"keyword": "under-approximate relational logic"},
{"keyword": "undergraduate dissertation"},
{"keyword": "underlying algebra"},
{"keyword": "underlying algorithmic mechanisms"},
{"keyword": "underlying boolean algebra structure"},
{"keyword": "underlying calculus"},
{"keyword": "underlying category"},
{"keyword": "underlying commented theories"},
{"keyword": "underlying concepts"},
{"keyword": "underlying decision procedure"},
{"keyword": "underlying disambiguation strategy"},
{"keyword": "underlying graph"},
{"keyword": "underlying ideas"},
{"keyword": "underlying libraries"},
{"keyword": "underlying local hidden-variable theory"},
{"keyword": "underlying mathematical structure"},
{"keyword": "underlying ontological structure"},
{"keyword": "underlying routing protocol"},
{"keyword": "underlying theorem"},
{"keyword": "underlying theory"},
{"keyword": "underlying transition system"},
{"keyword": "understood problem"},
{"keyword": "undesirable side-effect"},
{"keyword": "undesired information leak"},
{"keyword": "undirected graph theory"},
{"keyword": "undirected graphs"},
{"keyword": "unexecutable specification"},
{"keyword": "ungeneralised counterparts"},
{"keyword": "unification algorithm"},
{"keyword": "unification problem"},
{"keyword": "unified approximation order"},
{"keyword": "unified manner"},
{"keyword": "unified modeling language"},
{"keyword": "unified policy framework"},
{"keyword": "unified translation"},
{"keyword": "unified translation approach"},
{"keyword": "unified view"},
{"keyword": "unifies previous formalisations"},
{"keyword": "uniform boundedness principle"},
{"keyword": "uniform framework"},
{"keyword": "uniform global clock"},
{"keyword": "uniform proof"},
{"keyword": "uniform semantic substrate"},
{"keyword": "uniform spaces"},
{"keyword": "uniform structures"},
{"keyword": "uniform substitution calculus"},
{"keyword": "uniform substitution principle"},
{"keyword": "uniform substitutions"},
{"keyword": "uniform substitutions substitute"},
{"keyword": "uniformly bounded"},
{"keyword": "uniformly coxeter"},
{"keyword": "unify computation models"},
{"keyword": "unify correctness statements"},
{"keyword": "unifying theories"},
{"keyword": "uninterpreted functions"},
{"keyword": "union concatenation"},
{"keyword": "unique decomposition"},
{"keyword": "unique factorization domain"},
{"keyword": "unique factorization domain form"},
{"keyword": "unique irreducible factors"},
{"keyword": "unique measure mu"},
{"keyword": "unique normal forms"},
{"keyword": "unique nu_x -"},
{"keyword": "unique program"},
{"keyword": "unique solutions"},
{"keyword": "unique squarefree decomposition"},
{"keyword": "uniquely determined polynomial combination"},
{"keyword": "uniquely determined product"},
{"keyword": "uniquely distinguish quantum states"},
{"keyword": "uniquely represented"},
{"keyword": "unit propagation"},
{"keyword": "unit resolution"},
{"keyword": "unit vector"},
{"keyword": "univariate integer polynomials mod"},
{"keyword": "univariate monic polynomial"},
{"keyword": "univariate polynomial"},
{"keyword": "universal composability framework"},
{"keyword": "universal logical reasoning"},
{"keyword": "universal partial recursive function"},
{"keyword": "universal properties"},
{"keyword": "universal property"},
{"keyword": "universal tool"},
{"keyword": "universal turing machine"},
{"keyword": "universal turing machine entry"},
{"keyword": "universally quantified uninterpreted terms"},
{"keyword": "universit paris vii"},
{"keyword": "university-level computer science curriculum"},
{"keyword": "unlabeled trees"},
{"keyword": "unlike dedekind cuts"},
{"keyword": "unlike traditional decision procedures"},
{"keyword": "unlike treaps"},
{"keyword": "unnamed initial segment"},
{"keyword": "unordered pairs"},
{"keyword": "unprecedented time"},
{"keyword": "unpublished specialized algorithms"},
{"keyword": "unrelated times"},
{"keyword": "unrestricted resolution rule"},
{"keyword": "unrestricted rules"},
{"keyword": "unsolvable system"},
{"keyword": "unsorted first-order logic"},
{"keyword": "unsorted list deterministically"},
{"keyword": "untrusted mathsf approxmc implementations"},
{"keyword": "unverified checkers"},
{"keyword": "unverified monitoring tool whymon"},
{"keyword": "unverified reference implementation"},
{"keyword": "unverified ssa construction algorithm"},
{"keyword": "unverified tools"},
{"keyword": "unverified translation"},
{"keyword": "unwanted subtleties"},
{"keyword": "unwinding method"},
{"keyword": "unwinding results"},
{"keyword": "unwinding theorem"},
{"keyword": "up-closed sets"},
{"keyword": "upcoming entry iptables semantics"},
{"keyword": "upcoming work principia logico-metaphysica"},
{"keyword": "upcrossing inequality"},
{"keyword": "update constant pattern"},
{"keyword": "update functions"},
{"keyword": "updated april 7th"},
{"keyword": "updated version"},
{"keyword": "updown scheme"},
{"keyword": "upf emphasizes"},
{"keyword": "upper bound"},
{"keyword": "upper semicontinuous"},
{"keyword": "upper triangular"},
{"keyword": "upper-bound remains valid"},
{"keyword": "usable framework"},
{"keyword": "useless zero-reductions"},
{"keyword": "user command"},
{"keyword": "usual definitions"},
{"keyword": "usual monad laws"},
{"keyword": "usual programming constructs"},
{"keyword": "usual redundancy criteria based"},
{"keyword": "usual redundancy elimination rules"},
{"keyword": "usual semantics"},
{"keyword": "usual set operations union"},
{"keyword": "utility functions"},
{"keyword": "utility functions form"},
{"keyword": "utilizing modern proof assistants"},
{"keyword": "uwe waldmann"},
{"keyword": "valid completeness threshold"},
{"keyword": "valid formula"},
{"keyword": "valid octet quot"},
{"keyword": "valid parameters"},
{"keyword": "validate termination"},
{"keyword": "value-dependent noninterference property"},
{"keyword": "van der waerden"},
{"keyword": "van der waerden number"},
{"keyword": "van emde boas tree"},
{"keyword": "van oostrom"},
{"keyword": "vandermonde identity"},
{"keyword": "vandermonde matrices"},
{"keyword": "varepsilon 0"},
{"keyword": "variable assignment"},
{"keyword": "variable convention"},
{"keyword": "variable-for-variable substitution"},
{"keyword": "variants"},
{"keyword": "varphi_i vee mathbf"},
{"keyword": "varying numbers"},
{"keyword": "vcg auction"},
{"keyword": "vdash psi"},
{"keyword": "vdash varphi longrightarrow"},
{"keyword": "vdm-reminiscent partial-correctness specifications"},
{"keyword": "veblen hierarchies"},
{"keyword": "vector cross product"},
{"keyword": "vector fields"},
{"keyword": "vector space"},
{"keyword": "verification back-ends"},
{"keyword": "verification components"},
{"keyword": "verification condition generation"},
{"keyword": "verification condition generator"},
{"keyword": "verification condition generators producing"},
{"keyword": "verification conditions"},
{"keyword": "verification conditions generated"},
{"keyword": "verification operation"},
{"keyword": "verification techniques"},
{"keyword": "verification tools"},
{"keyword": "verified"},
{"keyword": "verified algorithms"},
{"keyword": "verified approach"},
{"keyword": "verified certificate checker"},
{"keyword": "verified checker past"},
{"keyword": "verified code"},
{"keyword": "verified compilation toolchain"},
{"keyword": "verified compiler"},
{"keyword": "verified construction"},
{"keyword": "verified decision procedures"},
{"keyword": "verified functional skew heaps"},
{"keyword": "verified functional splay trees"},
{"keyword": "verified heap functions"},
{"keyword": "verified implementation"},
{"keyword": "verified iptables firewall analysis"},
{"keyword": "verified monitor"},
{"keyword": "verified monitor implements"},
{"keyword": "verified parser generator"},
{"keyword": "verified programs"},
{"keyword": "verified refinement step"},
{"keyword": "verified runtime bounds"},
{"keyword": "verified ssa construction"},
{"keyword": "verified tool"},
{"keyword": "verified translation"},
{"keyword": "verified type checker"},
{"keyword": "verified virtual machines"},
{"keyword": "verifies infinite families"},
{"keyword": "verify algorithms"},
{"keyword": "verify axioms"},
{"keyword": "verify basic algorithms"},
{"keyword": "verify first-order relativity theory"},
{"keyword": "verify properties"},
{"keyword": "verify purely functional"},
{"keyword": "verify spoofing protection"},
{"keyword": "verify theorems"},
{"keyword": "verify truth tables"},
{"keyword": "verify-- philosophical arguments"},
{"keyword": "verifying correctness"},
{"keyword": "verifying depth-"},
{"keyword": "verifying dynamic"},
{"keyword": "verifying functional"},
{"keyword": "verifying functional programs"},
{"keyword": "verifying network security policies"},
{"keyword": "verifying practical algorithms"},
{"keyword": "verifying program correctness"},
{"keyword": "verifying relative security"},
{"keyword": "verifying safety properties"},
{"keyword": "verifying security policies"},
{"keyword": "verifying stateful security protocols"},
{"keyword": "verifying techniques"},
{"keyword": "verifying uri nodelman"},
{"keyword": "verifythis competition series"},
{"keyword": "version due"},
{"keyword": "version states"},
{"keyword": "vertex count"},
{"keyword": "vertex set"},
{"keyword": "vertical composite"},
{"keyword": "vertical residuation"},
{"keyword": "view sorted sets"},
{"keyword": "vincent bloemen"},
{"keyword": "vincent rahli"},
{"keyword": "violate sortedness"},
{"keyword": "virtual methods"},
{"keyword": "visualizing class models"},
{"keyword": "vital part"},
{"keyword": "viterbi algorithm"},
{"keyword": "volpano smith system"},
{"keyword": "volpano smith-style noninterference notions"},
{"keyword": "volume greater"},
{"keyword": "volume proofs"},
{"keyword": "von lindemann"},
{"keyword": "von neumann hierarchy"},
{"keyword": "von neumann measurements"},
{"keyword": "von wright"},
{"keyword": "von zur gathen"},
{"keyword": "von-neumann-morgenstern utility theorem"},
{"keyword": "vstte paper"},
{"keyword": "vy-prokhorov metric"},
{"keyword": "w_1 ldots w_n 1"},
{"keyword": "w_i a_i"},
{"keyword": "weak bi-quantales"},
{"keyword": "weak bisimilarity"},
{"keyword": "weak conjunction"},
{"keyword": "weak conjunction operator"},
{"keyword": "weak conjunction operator coincides"},
{"keyword": "weak convergence"},
{"keyword": "weak duality theorem"},
{"keyword": "weak form"},
{"keyword": "weak hol"},
{"keyword": "weak law"},
{"keyword": "weak nullstellensatz"},
{"keyword": "weak preferences"},
{"keyword": "weak simulation"},
{"keyword": "weak topologies"},
{"keyword": "weak topology induced"},
{"keyword": "weaker statement contained"},
{"keyword": "weaker variants"},
{"keyword": "weakest precondition component"},
{"keyword": "weakest-precondition entailment"},
{"keyword": "weakly monotone setting"},
{"keyword": "web community"},
{"keyword": "web components"},
{"keyword": "web standards"},
{"keyword": "webassembly language"},
{"keyword": "weight-balanced trees"},
{"keyword": "weighted arithmetic geometric"},
{"keyword": "weighted graphs"},
{"keyword": "weighted path order"},
{"keyword": "welfare economics holds"},
{"keyword": "well-formedness properties"},
{"keyword": "well-order relation"},
{"keyword": "well-ordered type"},
{"keyword": "well-typed attacks"},
{"keyword": "well-typed programs"},
{"keyword": "well-understood low-level behavior"},
{"keyword": "wide design space"},
{"keyword": "wide range"},
{"keyword": "wide variety"},
{"keyword": "widely applicable"},
{"keyword": "widely studied topic"},
{"keyword": "widening operation"},
{"keyword": "wider scope"},
{"keyword": "wieferich kempner theorem"},
{"keyword": "wikipedia articles"},
{"keyword": "wilf theorem"},
{"keyword": "wim20 simon wimmer"},
{"keyword": "wimmer wim20"},
{"keyword": "wimmers archive-of-graph-formalizations"},
{"keyword": "winding number"},
{"keyword": "winding number measures"},
{"keyword": "wireless mesh network"},
{"keyword": "wireless networks"},
{"keyword": "wireless protocols"},
{"keyword": "witnessing diamonds"},
{"keyword": "wolfram engine"},
{"keyword": "woots strong eventual consistency"},
{"keyword": "word count program"},
{"keyword": "word equations"},
{"keyword": "word iff"},
{"keyword": "word inside"},
{"keyword": "word numerals"},
{"keyword": "word power"},
{"keyword": "word problem"},
{"keyword": "words lexicographically minimal"},
{"keyword": "work builds"},
{"keyword": "work comprises proofs"},
{"keyword": "work focuses"},
{"keyword": "work implements"},
{"keyword": "work presents"},
{"keyword": "work revealed minor"},
{"keyword": "worker wrapper transformation"},
{"keyword": "working backwards"},
{"keyword": "working mathematician"},
{"keyword": "works based"},
{"keyword": "world code"},
{"keyword": "worst case"},
{"keyword": "worst-case optimal multiway-join algorithms"},
{"keyword": "worst-case time"},
{"keyword": "worst-time complexity"},
{"keyword": "wpo subsumes kbo"},
{"keyword": "write access"},
{"keyword": "write alpha"},
{"keyword": "write mathcal"},
{"keyword": "write operations"},
{"keyword": "write poof strategies"},
{"keyword": "write specifications"},
{"keyword": "written standard"},
{"keyword": "x1j hellip"},
{"keyword": "x1n hellip"},
{"keyword": "x86-64 assembly instructions"},
{"keyword": "x_1"},
{"keyword": "x_1 exists"},
{"keyword": "x_1 varepsilon"},
{"keyword": "xml trees"},
{"keyword": "yacc style grammars"},
{"keyword": "yamada 2"},
{"keyword": "years formal verification"},
{"keyword": "yet-to-be-explored states"},
{"keyword": "yielding dynamic programming algorithms"},
{"keyword": "yielding significant state-space reduction"},
{"keyword": "yoneda embedding preserves limits"},
{"keyword": "yoneda functor"},
{"keyword": "yoneda lemma"},
{"keyword": "yosuke-ito-345 actuary"},
{"keyword": "yufei zhao"},
{"keyword": "zermelo-fraenkel set theory"},
{"keyword": "zero-free region"},
{"keyword": "zeroth frequency moment"},
{"keyword": "zf set theory"},
{"keyword": "zfc set theory"},
{"keyword": "zout domains"}]